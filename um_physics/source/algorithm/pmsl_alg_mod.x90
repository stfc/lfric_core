!-------------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------
!> @brief Holds code to calculate PMSL

module pmsl_alg_mod

  use field_mod,               only: field_type
  use field_collection_mod,    only: field_collection_type
  use io_config_mod,           only: write_diag, use_xios_io,subroutine_timers
  use field_parent_mod,        only: write_interface
  use lfric_xios_write_mod,    only: write_field_single_face
  use timer_mod,               only: timer
  use extrusion_config_mod,    only: number_of_layers, domain_top
  use constants_mod,           only: r_def, i_def
  use level_heights_mod,       only: eta_theta_levels
  use geometric_constants_mod, only: get_height
  use fs_continuity_mod,       only: Wtheta, W3
  use function_space_collection_mod, only: function_space_collection
  use mesh_mod,                only: mesh_type

  implicit none
  private

  public :: pmsl_alg

contains

  !> @brief Calculate pressure at mean sea level
  !> @details Basic formation is based on the old UM diagnostic which is
  !>          described in UM Documentation Paper 80.
  !>          https://code.metoffice.gov.uk/doc/um/latest/papers/umdp_080.pdf
  !>          Initial version just calculates PMSL with no smoothing over
  !>          high ground. The UM diagnostic included smoothing of the field
  !>          for orography over 500m. This will be added later.
  !> @param[in]  exner_w3        exner pressure in w3 space
  !> @param[in]  derived_fields  Group of derived fields
  !> @param[in]  theta_wth       potential temperature
  !> @param[in]  twod_mesh       Current 2d mesh

  subroutine pmsl_alg(exner_w3, derived_fields, theta_wth, twod_mesh)

    use pmsl_kernel_mod, only: pmsl_kernel_type

    implicit none

    ! Arguments

    type( field_type ), intent(in)            :: exner_w3
    type( field_collection_type ), intent(in) :: derived_fields
    type( field_type ), intent(in)            :: theta_wth
    type( mesh_type ),  intent(in), pointer   :: twod_mesh

    ! Define PMSL field
    type( field_type )                        :: pmsl

    ! Internal variables

    type( field_type ), pointer     :: exner_wth  => null()
    type( field_type ), pointer     :: height_w3 => null()
    type( field_type ), pointer     :: height_wth => null()
    procedure(write_interface), pointer :: write_diag_behaviour => null()

    integer(kind=i_def) :: k, levelupper

    ! Height of upper level above ground
    ! Settting to same value as used in UM code

    real(kind=r_def), parameter :: upperheight=2000.0_r_def

    if ( subroutine_timers ) call timer('pmsl_alg')

    ! Unpack fields
    exner_wth       => derived_fields%get_field('exner_in_wth')
    height_w3       => get_height(W3, exner_w3%get_mesh_id())
    height_wth      => get_height(Wtheta, theta_wth%get_mesh_id())

    ! Set up PMSL field and make it writeable
    call pmsl%initialise( vector_space = &
                    function_space_collection%get_fs(twod_mesh, 0, W3) )

    ! Find level above boundary layer to use in PMSL calculation
    ! domain_top is the top model height and is the same everywhere

    DO k = 1, number_of_layers
      levelupper = k
      IF (domain_top * eta_theta_levels(k) > upperheight) EXIT
    END DO

    ! Call kernel to calculate PMSL

    call invoke(pmsl_kernel_type(exner_w3, exner_wth, theta_wth, &
                height_w3, height_wth, levelupper, pmsl))

    ! Output diagnostic if requested
    if (write_diag .and. use_xios_io) then
      write_diag_behaviour => write_field_single_face
      call pmsl%set_write_behaviour(write_diag_behaviour)
      call pmsl%write_field('processed__pmsl')
    end if

    if ( subroutine_timers ) call timer('pmsl_alg')

  end subroutine pmsl_alg

end module pmsl_alg_mod
