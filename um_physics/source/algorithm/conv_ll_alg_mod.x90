!-------------------------------------------------------------------------------
! (c) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------

!> @brief Interface to the UM convection scheme

module conv_ll_alg_mod

  use constants_mod,        only: i_def,
  use field_mod,            only: field_type
  use field_collection_mod, only: field_collection_type
  use mr_indices_mod,       only: nummr, imr_v, imr_cl
  use timestepping_config_mod, only: outer_iterations
  use io_config_mod,        only: subroutine_timers
  use timer_mod,            only: timer
  ! xios output
  use io_config_mod,      only: write_diag, use_xios_io

  implicit none

  private

  public conv_ll_alg_step

contains

  !> @brief Run the Lambert-Lewis convection scheme
  !> @details The Lambert-Lewis convection scheme is a simple
  !>           convection parametrization that mixes theta and moisture
  !>           as documented in UMDP41
  !> @param[in,out] mr             Mixing ratios
  !> @param[in]     exner          Exner pressure field in density (w3) space
  !> @param[in]     derived_fields Group of derived fields
  !> @param[in,out] convection_fields Fields for convection scheme
  !> @param[in]     outer          Outer loop counter
  subroutine conv_ll_alg_step(mr, exner, derived_fields, convection_fields,    &
                              outer)

    use conv_ll_kernel_mod, only: conv_ll_kernel_type

    implicit none

    type( field_type ), intent( inout )          :: mr(nummr)
    type( field_type ), intent( in )             :: exner

    type( field_collection_type ), intent(in)    :: derived_fields
    type( field_collection_type ), intent(inout) :: convection_fields

    integer(kind=i_def), intent(in)              :: outer

    ! Temporary fields unpacked from collections
    type( field_type ), pointer :: exner_in_wth  => null()
    type( field_type ), pointer :: theta_star => null()
    type( field_type ), pointer :: dt_conv => null()
    type( field_type ), pointer :: dmv_conv => null()
    type( field_type ), pointer :: dmcl_conv => null()
    type( field_type ), pointer :: conv_rain => null()
    type( field_type ), pointer :: conv_snow => null()

    if ( subroutine_timers ) call timer("conv_ll_alg_step")

    ! Unpack fields
    exner_in_wth => derived_fields%get_field('exner_in_wth')
    theta_star => derived_fields%get_field('theta_star')

    dt_conv => convection_fields%get_field('dt_conv')
    dmv_conv => convection_fields%get_field('dmv_conv')
    dmcl_conv => convection_fields%get_field('dmcl_conv')
    conv_rain => convection_fields%get_field('conv_rain')
    conv_snow => convection_fields%get_field('conv_snow')

    call invoke(conv_ll_kernel_type(dt_conv, dmv_conv, dmcl_conv,             &
                                    theta_star, mr(imr_v), mr(imr_cl),        &
                                    exner_in_wth, exner, conv_rain),          &
                ! update mixing ratios with convection increments here
                inc_X_plus_Y(mr(imr_v), dmv_conv),                            &
                inc_X_plus_Y(mr(imr_cl),dmcl_conv) )

    if (write_diag .and. use_xios_io .and. outer == outer_iterations) then
      call dt_conv%write_field('dt_conv')
      call dmv_conv%write_field('dmv_conv')
      call conv_rain%write_field('conv_rain')
      call conv_snow%write_field('conv_snow')
    end if

    if ( subroutine_timers ) call timer("conv_ll_alg_step")

  end subroutine conv_ll_alg_step

end module conv_ll_alg_mod
