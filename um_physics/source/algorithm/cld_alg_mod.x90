!-------------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------

!> @brief Interface to the UM diagnostic and prognostic cloud schemes

module cld_alg_mod

  use constants_mod, only: i_def
  use field_mod, only: field_type
  use field_collection_mod,         only: field_collection_type
  use mr_indices_mod,               only: nummr, imr_v, imr_cl, imr_ci
  use io_config_mod,                only: subroutine_timers
  use timer_mod,                    only: timer
  use cloud_config_mod,             only: scheme,                        &
                                          scheme_smith,                  &
                                          scheme_pc2
  use pc2_initiation_alg_mod,       only: pc2_initiation_alg_step
  use pc2_pressure_forcing_alg_mod, only: pc2_pressure_forcing_alg_step
  use physics_mappings_alg_mod,     only: map_physics_scalars

  implicit none

  public cld_alg_step

contains

  !>@brief Run the UM Large-scale diagnostic or (parts of) prognostic cloud scheme
  !>@details The UM Diagnostic cloud scheme:
  !>         generates liquid and ice cloud fraction and water content,
  !>         and adjust vapour and temperature, as described in UMDP29
  !>         (for liquid only for now).
  !>         Parts of PC2 scheme are also done here.
  !>@param[in,out] theta_inc Potential temperature increment in native space
  !>@param[in,out] mr        Mixing ratios, in theta space
  !>@param[in]     theta theta in its native space
  !>@param[in]     exner  Exner Pressure in w3 space
  !>@param[in]     derived_fields     Group of derived fields
  !>@param[in]     turbulence_fields  Fields for turbulence scheme
  !>@param[in,out] cloud_fields       Fields for cloud scheme
  !>@param[in]     theta_n theta at start of timestep in its native space
  !>@param[in]     exner_n exner at start of timestep in its native space
  !>@param[in]     mr_n micing ratios at start of timestep
  !>@param[in]     theta_after_slow theta after slow physics in theta space
  !>@param[in]     exner_after_slow exner after slow physics in w3 space

  subroutine cld_alg_step(theta_inc, mr, theta, exner,              &
                          derived_fields, turbulence_fields,        &
                          cloud_fields,                             &
                          theta_n,          exner_n, mr_n,          &
                          theta_after_slow, exner_after_slow        )

    use cld_kernel_mod, only: cld_kernel_type

    implicit none

    type( field_collection_type ), intent(in) :: derived_fields
    type( field_collection_type ), intent(in) :: turbulence_fields
    type( field_collection_type ), intent(inout) :: cloud_fields

    type( field_type ), intent( inout ) :: theta_inc, mr(nummr)

    ! Convention for 6 variables below is to omit their function space
    ! in their name if they are in native space. However, variable name
    ! states when in timestep variable is valid.
    type( field_type ), intent( in )    :: theta            ! Current value wth
    type( field_type ), intent( in )    :: exner            ! Current value w3
    type( field_type ), intent( in )    :: theta_n          ! Start of TS wth
    type( field_type ), intent( in )    :: exner_n          ! Start of TS w3
    type( field_type ), intent( in )    :: mr_n(nummr)      ! Start of TS
    type( field_type ), intent( in )    :: theta_after_slow ! After slowphys wth
    type( field_type ), intent( in )    :: exner_after_slow ! After slowphys w3

    ! 2 variables below are for remapping from w3 to wth.
    type( field_type ) :: exner_wth                         ! Current
    type( field_type ) :: exner_after_slow_wth              ! After slowphys

    type( field_type ), pointer :: cf_area  => null()
    type( field_type ), pointer :: cf_ice  => null()
    type( field_type ), pointer :: cf_liq  => null()
    type( field_type ), pointer :: cf_bulk  => null()
    type( field_type ), pointer :: ntml => null()
    type( field_type ), pointer :: cumulus => null()
    type( field_type ), pointer :: rh_crit => null()

    type( field_type ) :: dtheta_pc2_inc
    type( field_type ) :: dtheta_pc2_inc_pres
    type( field_type ) :: theta_updated

    if ( subroutine_timers ) call timer('cld_alg_step')

    call theta%copy_field_properties(exner_wth)
    call map_physics_scalars(exner_wth, exner)

    if (scheme == scheme_smith) then

      cf_area => cloud_fields%get_field('area_fraction')
      cf_ice => cloud_fields%get_field('ice_fraction')
      cf_liq => cloud_fields%get_field('liquid_fraction')
      cf_bulk => cloud_fields%get_field('bulk_fraction')
      rh_crit => cloud_fields%get_field('rh_crit')

      ntml => turbulence_fields%get_field('ntml')
      cumulus => turbulence_fields%get_field('cumulus')

      call invoke( cld_kernel_type( theta, exner , exner_wth, rh_crit,         &
                                    ntml, cumulus, mr(imr_v), mr(imr_cl),      &
                                    mr(imr_ci), cf_area, cf_ice, cf_liq,       &
                                    cf_bulk, theta_inc)   )

    else if (scheme == scheme_pc2) then

      call theta%copy_field_properties(exner_after_slow_wth)
      call map_physics_scalars(exner_after_slow_wth, exner_after_slow)

      call theta%copy_field_properties(dtheta_pc2_inc_pres)
      call invoke( setval_c(dtheta_pc2_inc_pres,   0.0_r_def) )

      ! Do PC2 Pressure forcing
      call pc2_pressure_forcing_alg_step( mr,                      & ! IN
                                          theta,                   & ! IN
                                          theta_after_slow,        & ! IN
                                          exner_wth,               & ! IN wth
                                          exner_after_slow_wth,    & ! IN
                                          cloud_fields,            & ! INOUT
                                          dtheta_pc2_inc_pres )      ! OUT

      ! Temporary value of theta to be updated with increment from
      ! pressure forcing for use as input for initiation.
      call theta%copy_field(theta_updated)
      call invoke( inc_X_plus_Y(theta_updated, dtheta_pc2_inc_pres) )

      ! Now do PC2 initiation (and checks)
      call pc2_initiation_alg_step( mr,                  & ! INOUT Current
                                    theta_updated,       & ! IN    Updated
                                    exner,               & ! IN    Current exner w3
                                    exner_wth,           & ! IN    Current exner wth
                                    mr_n,                & ! IN    Start of timestep
                                    theta_n,             & ! IN    Start of timestep
                                    derived_fields,      & ! IN
                                    turbulence_fields,   &
                                    cloud_fields,        & ! INOUT
                                    theta_inc )            ! OUT

      call invoke( inc_X_plus_Y(theta_inc,    dtheta_pc2_inc_pres) )

    end if

    if ( subroutine_timers ) call timer('cld_alg_step')

  end subroutine cld_alg_step

end module cld_alg_mod
