!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Compute the advective increment u.grad(f) for a wind field
!!        u and tracer f.

module tl_advective_increment_alg_mod

  implicit none

  private

  public :: tl_advective_increment_alg

contains

  !> @details Algorithm that uses the method-of-lines scheme to
  !!          compute the advective increment, u.grad(f), of field f
  !!          and wind u.
  !> @param[in,out] advective_increment ACTIVE Increment wind.grad(field)
  !> @param[in]     field               ACTIVE Field to compute the increment from
  !> @param[in]     wind                ACTIVE Advecting wind
  !> @param[in]     ls_field            PASSIVE Linearisation state advected field
  !> @param[in]     ls_wind             PASSIVE Linearisation state advecting wind
  !> @param[in]     dt                  Advection time step
  !> @param[in]     direction           Direction to perform the advective update
  !> @param[in]     reversible          Flag to use reversible scheme
  !> @param[in]     logspace            Flag to use logspace for
  !> @param[in]     monotonicity        Flag to apply monotonicity
  subroutine tl_advective_increment_alg(advective_increment, field, wind, &
                                        ls_field, ls_wind, dt, direction, &
                                        reversible, logspace, monotonicity)

    use constants_mod,                   only: r_def, i_def, l_def
    use field_mod,                       only: field_type
    use log_mod,                         only: log_event, &
                                               LOG_LEVEL_ERROR
    use reconstruct_w3_field_alg_mod,    only: reconstruct_w3_field_alg
    use tl_reconstruct_w3_field_alg_mod, only: tl_reconstruct_w3_field_alg
    use w3_advective_update_kernel_mod,  only: w3_advective_update_kernel_type
    use tl_wt_advective_update_alg_mod,  only: tl_wt_advective_update_alg
    use fs_continuity_mod,               only: W3, Wtheta
    use operator_mod,                    only: operator_type
    use fem_constants_mod,               only: get_inverse_w3_mass_matrix

    implicit none

    type(field_type),    intent(inout) :: advective_increment
    type(field_type),    intent(in)    :: field, wind
    type(field_type),    intent(in)    :: ls_field, ls_wind
    real(kind=r_def),    intent(in)    :: dt
    integer(kind=i_def), intent(in)    :: direction
    logical(kind=l_def), intent(in)    :: reversible
    logical(kind=l_def), intent(in)    :: logspace
    integer(kind=i_def), intent(in)    :: monotonicity

    type(field_type)             :: recon_ls_tracer, recon_tracer
    type(field_type)             :: adv_inc_ls_tracer, adv_inc_tracer
    type(operator_type), pointer :: m3_inv => null()

    select case ( field%which_function_space() )

      case ( W3 )
        call adv_inc_tracer%initialise( field%get_function_space() )
        call adv_inc_ls_tracer%initialise( field%get_function_space() )
        call recon_tracer%initialise( wind%get_function_space() )
        call recon_ls_tracer%initialise( wind%get_function_space() )
        m3_inv => get_inverse_w3_mass_matrix( field%get_mesh_id() )

        ! Calculate reconstructions
        ! ls wind is still used here to define upwind direction
        call reconstruct_w3_field_alg(recon_ls_tracer, ls_field, ls_wind, &
                                      direction, reversible, logspace)
        call tl_reconstruct_w3_field_alg(recon_tracer, field, ls_field,   &
                                         ls_wind, direction, reversible, logspace)

        ! Compute increments
        call invoke( w3_advective_update_kernel_type(adv_inc_tracer,        &
                                                     recon_tracer, ls_wind, &
                                                     m3_inv),               &
                     w3_advective_update_kernel_type(adv_inc_ls_tracer,     &
                                                     recon_ls_tracer, wind, &
                                                     m3_inv),               &
        ! Obtain final increment by combining these two:
        ! df' = ls_u.grad(f') + u'.grad(ls_f) )
                     X_plus_Y(advective_increment,                          &
                              adv_inc_tracer, adv_inc_ls_tracer) )

        nullify(m3_inv)

      case ( Wtheta )

        ! Everything is handled by T.L. version of Wtheta advective update alg
        call tl_wt_advective_update_alg(advective_increment, field, wind, &
                                        ls_field, ls_wind, dt, direction, &
                                        reversible, logspace, monotonicity)

      case default
        call log_event( "Advective increment only valid for W3 & Wtheta spaces", LOG_LEVEL_ERROR )

    end select

  end subroutine tl_advective_increment_alg

end module tl_advective_increment_alg_mod
