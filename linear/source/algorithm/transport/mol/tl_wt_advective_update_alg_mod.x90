!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Tangent linear for the advective update A of a variable f by a wind U
!!        Nonlinear code is A = U.grad(f)
!!        Linear code is    A = U.grad(ls_f) + ls_U.grad(f)
!> @todo There are number of workarounds in this algorithm for aspects which
!!       aren't yet supported by PSyclone/LFRic:
!!       1. Issue #868 Multidata fields are not natively supported in PSyclone.
!!                     Currently we treat these as normal fields but need to
!!                     additionally pass in ndata_h or ndata_v to the kernels
!!                     as extra integer arguments.
!!       2. Issue #1246 Region stencils require both the global maximum size of
!!                      the stencil and local column size of the stencil.
!!                      PSyclone currently only passes in the local size and so
!!                      until this is resolved we also pass in the global maximum
!!                      size as an integer argument.
module tl_wt_advective_update_alg_mod

  use constants_mod,                      only: r_def, i_def, l_def
  use fem_constants_mod,                  only: get_inverse_lumped_mass_matrix
  use field_mod,                          only: field_type
  use finite_element_config_mod,          only: element_order
  use fs_continuity_mod,                  only: W1, Wtheta
  use function_space_mod,                 only: function_space_type
  use function_space_collection_mod,      only: function_space_collection
  use transport_config_mod,               only: operators,            &
                                                fv_horizontal_order,  &
                                                fv_vertical_order,    &
                                                operators_fv,         &
                                                operators_fem,        &
                                                consistent_metric
  use log_mod,                            only: log_event,         &
                                                LOG_LEVEL_ERROR
  use tl_poly_advective_kernel_mod,       only: tl_poly_advective_kernel_type
  use tl_poly1d_vert_adv_kernel_mod,      only: tl_poly1d_vert_adv_kernel_type
  use transport_enumerated_types_mod,     only: direction_v,    &
                                                direction_h,    &
                                                direction_3d
  use wt_advective_update_alg_mod,        only: get_adv_ndata_v,                &
                                                get_vert_adv_coeffs,            &
                                                get_reversible_adv_ndata_v,     &
                                                get_reversible_vert_adv_coeffs, &
                                                horizontal_wt_reconstruct_alg

  implicit none

  private

  public :: tl_wt_advective_update_alg

contains

  !=============================================================================
  !> @brief Compute advective update of a Wtheta field for tangent linear app.
  !> @details Compute tangent linear advective update using desired spatial
  !!          reconstruction. Options for this are either FE or FV reconstructions.
  !!          A monotonicity filter is also optionally applied
  !> @param[in,out] rhs          ACTIVE Change in Advective increment
  !> @param[in]     adv_field    ACTIVE Change in Field to advect
  !> @param[in]     wind         ACTIVE Change in Advecting wind field
  !> @param[in]     ls_adv_field Lin state for Field to advect
  !> @param[in]     ls_wind      Lin state for Advecting wind field
  !> @param[in]     dt           Timestep
  !> @param[in]     direction    Direction of the transport
  !> @param[in]     reversible   Use the reversible reconstruction
  !> @param[in]     logspace     Carry out interpolation in log space
  !> @param[in]     monotonicity Choice of monontonic limiter
  subroutine tl_wt_advective_update_alg(rhs, adv_field, wind,    &
                                        ls_adv_field, ls_wind,   &
                                        dt, direction, reversible, &
                                        logspace, monotonicity)


    use reference_element_mod,          only: reference_element_type
    use mesh_mod,                       only: mesh_type
    use transport_enumerated_types_mod, only: monotone_none, &
                                              monotone_clipping

    implicit none

    type(field_type),              intent(in)    :: adv_field, wind
    type(field_type),              intent(in)    :: ls_adv_field, ls_wind
    type(field_type),              intent(inout) :: rhs
    real(kind=r_def),              intent(in)    :: dt
    integer(kind=i_def),           intent(in)    :: direction
    logical(kind=l_def),           intent(in)    :: reversible
    logical(kind=l_def), optional, intent(in)    :: logspace
    integer(kind=i_def), optional, intent(in)    :: monotonicity

    type(field_type)                       :: u_grad_f
    type(field_type)                       :: h_reconstruction
    type(field_type)                       :: ls_h_reconstruction
    type(field_type), pointer              :: chi(:) => null()
    type(field_type), pointer              :: mt_lumped_inv => null()
    type(field_type)                       :: consistent_wind
    type(field_type)                       :: ls_consistent_wind
    type(field_type), pointer              :: vert_adv_coeffs => null()
    type(field_type), pointer              :: chi3_at_wt => null()
    type(function_space_type), pointer     :: w1_fs => null()
    class(reference_element_type), pointer :: reference_element => null()
    type(mesh_type), pointer               :: mesh => null()

    logical(kind=l_def)                    :: logspace_loc
    integer(kind=i_def), pointer           :: ndata_v => null()
    integer(kind=i_def)                    :: monotonicity_option
    integer(kind=i_def)                    :: vertical_order
    integer(kind=i_def)                    :: mesh_id

    logspace_loc = .false.
    if ( present(logspace) ) then
      logspace_loc = logspace
    end if
    monotonicity_option = monotone_none
    if ( present(monotonicity) ) then
      monotonicity_option = monotonicity
    end if

    mesh => wind%get_mesh()

    mesh_id = wind%get_mesh_id()

    call u_grad_f%initialise( adv_field%get_function_space() )

    select case(operators)

    case default
      call log_event( "Gungho: Unrecognised option for wtheta reconstruction.", LOG_LEVEL_ERROR )

    case(operators_fv)
      ! Consistent winds will be used for vertical transport
      ! For now set these to be the normal winds and adjust later if needed
      call ls_consistent_wind%initialise( ls_wind%get_function_space() )
      call invoke( setval_X(ls_consistent_wind, ls_wind) )
      call consistent_wind%initialise( wind%get_function_space() )
      call invoke( setval_X(consistent_wind, wind) )


      if ( direction == direction_3d .or. direction == direction_h ) then
        w1_fs => function_space_collection%get_fs( mesh, element_order, W1 )
        call h_reconstruction%initialise( w1_fs )
        call ls_h_reconstruction%initialise( w1_fs )
        ! Horizontal update, to reconstruct adv_field and ls_adv_field in W1
        ! ls_wind here is used to define upwind direction
        call horizontal_wt_reconstruct_alg(h_reconstruction, ls_wind, adv_field)
        call horizontal_wt_reconstruct_alg(ls_h_reconstruction, ls_wind, ls_adv_field)
        ! Combine to get horizontal part of ls_u.grad(f) + u.grad(ls_f)
        call invoke( tl_poly_advective_kernel_type( u_grad_f,         &
                                                    wind,             &
                                                    h_reconstruction, &
                                                    ls_wind,          &
                                                    ls_h_reconstruction) )

        ! Adjust consistent wind fields
        if ( consistent_metric ) then
          call log_event( "TL: consistent metrics not available", LOG_LEVEL_ERROR )
        end if
      else
        call invoke( setval_c( u_grad_f, 0.0_r_def ) )
      end if

      if ( direction == direction_3d .or. direction == direction_v ) then
        ! vertical update
        if ( reversible ) then
          ndata_v => get_reversible_adv_ndata_v(mesh_id)
          vert_adv_coeffs => get_reversible_vert_adv_coeffs(mesh_id)
          vertical_order = fv_vertical_order
        else
          ndata_v => get_adv_ndata_v(mesh_id)
          vert_adv_coeffs => get_vert_adv_coeffs(mesh_id)
          vertical_order = fv_vertical_order + 1_i_def
        end if
        ! Compute vertical component of advective update
        call invoke( tl_poly1d_vert_adv_kernel_type( u_grad_f,           &
                                                     consistent_wind,    &
                                                     adv_field,          &
                                                     ls_consistent_wind, &
                                                     ls_adv_field,       &
                                                     vert_adv_coeffs,    &
                                                     ndata_v,            &
                                                     vertical_order,     &
                                                     logspace_loc ) )
      end if

    case(operators_fem)
      call log_event( "TL: fem not available", LOG_LEVEL_ERROR )
    end select

    mt_lumped_inv => get_inverse_lumped_mass_matrix(Wtheta, mesh%get_id())

    ! Apply monotonicity (as if this is a full timestep)
    if ( monotonicity_option == monotone_clipping ) then
      call log_event( "TL: monotonicity not available", LOG_LEVEL_ERROR )
    end if

    ! Scale by lumped inverse mass matrix
    call invoke( X_times_Y(rhs, u_grad_f, mt_lumped_inv) )

    nullify( chi3_at_wt, chi, mt_lumped_inv, vert_adv_coeffs, &
             reference_element, mesh, ndata_v )

  end subroutine tl_wt_advective_update_alg

end module tl_wt_advective_update_alg_mod
