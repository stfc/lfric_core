!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the non-linear 3D equations,
!>       currently using 3-stage SSP.
!>@details An algorithm for timstepping the 3D nonlinear linear
!>         equations using a multistage explicit Runge-Kutta algortihm. 
module rk_alg_timestep_mod

  use log_mod,       only: log_event,         &
                           log_scratch_space, &
                           LOG_LEVEL_INFO,    &
                           LOG_LEVEL_TRACE
  use psy,           only: &
                           invoke_axpy,                        &
                           invoke_copy_field_data,             &
                           invoke_set_field_scalar,            &
                           invoke_flux_rhs

  use initial_theta_kernel_mod,          only: initial_theta_kernel_type
  use compute_mass_matrix_kernel_w0_mod, only: compute_mass_matrix_kernel_w0_type
  use compute_mass_matrix_kernel_w1_mod, only: compute_mass_matrix_kernel_w1_type
  use compute_mass_matrix_kernel_w2_mod, only: compute_mass_matrix_kernel_w2_type
  use compute_geopotential_kernel_mod,   only: compute_geopotential_kernel_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use ru_kernel_mod,                     only: ru_kernel_type
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use initial_rho_kernel_mod,            only: initial_rho_kernel_type
  use vorticity_rhs_kernel_mod,          only: vorticity_rhs_kernel_type
  use rotation_kernel_mod,               only: rotation_kernel_type
  use pressure_gradient_kernel_mod,      only: pressure_gradient_kernel_type
  use kinetic_energy_gradient_kernel_mod,only: kinetic_energy_gradient_kernel_type
  use geopotential_gradient_kernel_mod,  only: geopotential_gradient_kernel_type
  use vorticity_advection_kernel_mod,    only: vorticity_advection_kernel_type

  use mesh_mod,      only: mesh_type
  use field_mod,     only: field_type
  use function_space_mod, &
                     only: function_space_type, W0, W1, W2, W3
  use solver_mod,    only: solver_algorithm
  use constants_mod, only: r_def, SOLVER_OPTION, DT, NT
  use quadrature_mod, only : quadrature_type, QR3
  use galerkin_projection_algorithm_mod, &
                     only : galerkin_projection_algorithm
  use driver_layer,  only : interpolated_output
  use operator_mod,  only : operator_type
  use conservation_algorithm_mod, &
                     only : conservation_algorithm

  implicit none

  private
  public :: rk_alg_timestep

contains

  !> @brief A Runge-Kutta time-discretisation of the non-linear 3D equations,
  !>        currently using 3-stage SSP.
  !> @details An algorithm for timstepping the 3D nonlinear
  !>          equations using a Runge-Kutta algortihm. The 
  !>          algorithm initialialises all fields, sets up temporary fields
  !>          and performs the timestepping and checks to see if it should
  !>          dump output.
  !>          The type of Runge-Kutta scheme can be simply changed by 
  !>          modifying the (currently hardwired) Butcher tableau (ak array)
  !>          The current set up uses the 3rd-order three stage 
  !>          Strong-Stability-Preserving (SSP3) method
  !> @param[in]    mesh Mesh object on which the model runs
  !> @param[inout] chi  The finite element form of the coordinates
  !> @param[inout] u The 3D wind field
  !> @param[inout] rho The density
  !> @param[inout] theta The potential temperature
  !> @param[inout] xi The vorticity field
  subroutine rk_alg_timestep( mesh, chi, u, rho, theta, xi)

    implicit none

    type (mesh_type), intent(in) :: mesh 

    ! coordinate fields
    type( field_type ), intent( inout ) :: chi(3)
    ! prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta, xi
    ! temporary fields
    type( field_type ) :: u_n, rho_n, theta_n,       &
                          r_u, r_rho, r_theta,       &
                          u_inc, rho_inc, theta_inc, &
                          mass_flux, rhs_xi,         &
                          geopotential

    type( field_type ), allocatable :: rt_prediction(:),  &
                                       ru_prediction(:),  &
                                       rr_prediction(:)
    type( field_type ) :: projected_field(3)

    integer :: theta_fs, u_fs, rho_fs, xi_fs
    integer :: n, output_freq
    integer :: stage, num_rk_stage, st
    real(kind=r_def), allocatable :: ak(:,:)
    type(function_space_type) :: fs
    type( quadrature_type), pointer :: qr => null()
    integer, parameter :: VECTOR_FIELD = 3, &
                          SCALAR_FIELD = 1

    type(operator_type) :: mm_w2, mm_w1, mm_w0

    ! SSP3 weights
    num_rk_stage = 3
    allocate ( ak (num_rk_stage,num_rk_stage) )
    ak(1,:) = (/ 1.0_r_def,  0.0_r_def,  0.0_r_def /)
    ak(2,:) = (/ 0.25_r_def, 0.25_r_def, 0.0_r_def /)
    ak(3,:) = (/ 1.0_r_def,  1.0_r_def,  4.0_r_def /)/6.0_r_def

    allocate ( rt_prediction(num_rk_stage), &
               ru_prediction(num_rk_stage), &
               rr_prediction(num_rk_stage) )

    ! Local fields
    theta_fs  = theta%which_function_space()
    u_fs      = u%which_function_space()
    rho_fs    = rho%which_function_space()
    xi_fs     = xi%which_function_space()

    qr => qr%get_instance(QR3,9,3)

    theta_n      = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    u_n          = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    rho_n        = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    r_theta      = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    r_u          = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    r_rho        = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    theta_inc    = field_type( vector_space = fs%get_instance(mesh, theta_fs) )
    u_inc        = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    rho_inc      = field_type( vector_space = fs%get_instance(mesh, rho_fs) )
    mass_flux    = field_type( vector_space = fs%get_instance(mesh, u_fs) )
    rhs_xi       = field_type( vector_space = fs%get_instance(mesh, xi_fs) )
    geopotential = field_type( vector_space = fs%get_instance(mesh, theta_fs) )

    do stage = 1,num_rk_stage
      rt_prediction(stage) = field_type                                        &
                             (vector_space = fs%get_instance(mesh, theta_fs))
      ru_prediction(stage) = field_type                                        &
                             (vector_space = fs%get_instance(mesh, u_fs))
      rr_prediction(stage) = field_type                                        &
                             (vector_space = fs%get_instance(mesh, rho_fs))
    end do

    mm_w0 = operator_type(fs%get_instance(mesh, W0),fs%get_instance(mesh, W0))
    mm_w1 = operator_type(fs%get_instance(mesh, W1),fs%get_instance(mesh, W1))
    mm_w2 = operator_type(fs%get_instance(mesh, W2),fs%get_instance(mesh, W2))

    do stage = 1,3
      projected_field(stage) = field_type                                      &
                               (vector_space = fs%get_instance(mesh, theta_fs))
    end do

    !Construct PSy layer given a list of kernels. This is the line the code
    !generator may parse and do its stuff.

    ! initialise

    call invoke(compute_geopotential_kernel_type( geopotential, chi ) )
    ! Construct initial conditions
    call log_event( "Dynamo: computing initial fields", LOG_LEVEL_INFO )

    call invoke( initial_theta_kernel_type( theta, chi ) )
    call invoke( initial_rho_kernel_type ( rho, chi, qr ) )
    call invoke_set_field_scalar(0.0_r_def, u)
    call invoke_set_field_scalar(0.0_r_def, xi)
    call invoke_set_field_scalar(0.0_r_def, mass_flux)

    call invoke( compute_mass_matrix_kernel_w0_type(mm_w0, chi, qr),           &
                 compute_mass_matrix_kernel_w1_type(mm_w1, chi, qr),           &
                 compute_mass_matrix_kernel_w2_type(mm_w2, chi, qr) )

    call galerkin_projection_algorithm( projected_field(1)                     &
                                      , theta                                  &
                                      , mesh                                   &
                                      , chi                                    &
                                      , SCALAR_FIELD                           &
                                      , qr                                     &
                                      , mm=mm_w0 )
    call interpolated_output( 0                                                &
                            , SCALAR_FIELD                                     &
                            , projected_field(1)                               &
                            , mesh                                             &
                            , chi                                              &
                            , 'theta_' )

    call invoke_set_field_scalar( 0.0_r_def, projected_field(1) )

    call galerkin_projection_algorithm( projected_field(1)                     &
                                      , rho                                    &
                                      , mesh                                   &
                                      , chi                                    &
                                      , SCALAR_FIELD                           &
                                      , qr                                     &
                                      , mm=mm_w0 )

    call interpolated_output( 0                                                &
                            , SCALAR_FIELD                                     &
                            , projected_field(1)                               &
                            , mesh                                             &
                            , chi                                              &
                            , 'rho___' )

    call galerkin_projection_algorithm( projected_field(:)                     &
                                      , u                                      &
                                      , mesh                                   &
                                      , chi                                    &
                                      , VECTOR_FIELD                           &
                                      , qr                                     &
                                      , mm=mm_w0 )
    call interpolated_output( 0                                                &
                            , VECTOR_FIELD                                     &
                            , projected_field(:)                               &
                            , mesh                                             &
                            , chi                                              &
                            , 'u_____' )

    call conservation_algorithm(0, mesh, rho, u, theta, xi, geopotential, chi)

    !==========================================================================
    ! Timestep
    output_freq = NT
    do n = 1,NT
      call log_event( "/****************************************************************************\ ", &
                      LOG_LEVEL_TRACE )
      write( log_scratch_space, '(A,I0)' ) 'Start of timestep ', n
      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      !PSY call invoke ( copy_field_data(theta,theta_n))
      call invoke_copy_field_data(theta,theta_n)
      !PSY call invoke ( copy_field_data(u,u_n))
      call invoke_copy_field_data(u,u_n)
      !PSY call invoke ( copy_field_data(rho,rho_n))
      call invoke_copy_field_data(rho,rho_n)

      ! Runge-Kutta algorithm
      do stage = 1,num_rk_stage
        ! Compute advection terms
        ! mass flux ( F = rho * u )
        call invoke_set_field_scalar(0.0_r_def, r_u)
!PSY        call invoke(flux_rhs_kernel_type( r_u, u, rho, chi, qr ) )
        call invoke_flux_rhs( r_u, u, rho, chi, qr ) 

        call solver_algorithm( mass_flux     &
                             , r_u           &
                             , mesh          &
                             , chi           &
                             , solver_option &
                             , mm=mm_w2 )

        ! compute rrho = div(F)
        call invoke( rrho_kernel_type  ( rr_prediction(stage), mass_flux, qr ) )
        ! Compute vorticity
        call invoke_set_field_scalar(0.0_r_def, rhs_xi)
        call invoke( vorticity_rhs_kernel_type( rhs_xi, u, chi, qr ) )
        call solver_algorithm( xi, rhs_xi, mesh, chi, solver_option, mm=mm_w1)

        ! Compute new rhs
        !PSY call invoke ( set_field_scalar(0.0_r_def, rt_prediction(stage)))
        call invoke_set_field_scalar(0.0_r_def, rt_prediction(stage))
        !call invoke_rtheta_kernel( rt_prediction(stage), u, chi, qr)
        call invoke( rtheta_kernel_type( rt_prediction(stage), theta, mass_flux, rho, qr) )
        !PSY call invoke ( set_field_scalar(0.0_r_def, ru_prediction(stage)))
        call invoke_set_field_scalar(0.0_r_def, ru_prediction(stage))
        call invoke( rotation_kernel_type                ( ru_prediction(stage), u, chi, qr ) )
        call invoke( pressure_gradient_kernel_type       ( ru_prediction(stage), rho, theta, qr ) )
        call invoke( kinetic_energy_gradient_kernel_type ( ru_prediction(stage), u, chi, qr ) )
        call invoke( geopotential_gradient_kernel_type   ( ru_prediction(stage), geopotential, qr ) )
        call invoke( vorticity_advection_kernel_type     ( ru_prediction(stage), mass_flux, rho, xi, chi, qr ) )
        ! Ru kernel only being used for boundary dof's
        call invoke( ru_kernel_type( ru_prediction(stage) ) ) 

        !PSY call invoke ( set_field_scalar(0.0_r_def, r_theta))
        call invoke_set_field_scalar(0.0_r_def, r_theta)
        !PSY call invoke ( set_field_scalar(0.0_r_def, r_u))
        call invoke_set_field_scalar(0.0_r_def, r_u)
        !PSY call invoke ( set_field_scalar(0.0_r_def, r_rho))
        call invoke_set_field_scalar(0.0_r_def, r_rho)

        do st = 1, stage
          !PSY call invoke ( axpy(ak(stage,st), rt_prediction(st),r_theta, r_theta))
          call invoke_axpy(ak(stage,st), rt_prediction(st),r_theta, r_theta)
          !PSY call invoke ( axpy(ak(stage,st), ru_prediction(st),r_u, r_u))
          call invoke_axpy(ak(stage,st), ru_prediction(st),r_u, r_u)
          !PSY call invoke ( axpy(ak(stage,st), rr_prediction(st),r_rho, r_rho))
          call invoke_axpy(ak(stage,st), rr_prediction(st),r_rho, r_rho)
        end do

        ! Invert mass matrices
        call solver_algorithm( theta_inc     &
                             , r_theta       &
                             , mesh          &
                             , chi           &
                             , SOLVER_OPTION &
                             , mm=mm_w0 )
        call solver_algorithm( u_inc         &
                             , r_u           &
                             , mesh          &
                             , chi           &
                             , SOLVER_OPTION &
                             , mm=mm_w2 )
        call solver_algorithm( rho_inc       &
                             , r_rho         &
                             , mesh          &
                             , chi           &
                             , SOLVER_OPTION &
                             , qr=qr )

        ! add increments
        !PSY call invoke ( axpy(DT, theta_inc, theta_n, theta))
        call invoke_axpy(DT, theta_inc, theta_n, theta)
        !PSY call invoke ( axpy(DT, u_inc, u_n, u))
        call invoke_axpy(DT, u_inc, u_n, u)
        !PSY call invoke ( axpy(DT, rho_inc, rho_n, rho))
        call invoke_axpy(DT, rho_inc, rho_n, rho)

        ! diagnostics
        call theta_inc%log_minmax(LOG_LEVEL_TRACE, 'theta_inc');
        call u_inc%log_minmax(LOG_LEVEL_TRACE, 'u_inc');
        call rho_inc%log_minmax(LOG_LEVEL_TRACE, 'rho_inc');

      end do

      if ( mod(n, output_freq) == 0 ) then
        call galerkin_projection_algorithm( projected_field(1) &
                                          , theta              &
                                          , mesh               &
                                          , chi                &
                                          , SCALAR_FIELD       &
                                          , qr                 &
                                          , mm=mm_w0 )
        call interpolated_output( n                  &
                                , SCALAR_FIELD       & 
                                , projected_field(1) &
                                , mesh               &
                                , chi                &
                                , 'theta_' )

        call galerkin_projection_algorithm( projected_field(1) &
                                          , rho                &
                                          , mesh               &
                                          , chi                &
                                          , SCALAR_FIELD       &
                                          , qr                 &
                                          , mm=mm_w0 )
        call interpolated_output( n                   &
                                , SCALAR_FIELD        &
                                , projected_field(1), &
                                , mesh                &
                                , chi                 &
                                , 'rho___' )

        call galerkin_projection_algorithm( projected_field(:) &
                                          , u                  &
                                          , mesh               &
                                          , chi                &
                                          , VECTOR_FIELD       &
                                          , qr                 &
                                          , mm=mm_w0)
        call interpolated_output( n                            &
                                , VECTOR_FIELD                 &
                                , projected_field(:)           &
                                , mesh                         &
                                , chi                          &
                                , 'u_____' )
      end if
      call conservation_algorithm(n, mesh, rho, u, theta, xi, geopotential, chi)

      write( log_scratch_space, '(A,I0)' ) 'End of timestep ', n
      call log_event( log_scratch_space, LOG_LEVEL_TRACE )
      call log_event( '\****************************************************************************/ ', &
                      LOG_LEVEL_TRACE )
    end do
    call log_event( "Dynamo: finished timestep", LOG_LEVEL_INFO )
    !==========================================================================

  end subroutine rk_alg_timestep

end module rk_alg_timestep_mod
