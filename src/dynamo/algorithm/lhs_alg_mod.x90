!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief wrapper algorithm to compute the lhs of the prognostic
!>       equations
module lhs_alg_mod

  use constants_mod,                     only: r_def
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use field_bundle_mod,                  only: clone_bundle
  use field_mod,                         only: field_type
  use finite_element_config_mod,         only: element_order
  use formulation_config_mod,            only: eliminate_p
  use function_space_mod,                only: function_space_type
  use rtheta_kernel_mod,                 only: rtheta_kernel_type
  use pert_pressure_gradient_kernel_mod, only: pert_pressure_gradient_kernel_type
  use exner_gradient_kernel_mod,         only: exner_gradient_kernel_type
  use psykal_lite_mod,                   only: invoke_axpy,               &
                                               invoke_copy_field_data,    &
                                               invoke_multiply_field,     &
                                               invoke_sample_flux_kernel, &
                                               invoke_set_field_scalar
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use mesh_mod,                          only: mesh_type
  use multiplicity_kernel_mod,           only: multiplicity_kernel_type
  use operator_mod,                      only: operator_type
  use quadrature_mod,                    only: quadrature_type, GAUSSIAN
  use rrho_kernel_mod,                   only: rrho_kernel_type
  use runtime_constants_mod,             only: runtime_constants_type
  use w3_solver_kernel_mod,              only: w3_solver_kernel_type
  use derived_config_mod,                only: si_bundle_size, bundle_size
  use lhs_exner_kernel_mod,              only: lhs_exner_kernel_type

  implicit none

  type(field_type),              private :: ones, w2_multiplicity, f_star, r_rho
  type(field_type), allocatable, private :: lhs_tmp(:)

  private
  public :: lhs_alg
  public :: lhs_init

contains

  subroutine lhs_init(state)
    implicit none
    type(field_type), intent(in) :: state(si_bundle_size)

    type(function_space_type), pointer :: rho_fs, u_fs => null()
    type(mesh_type),           pointer :: mesh => null()
    type(function_space_type)          :: fs
    integer                            :: fs_handle

    allocate( lhs_tmp(si_bundle_size) )
    call clone_bundle(state, lhs_tmp, si_bundle_size)
    mesh => state(1)%get_mesh()

    ! For computing lhs_theta
    fs_handle = state(3)%which_function_space()
    rho_fs => fs%get_instance(mesh, element_order, fs_handle)
    ones = field_type( vector_space = rho_fs )
    call invoke_set_field_scalar( 1.0_r_def, ones )
    r_rho = field_type( vector_space = rho_fs )

    ! for computing lhs rho
    fs_handle = state(1)%which_function_space()
    u_fs => fs%get_instance(mesh, element_order, fs_handle)
    w2_multiplicity = field_type( vector_space = u_fs )
    call invoke_set_field_scalar( 0.0_r_def, w2_multiplicity )
    call invoke ( multiplicity_kernel_type( w2_multiplicity ) )
    f_star = field_type( vector_space = u_fs )

  end subroutine lhs_init

!>@details A wrapper for computing the lhs of the prognostic
!>         equations by choosing certain terms to approximate the 
!>         Jacobian, namely:
!>         \f[
!>         \mathbf{L_u} = \mathbf{u}' 
!>                      + \alpha\Delta t Cp\left( \theta^*\nabla\Pi' 
!>                                                +\theta'\nabla\Pi^*\right)
!>         \f]
!>         \f[ L_\rho = \rho' 
!>                    + \alpha\Delta t\nabla.\left(\rho^*\mathbf{u}'\right) \f]
!>         \f[ L_\theta = \theta' + \alpha\Delta t\mathbf{u}'.\nabla\theta^*\f]
!>
!>         Where primed terms are increments to the n+1 timelevel field and
!>         star terms are a reference profile
!> @param[inout] lhs The state vector to compute
!> @param[in]    alpha_dt The offcentring parameter times the timestep
!> @param[inout] state The current model prognostic state
!> @param[in]    runtime_constants Runtime constants for the model
  subroutine lhs_alg(lhs, state, ref_state, alpha_dt,  runtime_constants)

  implicit none

  real(kind=r_def),             intent(in)    :: alpha_dt
  ! Form of state and lhs is [u,theta,rho,exner]
  type(field_type), target,     intent(inout) :: state(si_bundle_size)
  type(field_type), target,     intent(in)    :: ref_state(bundle_size)
  type(field_type),             intent(inout) :: lhs(si_bundle_size)
  type(runtime_constants_type), intent(in)    :: runtime_constants

  type(quadrature_type)        :: qr
  type(field_type),    pointer :: chi(:)=> null()
  type(operator_type), pointer :: mm_w2, mm_w0, mm_w3_inv => null()
  type(operator_type), pointer :: div => null()
  type(field_type),    pointer :: u ,theta, rho, exner, theta_ref, rho_ref => null()

  mm_w0        => runtime_constants%get_mass_matrix(0)
  mm_w2        => runtime_constants%get_mass_matrix(2)
  mm_w3_inv    => runtime_constants%get_mass_matrix(4)
  chi          => runtime_constants%get_coordinates()
  div          => runtime_constants%get_div()

  u     => state(1)
  theta => state(2)
  rho   => state(3)

  theta_ref => ref_state(2)
  rho_ref   => ref_state(3)

  qr = quadrature_type(element_order+2, GAUSSIAN)

  ! Compute lhs_u
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(1) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(1) )
  if ( eliminate_p ) then
    call invoke( pert_pressure_gradient_kernel_type(  &
                   lhs_tmp(1), rho, rho_ref, theta, theta_ref, qr ), &
                 matrix_vector_kernel_type( lhs(1), u, mm_w2) )
  else 
    ! Use r_rho as a zero field so that exner' = 0 in pert_pressure_gradient_kernel
    call invoke_set_field_scalar( 0.0_r_def, r_rho )
    exner => state(4)
    call invoke( exner_gradient_kernel_type( lhs_tmp(1), exner, theta_ref, qr ), &
                 pert_pressure_gradient_kernel_type( lhs_tmp(1), r_rho, rho_ref, &
                                                     theta, theta_ref, qr ), &
                 matrix_vector_kernel_type( lhs(1), u, mm_w2) )
  end if
  call invoke( enforce_bc_kernel_type( lhs_tmp(1) ) )
  call invoke_axpy( alpha_dt, lhs_tmp(1), lhs(1), lhs(1) ) 
 

  qr = quadrature_type(element_order+1, GAUSSIAN)

  ! Compute lhs_theta
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(2) )
  call invoke_set_field_scalar( 0.0_r_def, lhs(2) )
  call invoke( rtheta_kernel_type( lhs_tmp(2), theta_ref, u, ones, qr), & 
               matrix_vector_kernel_type( lhs(2), theta, mm_w0) )
  call invoke_axpy( alpha_dt, lhs_tmp(2), lhs(2), lhs(2) ) 

  ! Compute lhs_rho
  ! Need to create u*rho^ref \in W2 for lhs_tmp(3) kernel -> sampled mass flux
  call invoke_set_field_scalar( 0.0_r_def, f_star )
  call invoke_sample_flux_kernel( f_star, u, w2_multiplicity, rho_ref )

  call invoke_set_field_scalar( 0.0_r_def, r_rho )
  call invoke( matrix_vector_kernel_type( r_rho, f_star, div) )
  call invoke_multiply_field(-1.0_r_def, r_rho, r_rho) 
  call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(3) )
  call invoke( matrix_vector_kernel_type( lhs_tmp(3), r_rho, mm_w3_inv) )
  call invoke_axpy( alpha_dt, lhs_tmp(3), rho, lhs(3) )

  ! Compute lhs exner
  if ( .not. eliminate_p ) then
    exner => state(4)
    call invoke_set_field_scalar( 0.0_r_def, lhs(4) )
    call invoke_set_field_scalar( 0.0_r_def, lhs_tmp(4) )
    call invoke( lhs_exner_kernel_type(lhs_tmp(4), theta, rho, exner, &
                                       theta_ref, rho_ref, chi, qr ) )
    call invoke( matrix_vector_kernel_type( lhs(4), lhs_tmp(4), mm_w3_inv) )

  end if

  end subroutine lhs_alg

end module lhs_alg_mod


