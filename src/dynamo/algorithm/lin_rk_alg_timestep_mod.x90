!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!>@brief A Runge-Kutta time-discretisation of the linear 3D equations, currently
!>       using 3-stage SSP.
!>@details An algorithm for timstepping the 3D linear no advection equations
!>         using a 3-stage SSP Runge-Kutta algorithm.
!>@deprecated The Usefulness of the linear model is to be re-evaluated at 
!>            the end of the Gung-Ho project and removed if possible
module lin_rk_alg_timestep_mod

  use log_mod,           only: log_event, log_scratch_space,                   &
                               LOG_LEVEL_INFO, LOG_LEVEL_TRACE
  use constants_mod,     only: r_def, str_max_filename, i_def

  ! Configuration options
  use finite_element_config_mod, only : element_order
  use solver_config_mod,         only : method
  use timestepping_config_mod,   only : dt
  use runge_kutta_init_mod,      only : ak, num_rk_stage
  use runtime_constants_mod,     only : get_geopotential, &
                                        get_mass_matrix, &
                                        get_qr

  ! PsyKAl-lite kernels
  use psykal_lite_mod,     only: invoke_copy_field_data,                        &
                                 invoke_set_field_scalar,                       &
                                 invoke_axpy

  ! PsyKAl PSYClone kernels 
  use linear_rtheta_kernel_mod,          only: linear_rtheta_kernel_type
  use linear_rrho_kernel_mod,            only: linear_rrho_kernel_type 
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use linear_ru_kernel_mod,              only: linear_ru_kernel_type

  use field_mod,                         only: field_type
  use function_space_collection_mod,     only: function_space_collection
  use function_space_mod,                only: function_space_type
  use quadrature_mod,                    only: quadrature_type
  use solver_mod,                        only: solver_algorithm
  use operator_mod,                      only: operator_type

  use fs_continuity_mod,   only: W1

  implicit none

  private
  ! 'State' items private to the algorithm that need to be 
  !  created once but used every step
  type( field_type ), allocatable :: rt_prediction(:),  &
                                     ru_prediction(:),  &
                                     rr_prediction(:) 
  public :: lin_rk_alg_init
  public :: lin_rk_alg_step

contains
  !>-------------------------------------------------
  !> @details Initialisation procedure for the linear rk 
  !> timestepping algorithm. Initialises various
  !> internal fields.
  !> @param[in]    mesh id of mesh object on which the model runs
  !> @param[inout] u The 3D wind field
  !> @param[inout] rho The density
  !> @param[inout] theta The potential temperature
  !> @deprecated The Usefulness of the linear model is to be re-evaluated at 
  !>             the end of the Gung-Ho project and removed if possible
  subroutine lin_rk_alg_init(mesh, u, rho, theta)

    implicit none

    integer( i_def  ), intent( in )    :: mesh

    ! prognostic fields    
    type( field_type ), intent( inout ) :: u, rho, theta 

    type(function_space_type), pointer :: theta_fs => null()
    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()
                                   
    
    ! Timestepping variables
    integer :: stage
    
    allocate ( rt_prediction(num_rk_stage), &
               ru_prediction(num_rk_stage), & 
               rr_prediction(num_rk_stage) )
      
    ! Initialise local fields
    theta_fs => function_space_collection%get_fs(mesh, &
                                                 element_order, &
                                                 theta%which_function_space())
    u_fs     => function_space_collection%get_fs(mesh, &
                                                 element_order, &
                                                 u%which_function_space())
    rho_fs   => function_space_collection%get_fs(mesh, &
                                                 element_order, &
                                                 rho%which_function_space())


    do stage = 1,num_rk_stage
      rt_prediction(stage) = field_type( vector_space = theta_fs )
      ru_prediction(stage) = field_type( vector_space = u_fs     )
      rr_prediction(stage) = field_type( vector_space = rho_fs   )
    end do  



  end subroutine lin_rk_alg_init

  !>-------------------------------------------------
  !> @brief A Runge-Kutta time-discretisation of the linear 3D equations,
  !>        currently using 3-stage SSP.
  !> @details An algorithm for timstepping the 3D linear
  !>          equations with no advection using a Runge-Kutta algortihm.
  !>          The type of Runge-Kutta scheme can be simply changed by 
  !>          modifying the (currently hardwired) Butcher tableau (ak array)
  !>          The current set up uses the 3rd-order three stage 
  !>          Strong-Stability-Preserving (SSP3) method
  !> @param[in]    mesh id of mesh object on which the model runs
  !> @param[inout] chi The finite element form of the coordinates
  !> @param[inout] u The 3D wind field
  !> @param[inout] rho The density
  !> @param[inout] theta The potential temperature
  !> @deprecated The Usefulness of the linear model is to be re-evaluated at 
  !>             the end of the Gung-Ho project and removed if possible

  subroutine lin_rk_alg_step(mesh, chi, u, rho, theta)

    implicit none

    integer( i_def  ), intent( in )    :: mesh

    ! coordinate fields
    type( field_type ), intent( inout ) :: chi(3)

    ! prognostic fields    
    type( field_type ), intent( inout )           :: u, rho, theta 


    ! the quadrature object
    type( quadrature_type )           :: qr


    type(function_space_type), pointer :: theta_fs => null()
    type(function_space_type), pointer :: u_fs     => null()
    type(function_space_type), pointer :: rho_fs   => null()


    ! temporary fields    
    type( field_type ) :: u_n, rho_n, theta_n,       &
                          r_u, r_rho, r_theta,       &
                          u_inc, rho_inc, theta_inc

    ! temps for retrieving things back from runtime_constants
    type(operator_type) :: mm_w2, mm_w0
    type( field_type )  :: geopotential

    integer :: stage, st

    qr = get_qr()

    theta_fs => function_space_collection%get_fs(mesh, &
                                                 element_order, &
                                                 theta%which_function_space())
    u_fs     => function_space_collection%get_fs(mesh, &
                                                 element_order, &
                                                 u%which_function_space())
    rho_fs   => function_space_collection%get_fs(mesh, &
                                                 element_order, &
                                                 rho%which_function_space())

    theta_n      = field_type( vector_space = theta_fs )
    u_n          = field_type( vector_space = u_fs     ) 
    rho_n        = field_type( vector_space = rho_fs   ) 
    r_theta      = field_type( vector_space = theta_fs ) 
    r_u          = field_type( vector_space = u_fs     ) 
    r_rho        = field_type( vector_space = rho_fs   ) 
    theta_inc    = field_type( vector_space = theta_fs ) 
    u_inc        = field_type( vector_space = u_fs     ) 
    rho_inc      = field_type( vector_space = rho_fs   ) 

    mm_w0 = get_mass_matrix(0)         
    mm_w2 = get_mass_matrix(2)    

    geopotential = get_geopotential()

    call invoke_copy_field_data(theta,theta_n)
    call invoke_copy_field_data(u,u_n)
    call invoke_copy_field_data(rho,rho_n)
      
    ! Runge-Kutta algorithm
    do stage = 1,num_rk_stage
      ! Compute new rhs      
      call invoke_set_field_scalar(0.0_r_def, rt_prediction(stage))
      call invoke(linear_rtheta_kernel_type( rt_prediction(stage), u, geopotential, chi, qr) )
      call invoke_set_field_scalar(0.0_r_def, ru_prediction(stage))
      call invoke(linear_ru_kernel_type ( ru_prediction(stage), u, rho, theta, &
                                          geopotential, chi, qr ) )
      call invoke( enforce_bc_kernel_type(ru_prediction(stage)) )
      call invoke( linear_rrho_kernel_type ( rr_prediction(stage), u, geopotential, chi, qr ) )
      call invoke_set_field_scalar(0.0_r_def, r_theta)
      call invoke_set_field_scalar(0.0_r_def, r_u)
      call invoke_set_field_scalar(0.0_r_def, r_rho) 
        
      do st = 1, stage          
        call invoke_axpy(ak(stage,st), rt_prediction(st),r_theta, r_theta)
        call invoke_axpy(ak(stage,st), ru_prediction(st),r_u, r_u)
        call invoke_axpy(ak(stage,st), rr_prediction(st),r_rho, r_rho)
      end do

      ! Invert mass matrices
      call solver_algorithm(theta_inc, r_theta, mesh, chi, &
                            method, mm=mm_w0)
      call solver_algorithm(u_inc,     r_u,     mesh, chi, &
                            method, mm=mm_w2)
      call solver_algorithm(rho_inc,   r_rho,   mesh, chi, &
                            method, qr=qr)

      ! Add increments
      call invoke_axpy(dt, theta_inc, theta_n, theta)
      call invoke_axpy(dt, u_inc, u_n, u)
      call invoke_axpy(dt, rho_inc, rho_n, rho)

      ! Diagnostics
      call theta_inc%log_minmax(LOG_LEVEL_TRACE, 'theta_inc');
      call u_inc%log_minmax(LOG_LEVEL_TRACE, 'u_inc');
      call rho_inc%log_minmax(LOG_LEVEL_TRACE, 'rho_inc');

    end do


  end subroutine lin_rk_alg_step

end module lin_rk_alg_timestep_mod
