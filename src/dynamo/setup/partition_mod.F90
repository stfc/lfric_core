!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!> @brief Provides partitioning functionality

!> @details Partitions the mesh for the supported mesh types:
!> bi-periodic plane and cubed sphere.
!> Generates a list of cells known to this partition.
!> The cells owned by the partition are followed by the cells in 
!> the halo. These are generated by applying a stencil to the owned cells


module partition_mod

use constants_mod,            only : r_def

implicit none

private apply_stencil_biperiodic

contains 

!> Partitions the mesh on a bi-periodic plane
  subroutine partition_biperiodic( )

  use mesh_mod, only : num_cells_x, num_cells_y, &
                       local_rank, xproc, yproc, &
                       partitioned_cells, num_owned, num_halo 
  use linked_list_mod, only : linked_list_type, add_item, clear_list

  implicit none

  integer :: local_xproc, local_yproc ! x- and y-dirn grid id of this partition
  integer :: start_x   ! global cell id of start of the domain on this partition in x-dirn
  integer :: num_x     ! number of cells in the domain on this partition in x-dirn
  integer :: start_y   ! global cell id of start of the domain on this partition in y-dirn
  integer :: num_y     ! number of cells in the domain on this partition in y-dirn
  integer :: num_in_list !total number of cells known to this partition (owned+halo)

  integer :: ix, iy    ! loop counters over cells on this partition in x- and y-dirns

  type(linked_list_type), pointer :: curr=>null()  ! the current position at which items will be added
                                                   ! to the list that holds cells known to this partition
  type(linked_list_type), pointer :: start=>null() ! start of the list that holds cells known to this partition

  integer :: i         ! loop counter over all items being sorted in the bubble sort
  integer :: swap_temp ! temporary swap space used to swap items in the bubble sort
  logical :: swapped   ! flag set to true if the current iteration of the bubble sort swapped any items

  !convert the local rank number into a local xproc and yproc
  local_xproc=modulo(local_rank,xproc)
  local_yproc=local_rank/xproc

  !Work out the start index and number of cells (in x- and y-dirn) for 
  !the local partition - this algorithm should spread out the number of
  !cells each partition gets fairly evenly
  start_x = int(real(local_xproc)*real(num_cells_x)/ &
                real(xproc)+0.5)+1
  num_x   = int(real(local_xproc+1)*real(num_cells_x)/ &
                real(xproc)+0.5)-start_x+1

  start_y = int(real(local_yproc)*real(num_cells_y)/ &
                real(yproc)+0.5)+1
  num_y   = int(real(local_yproc+1)*real(num_cells_y)/ &
                real(yproc)+0.5)-start_y+1

  !Create a linked list of cells known to this partition
  !Start with the owned cells
  call add_item(start,(start_y-1)*num_cells_x+start_x)
  num_in_list=1
  curr => start
  do iy=start_y, start_y+num_y -1
    do ix=start_x, start_x+num_x-1
      if(ix /= start_x .or. iy /= start_y)then
        call add_item(curr,(iy-1)*num_cells_x+ix)
        num_in_list=num_in_list+1
      end if
    end do
  end do 
  num_owned = num_in_list

  ! look for halos around top and bottom rows
  do ix=start_x, start_x+num_x-1
   call apply_stencil_biperiodic(ix,start_y,num_cells_x,num_cells_y,start,curr,num_in_list)
   call apply_stencil_biperiodic(ix,start_y+num_y-1,num_cells_x,num_cells_y,start,curr,num_in_list)
  end do
  ! look for halos around left and right edges
  do iy=start_y, start_y+num_y-1
   call apply_stencil_biperiodic(start_x,iy,num_cells_x,num_cells_y,start,curr,num_in_list)
   call apply_stencil_biperiodic(start_x+num_x-1,iy,num_cells_x,num_cells_y,start,curr,num_in_list)
  end do

  allocate(partitioned_cells(num_in_list))
  curr => start
  do i = 1,num_in_list
    partitioned_cells(i)=curr%dat
    curr=>curr%next
  end do

  num_halo=num_in_list-num_owned

  !Deallocate the list
  call clear_list(start)

  !List of halo cells is all over the place - (bubble) sort into ascending global id order
  do
    swapped=.false.
    do i = num_in_list-num_halo+1,num_in_list-1
      if(partitioned_cells(i) > partitioned_cells(i+1))then
        swap_temp=partitioned_cells(i)
        partitioned_cells(i)=partitioned_cells(i+1)
        partitioned_cells(i+1)=swap_temp
        swapped=.true.
      end if
    end do
    if(.not.swapped)exit
  end do

  end subroutine partition_biperiodic

!> Partitions the mesh on a cubed sphere
  subroutine partition_cubedsphere( )

  use mesh_mod, only : num_cells_x, num_cells_y, &
                       partitioned_cells, num_owned, num_halo 

! Currently not written to partition the mesh (that will come later)
! - will just return one big partition that holds everything
  implicit none
  integer :: i

  num_cells_y = num_cells_x
  num_owned = 6*num_cells_x**2
  num_halo=0

  allocate(partitioned_cells(num_owned))
  do i=1, num_owned
    partitioned_cells(i)=i
  end do

  end subroutine partition_cubedsphere

! Applies a nine-point stencil in a bi-periodic domain around a cell and adds
! the global ids of the stencil cells to a list of cells known to the partition
! if they are not already in the list. The subroutine is private to this module.
  subroutine apply_stencil_biperiodic(ix,iy,num_cells_x,num_cells_y,start,curr,num_in_list)
  use linked_list_mod, only : linked_list_type, add_unique_item
  implicit none
  integer, intent(in) :: ix, iy ! global cell coordinates on which to apply the stencel
  integer, intent(in) :: num_cells_x, num_cells_y ! number of cells in the global domain in x- and y-dirn
  type(linked_list_type), pointer :: curr  ! the current position at which items will be added
                                           ! to the list that holds cells known to this partition
  type(linked_list_type), pointer :: start ! start of the list that holds cells known to this partition
  integer, intent(inout) :: num_in_list ! total number of cells known to this partition (owned+halo)

  integer :: j         ! counter over the points in the stencil
  integer :: ix1, iy1  ! x- and y-coordinate of cell in the stencil
  integer :: num_added ! number of cells added to the linked list 

  do j=1,8  ! there are 8 cells around a centre cell in a 9-point stencil
    select case (j)
    case (1)  !South
      ix1=ix
      iy1=iy-1
    case (2)  !Southwest
      ix1=ix-1
      iy1=iy-1
    case (3)  !West
      ix1=ix-1
      iy1=iy
    case (4)  !Northwest
      ix1=ix-1
      iy1=iy+1
    case (5)  !North
      ix1=ix
      iy1=iy+1
    case (6)  !Northeast
      ix1=ix+1
      iy1=iy+1
    case (7)  !East
      ix1=ix+1
      iy1=iy
    case (8)  !Southeast
      ix1=ix+1
      iy1=iy-1
    case default
      ix1=ix
      iy1=iy
    end select
    !wrap-around
    if (ix1<1)ix1=num_cells_x
    if (ix1>num_cells_x)ix1=1
    if (iy1<1)iy1=num_cells_y
    if (iy1>num_cells_y)iy1=1

    call add_unique_item(start,curr,(iy1-1)*num_cells_x+ix1,num_added)
    num_in_list=num_in_list+num_added
  end do

  end subroutine apply_stencil_biperiodic

end module partition_mod
