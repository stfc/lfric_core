!-------------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown,
! Met Office and NERC 2014.
! However, it has been created with the help of the GungHo Consortium,
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-------------------------------------------------------------------------------

!> @brief Sets up data required for the the function spaces

!> @details This code generates a mesh and determines the basis functions and
!> dofmaps. This will be replaced with code that reads this in from a mesh
!> generation and paritioning pre-processor stage.

! There are no tests for this code as this will be replaced.

module set_up_mod

  use base_mesh_config_mod,      only : filename, &
                                        geometry, &
                                        base_mesh_geometry_spherical
  use constants_mod,             only : i_def, r_def, str_def, l_def, PI
  use extrusion_config_mod,      only : number_of_layers,           &
                                        domain_top,                 &
                                        method,                     &
                                        extrusion_method_uniform,   &
                                        extrusion_method_quadratic, &
                                        extrusion_method_geometric, &
                                        extrusion_method_dcmip
  use finite_element_config_mod, only : shape,                         &
                                        finite_element_shape_triangle, &
                                        finite_element_shape_quadrilateral
  use partitioning_config_mod,   only : auto, panel_xproc, panel_yproc
  use global_mesh_mod,           only : global_mesh_type
  use mesh_collection_mod,       only : mesh_collection_type, &
                                        mesh_collection
  use reference_element_mod,     only : reference_cube, reference_element, &
                                        nfaces, nedges, nverts
  use mesh_mod,                  only : mesh_type
  use log_mod,                   only : log_event,      &
                                        log_scratch_space, &
                                        LOG_LEVEL_INFO, &
                                        LOG_LEVEL_ERROR
  use partition_mod,             only : partition_type,                   &
                                        partitioner_interface,            &
                                        partitioner_cubedsphere_serial,   &
                                        partitioner_cubedsphere,          &
                                        partitioner_biperiodic

  implicit none

contains

!> @brief Generates a mesh and determines the basis functions and dofmaps
!> @details This will be replaced with code that reads the information in
!> @param[in] local_rank Number of the MPI rank of this process
!> @param[in] total_ranks Total number of MPI ranks in this job
!> @param[out] primal_mesh_id id of paritioned primal mesh
  subroutine set_up(local_rank, total_ranks, primal_mesh_id)

    implicit none

    integer(i_def), intent(in)  :: local_rank
    integer(i_def), intent(in)  :: total_ranks
    integer(i_def), intent(out) :: primal_mesh_id

    integer(i_def), parameter :: max_factor_iters = 10000

    type (global_mesh_type)    :: global_mesh
    type (partition_type)      :: partition
    type (mesh_type), pointer  :: mesh => null()

    procedure (partitioner_interface), pointer :: partitioner_ptr => null ()

!   max_stencil_depth is the maximum depth (of cells outside the cell over
!   which the stencil is based) of the stencil to be used on fields with this
!   partition. A single cell stencil will, therefore, have a max_stencil_depth=0
!   A nine-point square region stencil will have max_stencil_depth=1
!
!> @todo max_stencil_depth will eventually become either a configuration item,
!>       or will be autogenerated from kernel metadata, but for now it is
!>       just hard-coded
    integer(i_def) :: max_stencil_depth

    ! Number of ranks the mesh is partitioned over in the x- and y-directions
    ! (across a single face for a cubed-sphere mesh)
    integer(i_def) :: xproc, yproc

    integer(i_def) :: ranks_per_panel
    integer(i_def) :: start_factor
    integer(i_def) :: fact_count
    logical(l_def) :: found_factors
    character(str_def) :: domain_desc, partition_desc


    call log_event( "set_up: Generating/reading the mesh", LOG_LEVEL_INFO )

    reference_element = shape

    ! Currently only quad elements are fully functional
    if ( reference_element /= finite_element_shape_quadrilateral ) then
      call log_event( "set_up: Reference_element must be QUAD for now...", &
                      LOG_LEVEL_ERROR )
    end if
    ! Setup reference cube
    call reference_cube()

    ! Generate the global mesh and choose a partitioning strategy by setting
    ! a function pointer to point at the appropriate partitioning routine
    global_mesh = global_mesh_type( filename )
    if ( geometry == base_mesh_geometry_spherical ) then

      if(total_ranks == 1 .or. mod(total_ranks,6) == 0)then
        ranks_per_panel = total_ranks/6
        domain_desc="6x"
      else
        call log_event( "set_up: Total number of processors must be a"// &
                        " multiple of 6 for a cubed-sphere domain.", &
                      LOG_LEVEL_ERROR )
      end if

      if(total_ranks == 1) then
        ranks_per_panel = 1
        partitioner_ptr => partitioner_cubedsphere_serial
        call log_event( "set_up: Setting up serial cubed sphere partitioner", &
                       LOG_LEVEL_INFO )
      else
        partitioner_ptr => partitioner_cubedsphere
        call log_event( "set_up: Setting up parallel cubed sphere partitioner",&
                        LOG_LEVEL_INFO )
      end if
    else
      ranks_per_panel=total_ranks
      domain_desc=""

      partitioner_ptr => partitioner_biperiodic
      call log_event( "set_up: Setting up biperiodic plane partitioner ", &
                      LOG_LEVEL_INFO )
    end if

    if(auto)then
    ! For automatic partitioning, try to partition into the squarest possible
    ! partitions by finding the two factors of ranks_per_panel that are
    ! closest to sqrt(ranks_per_panel). If two factors can't be found after
    ! max_factor_iters attempts, they would provide partitions that are
    ! too un-square, so an error is produced.
      start_factor=int(sqrt(float(ranks_per_panel)))
      found_factors=.false.
      do fact_count=start_factor, max(1,(start_factor-max_factor_iters)), -1
        if(mod(ranks_per_panel,fact_count)==0)then
          found_factors=.true.
          exit
        end if
      end do
      if(found_factors)then
        xproc = fact_count
        yproc = ranks_per_panel/fact_count
      else
        call log_event( "set_up: Could not automatically partition domain.", &
                      LOG_LEVEL_ERROR )
      end if
    else
    ! Not automatic partitioning - use the values provided from the
    ! partitioning namelist
      if(panel_xproc*panel_yproc == ranks_per_panel)then
        xproc = panel_xproc
        yproc = panel_yproc
      else
        call log_event( "set_up: The values of panel_xproc and panel_yproc"// &
          " are inconsistent with the total number of processors available.", &
                      LOG_LEVEL_ERROR )
      end if
    end if

    if(total_ranks == 1) then
      call log_event( 'set_up: Using 1 partition', LOG_LEVEL_INFO )
    else
      write(partition_desc,"(i0,'x',i0)")xproc,yproc
      write( log_scratch_space, "('set_up: Using ',a,a,' partitions.')" ) &
                 trim(domain_desc), trim(partition_desc)
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
    end if

    ! Generate the partition object
    max_stencil_depth=0
    partition = partition_type( global_mesh, &
                               partitioner_ptr, &
                               xproc, &
                               yproc, &
                               max_stencil_depth, &
                               local_rank, &
                               total_ranks)

    ! Generate the mesh
    primal_mesh_id = mesh_collection%get_id_for_new_mesh( global_mesh, &
                                                          partition, &
                                                          number_of_layers, &
                                                          domain_top, &
                                                          method )
    mesh => mesh_collection%get_mesh( primal_mesh_id )

    call mesh%set_colours()

    return
  end subroutine set_up
end module set_up_mod
