!-----------------------------------------------------------------------------
! (c) The copyright relating to this work is owned jointly by the Crown, 
! Met Office and NERC 2014. 
! However, it has been created with the help of the GungHo Consortium, 
! whose members are identified at https://puma.nerc.ac.uk/trac/GungHo/wiki
!-----------------------------------------------------------------------------

!> Test the field representation
!>
!-------------------------------------------------------------------------------
module field_mod_test

  use constants_mod,                  only : i_def, r_def
  use function_space_collection_mod,  only : function_space_collection_type, &
                                             function_space_collection
  use mesh_collection_mod,            only : mesh_collection_type, &
                                             mesh_collection
  use fs_continuity_mod,              only : W2
  use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: field_test_type
    private
    type(function_space_collection_type) :: fs_list
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type field_test_type

  integer(i_def), parameter :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod, only : finite_element_shape_quadrilateral
    use reference_element_mod,     only : reference_cube, reference_element

    implicit none

    class(field_test_type), intent(inout) :: this

    reference_element = finite_element_shape_quadrilateral
    call reference_cube()

    ! Create top level mesh collection
    mesh_collection = mesh_collection_type()
    ! Create top level function space collection
    function_space_collection = function_space_collection_type()

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use reference_element_mod, only : deallocate_reference

    implicit none

    class(field_test_type), intent(inout) :: this

    call function_space_collection%clear()
    call deallocate_reference()
    call mesh_collection%clear()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    use field_mod,             only: field_type, field_proxy_type

    use mesh_mod,              only: mesh_type, PLANE_BI_PERIODIC
    use function_space_mod,    only: function_space_type

    implicit none

    class(field_test_type), intent(inout) :: this

    type(field_type)          :: f1
    type(field_type)          :: f2
    type(field_proxy_type)    :: f1_p
    type(field_proxy_type)    :: f2_p

    integer(i_def)            :: mesh_id

    type(function_space_type), pointer :: w2_fs    => null()
    type(mesh_type),           pointer :: mesh_out => null()

    integer(i_def) :: err
    integer :: i, iface, iedge, lid, test_integer
    real(r_def) :: sum, min, max

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    mesh_id = mesh_collection%add_unit_test_mesh( PLANE_BI_PERIODIC )

    ! Make a field with a function space
    w2_fs => function_space_collection%get_fs( mesh_id, element_order, W2 )
    f1 = field_type( vector_space = w2_fs )

    ! get the proxy
    f1_p = f1%get_proxy()

    ! Check the size of the data array is the same as undf from the fs
    @assertEqual( size( f1_p%data ) , f1_p%vspace%get_undf() )
    ! Check the the function space the field lives on is the one it was
    ! created with
    @assertEqual( f1%which_function_space(), W2 )

    !Initialise field data
    do i=1,f1_p%vspace%get_undf()
      f1_p%data(i)=real(i)
    end do

    ! Make a second field, identical to the first
    f2 = field_type( vector_space = w2_fs )
    f2_p = f2%get_proxy()
    do i=1,f2_p%vspace%get_undf()
      f2_p%data(i)=real(i)
    end do

    ! Perform a halo swap on the second field
    call f2_p%halo_exchange_start(1)
    ! If I had any calculations to overlap with comms - I'd put them here!
    call f2_p%halo_exchange_finish(1)

    ! For serial case, the halo swapped field should be the same as the original
    @assertEqual( f1_p%data  , f2_p%data, 1.0e-2_r_def )

    ! Test the global reductions
    sum=f1_p%get_sum()
    @assertEqual( 4095.0  , sum, 1.0e-2_r_def )

    min=f1_p%get_min()
    @assertEqual( 1.0  , min, 1.0e-2_r_def )

    max=f1_p%get_max()
    @assertEqual( 90.0  , max, 1.0e-2_r_def)


    ! Assignment operator tests follow...
    f2 = f1
    f2_p = f2%get_proxy()

    ! Check that contained vector_space pointers point to same address
    @assertTrue(associated(f1_p%vspace, f2_p%vspace), "Assigned field_type vspace pointers differ.")

    ! Operations on field data are part of the PSy and Kernel layers so
    ! that is all.


    ! Test if the function space returns the correct mesh
    ! Use a subset of the tests from mesh_mod_test.pf
    mesh_out => f1%get_mesh()

    !-------------------------------------------------------------------
    ! Test get_face_on_cell()
    iface=3
    lid=9
    test_integer = mesh_out%get_face_on_cell(iface, lid)
    @assertEqual ( 28, test_integer )

    !-------------------------------------------------------------------
    ! Test get_edge_on_cell()
    iedge=1
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 27, test_integer )

    iedge=5
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 11, test_integer )

    iedge=9
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 28, test_integer )

    iedge=12
    lid=5
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 36, test_integer )

    iedge=6
    lid=9
    test_integer = mesh_out%get_edge_on_cell(iedge, lid)
    @assertEqual ( 32, test_integer )

  end subroutine test_all

end module field_mod_test
!-------------------------------------------------------------------------------
! vim: set ft=fortran :
