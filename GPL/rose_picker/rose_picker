#!/usr/bin/env python
# -*- coding: utf-8 -*-
##############################################################################
# (C) British Crown Copyright 2018 Met Office.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Rose. If not, see <http://www.gnu.org/licenses/>.
##############################################################################

from __future__ import absolute_import
from __future__ import print_function

import argparse
import os.path
import collections
import re
import json

import rose
from rose.config import ConfigSyntaxError
from rose.config_tree import ConfigTreeLoader


class RosePickerException(Exception):
    pass


def main():

    parser = argparse.ArgumentParser(add_help=False,
                                     description=__doc__)
    parser.add_argument('-help', '-h', '--help', action='help',
                        help='Show this help message and exit')
    parser.add_argument('-directory', metavar='path', default='.',
                        help='Generated source files are put here.')
    parser.add_argument('-include_dirs', action='append',
                        help='Include directory to list of directories '
                             'to search for inherited metadata files')
    parser.add_argument('meta_filename', metavar='description-file',
                        help='The metadata file to load')

    args = parser.parse_args()

    meta_filename = args.meta_filename
    include_dirs = args.include_dirs
    output_dir = args.directory

    # Load in a config file. This is using Rose's "config.py" code
    # which is different to pythons ConfigParser. We need to use
    # config.py to ensure any changes to the way rose meta data
    # is treated are picked up.
    #
    # Rose's "config_tree.py" code is used to expand any import
    # statements in the specified configuration file.

    try:
        # Load and expand the configuration file
        config_node = rose.config.load(meta_filename)
        tree_loader = ConfigTreeLoader()

        tree_loader.load(os.path.dirname(meta_filename),
                         os.path.basename(meta_filename),
                         conf_dir_paths=include_dirs,
                         conf_node=config_node)

    except ConfigSyntaxError:
        # Handle exception.
        if not os.path.isfile(meta_filename):
            print('File {} does not exist.'.format(meta_filename))
        else:
            print('File {} is not a valid rose '
                  'meta configuration file.'.format(meta_filename))

        quit()


    # Get keys list of all the namelists/members in the
    # configuration file
    listnames = []
    namelist_config = collections.OrderedDict()
    namelists_regex = re.compile(
        r'^\s*namelist\s*:\s*(\w*)\s*(?:=\s*(\S+))?')

    node_keys = list(filter(namelists_regex.match,
                            config_node.get_value().keys()))
    node_keys.sort()

    required_properties = ['bounds',
                           'enumeration',
                           'expression',
                           'kind',
                           'length',
                           'string_length',
                           'type',
                           'values']

    # Extract require namelists and member
    # properties to build namelist loaders.
    for key in node_keys:

        match = namelists_regex.match(key)
        node = match.group(0)
        namelist = match.group(1)
        member = match.group(2)

        if namelist:
            if not member:
                listnames.append(namelist)
                namelist_config[namelist] = {}
                continue

            elif namelist not in namelist_config.keys():
                message = (
                    'namelist:' + namelist
                    + ' has no section in metadata configuration file')
                raise RosePickerException(message)

            else:
                namelist_config[namelist][member] = {}

                member_node = config_node.get([node])
                member_node_keys = member_node.get_value().keys()
                for i in required_properties:
                    if i in member_node_keys:
                        member_prop = member_node.get([i])
                        member_prop = member_prop.get_value()
                        namelist_config[namelist][member][i] \
                            = member_prop

    basename = os.path.basename(meta_filename).split('.')

    # Output as .json file
    nml_config_filename = '{}.json'.format(basename[0])
    output = open('{}/{}'.format(
        output_dir, nml_config_filename), 'wb')
    json.dump(namelist_config, output, indent=4, encoding='ascii')
    output.close()

    # Write out namelists in configuration
    output = open('{}/config_namelists.txt'.format(output_dir), 'wt')

    for listname in listnames:
        output.write('{}\n'.format(listname))

    output.close()


if __name__ == '__main__':
    main()
