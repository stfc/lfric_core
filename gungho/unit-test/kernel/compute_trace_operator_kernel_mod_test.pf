!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> Test the trace operator computation
!>
module compute_trace_operator_kernel_mod_test

  use constants_mod,                     only : i_def, r_def
  use function_space_collection_mod,     only : function_space_collection_type, &
                                                function_space_collection
  use mesh_mod,                          only : mesh_type
  use mesh_collection_mod,               only : mesh_collection_type, &
                                                mesh_collection
  use reference_element_mod,             only : reference_element_type
  use field_mod,                         only : field_type, &
                                                field_proxy_type
  use fs_continuity_mod,                 only : W0, W2Broken, W2trace
  use function_space_mod,                only : function_space_type
  use operator_mod,                      only : operator_type, operator_proxy_type
  use pFUnit_Mod
  use quadrature_face_mod,               only : quadrature_face_type, &
                                                quadrature_face_proxy_type
  use quadrature_rule_gaussian_mod,      only : quadrature_rule_gaussian_type
  use yaxt,                              only : xt_initialize, xt_finalize
  use mpi_mod,                           only : store_comm, clear_comm

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public       :: compute_trace_operator_test_type
     private
     type(quadrature_face_type)            :: qr
     type(quadrature_face_proxy_type)      :: qr_proxy
     type(function_space_type), pointer    :: w0_fs => null()
     type(function_space_type), pointer    :: w2b_fs => null()
     type(function_space_type), pointer    :: w2t_fs => null()
     type(operator_type)                   :: trace_op
     real(kind=r_def), allocatable         :: basis_w2b(:, :, :, :),      &
                                              basis_w2t(:, :, :, :)
     integer(kind=i_def)                   :: mesh_id

   contains
     procedure setUp
     procedure tearDown
     procedure test_all
  end type compute_trace_operator_test_type

  integer(kind=i_def), parameter :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod,  only : finite_element_cellshape_quadrilateral
    use gungho_feign_config_mod,    only : feign_finite_element_config
    use mesh_mod,                   only : PLANE_BI_PERIODIC

    implicit none

    class(compute_trace_operator_test_type), intent(inout) :: this

    type(operator_proxy_type)              :: trace_op_p
    type(quadrature_rule_gaussian_type)    :: quadrature_rule

    class(mesh_type),              pointer :: mesh => null()
    class(reference_element_type), pointer :: reference_element => null()

    integer(kind=i_def) :: nlayers, dim_w2b, dim_w2t
    integer(kind=i_def) :: ndf_w2b, ndf_w2t
    integer(kind=i_def) :: nqp, nfaces
    integer(kind=i_def) :: i

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())

    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_finite_element_config(                          &
             cellshape=finite_element_cellshape_quadrilateral, &
             coordinate_order=0_i_def,                         &
             element_order=1_i_def,                            &
             rehabilitate=.true.,                              &
             supg=.false.,                                     &
             vorticity_in_w1=.false.)

    ! Create top level mesh collection
    mesh_collection = mesh_collection_type()

    ! Create top level function space collection
    function_space_collection = function_space_collection_type()

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    this%mesh_id = mesh_collection%add_unit_test_mesh( PLANE_BI_PERIODIC )

    this%w2b_fs => function_space_collection%get_fs( this%mesh_id,  &
                                                     element_order, &
                                                     W2broken )
    this%w2t_fs => function_space_collection%get_fs( this%mesh_id,  &
                                                     element_order, &
                                                     W2trace )

    ! Trace operator mapping from W2trace to W2broken
    this%trace_op = operator_type(this%w2t_fs, this%w2b_fs)
    trace_op_p    = this%trace_op%get_proxy()

    ndf_w2b = trace_op_p%fs_from%get_ndf()
    dim_w2b = trace_op_p%fs_from%get_dim_space()
    ndf_w2t = trace_op_p%fs_to%get_ndf()
    dim_w2t = trace_op_p%fs_to%get_dim_space()

    ! Retrieve mesh information to construct the right face quadrature
    mesh              => trace_op_p%fs_from%get_mesh()
    reference_element => mesh%get_reference_element()

    ! Want a quadrature rule on both horizontal and vertical faces
    nfaces  = reference_element%get_number_faces()

    this%qr = quadrature_face_type(3, .true., .true., reference_element, &
                                   quadrature_rule )
    this%qr_proxy = this%qr%get_quadrature_proxy()
    nqp           = this%qr_proxy%np_xyz

    allocate( this%basis_w2b(dim_w2b, ndf_w2b, nqp, nfaces) )
    allocate( this%basis_w2t(dim_w2t, ndf_w2t, nqp, nfaces) )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use gungho_configuration_mod, only: final_configuration

    implicit none

    class(compute_trace_operator_test_type), intent(inout) :: this

    deallocate( this%basis_w2b, this%basis_w2t )

    call mesh_collection%clear()
    call function_space_collection%clear()
    call final_configuration()

    ! Finalize YAXT
    call xt_finalize()

    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_all( this )

    use compute_trace_operator_kernel_mod, only : compute_trace_operator_code
    use mesh_mod,                          only : mesh_type
    use function_space_mod,                only : BASIS, DIFF_BASIS

    implicit none

    class(compute_trace_operator_test_type), intent(inout) :: this

    type(operator_proxy_type)     :: trace_op_p

    type(mesh_type), pointer               :: mesh              => null()
    class(reference_element_type), pointer :: reference_element => null()

    real(kind=r_def), parameter   :: tol = 1.0e-6_r_def
    real(kind=r_def)              :: answer(6, 6)

    integer(kind=i_def)           :: i, j, k, cell

    integer(kind=i_def)           :: nlayers, nfaces
    integer(kind=i_def)           :: ndf_w2b, ndf_w2t
    integer(kind=i_def)           :: nqp

    real(kind=r_def), allocatable :: out_face_normal(:, :)

    integer(kind=i_def), pointer  :: face_entity_map(:) => null()

    real(kind=r_def), pointer     :: qp(:, :, :) => null()
    real(kind=r_def), pointer     :: wqp(:, :)   => null()

    mesh => mesh_collection%get_mesh( this%mesh_id )
    reference_element => mesh%get_reference_element()

    nfaces = reference_element%get_number_faces()

    ! Test the trace operator kernel
    trace_op_p = this%trace_op%get_proxy()

    ! Ensure the operator maps between the correct spaces
    @assertEqual( trace_op_p%fs_from%which(), W2broken )
    @assertEqual( trace_op_p%fs_to%which(),   W2trace )

    nqp =  this%qr_proxy%np_xyz
    wqp => this%qr_proxy%weights_xyz
    qp  => this%qr_proxy%points_xyz

    ! NOTE: Since these integrands are all defined on faces
    ! only, we use the methods built into the face quadrature
    ! rule to evaluate basis functions
    nlayers = trace_op_p%fs_from%get_nlayers()
    ndf_w2b = trace_op_p%fs_from%get_ndf()
    ndf_w2t = trace_op_p%fs_to%get_ndf()
    call this%qr%compute_function(                           &
       BASIS, trace_op_p%fs_to,                              &
       trace_op_p%fs_to%get_dim_space(), ndf_w2t,            &
       this%basis_w2t )

    call this%qr%compute_function(                           &
       BASIS, trace_op_p%fs_from,                            &
       trace_op_p%fs_from%get_dim_space(), ndf_w2b,          &
       this%basis_w2b )

    cell = 1
    face_entity_map => trace_op_p%fs_to%get_entity_dofs()
    trace_op_p%local_stencil(:, :, :) = 0.0_r_def
    call reference_element%get_normals_to_out_faces( out_face_normal )

    call compute_trace_operator_code( cell,                     &
                                      nlayers,                  &
                                      trace_op_p%ncell_3d,      &
                                      trace_op_p%local_stencil, &
                                      ndf_w2b,                  &
                                      ndf_w2t,                  &
                                      nqp,                      &
                                      wqp,                      &
                                      this%basis_w2b,           &
                                      this%basis_w2t,           &
                                      nfaces,                   &
                                      face_entity_map,          &
                                      out_face_normal )

    call trace_ans( answer )
    @assertEqual(answer, trace_op_p%local_stencil(:, :, 1), tol)

  end subroutine test_all

  subroutine trace_ans( tr_op )

    implicit none

    real(kind=r_def), dimension(6, 6), intent(inout) :: tr_op

    tr_op = reshape( [              &
       -1.00000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       1.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       1.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       -1.00000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       -1.00000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       0.000000000000000E+00_r_def, &
       1.000000000000000E+00_r_def  &
       ], shape(tr_op) )

    return

  end subroutine trace_ans

end module compute_trace_operator_kernel_mod_test
