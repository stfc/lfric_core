!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the divergence operator computation
!>
module compound_operator_kernel_mod_test

    use constants_mod,                 only : i_def, r_def
    use function_space_collection_mod, only : function_space_collection_type, &
                                              function_space_collection
    use mesh_collection_mod,           only : mesh_collection_type, &
                                              mesh_collection
    use fs_continuity_mod,             only : W2, W3
    use function_space_mod,            only : function_space_type
    use operator_mod,                  only : operator_type, operator_proxy_type
    use pFUnit_Mod

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(TestCase), public :: compound_operator_test_type
    private
    type(function_space_type), pointer :: w2_fs => null()
    type(function_space_type), pointer :: w3_fs => null()
    type(operator_type)                :: div, m_w3_1, m_w3_2, dstar
    integer(i_def)                     :: mesh_id
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type compound_operator_test_type

  integer(i_def), parameter :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod, only : finite_element_cellshape_quadrilateral
    use gungho_feign_config_mod,   only : feign_finite_element_config
    use mesh_mod,                  only : PLANE_BI_PERIODIC
    use reference_element_mod,     only : reference_cube, reference_element

    implicit none

    class(compound_operator_test_type), intent(inout) :: this

    integer :: i

    call feign_finite_element_config( finite_element_cellshape_quadrilateral, &
                                      0, 1, .true., .false., .false., .false.)

    reference_element = finite_element_cellshape_quadrilateral
    call reference_cube()

    ! Create top level collections
    mesh_collection = mesh_collection_type()
    function_space_collection = function_space_collection_type()

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    this%mesh_id = mesh_collection%add_unit_test_mesh( PLANE_BI_PERIODIC )

    this%w2_fs => function_space_collection%get_fs( this%mesh_id, &
                                                    element_order, &
                                                    W2 )
    this%w3_fs => function_space_collection%get_fs( this%mesh_id, &
                                                    element_order, &
                                                    W3 )

    this%dstar  = operator_type(this%w3_fs,this%w2_fs)
    this%div    = operator_type(this%w3_fs,this%w2_fs)
    this%m_w3_1 = operator_type(this%w3_fs,this%w3_fs)
    this%m_w3_2 = operator_type(this%w3_fs,this%w3_fs)

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use reference_element_mod, only : deallocate_reference

    implicit none

    class(compound_operator_test_type), intent(inout) :: this

    call function_space_collection%clear()
    call mesh_collection%clear()
    call deallocate_reference()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @test
  subroutine test_all( this )

    use compound_operator_kernel_mod, only : compound_operator_kernel_code

    implicit none

    class(compound_operator_test_type), intent(inout) :: this

    type(operator_proxy_type) :: div_p, m_w3_1_p, m_w3_2_p, dstar_p

    real(kind=r_def), parameter :: tol = 1.0e-12_r_def
    real(kind=r_def), parameter :: tau = 0.5_r_def
    integer :: cell, i, j
    integer(i_def) :: err

    integer :: nlayers
    integer :: ndf_w2, ndf_w3, undf_w2
    integer, dimension(6) :: map_w2
    
    real(kind=r_def), dimension(1,6) :: answer
    real(kind=r_def), dimension(1,6) :: d
    real(kind=r_def), dimension(1,1) :: m3_1, m3_2

    real(kind=r_def), allocatable, dimension(:) :: rho

    ! Test the operator kernel
    dstar_p = this%dstar%get_proxy()
    div_p = this%div%get_proxy()
    m_w3_1_p = this%m_w3_1%get_proxy()
    m_w3_2_p = this%m_w3_2%get_proxy()

    nlayers = div_p%fs_from%get_nlayers()
    ndf_w2  = div_p%fs_from%get_ndf()
    ndf_w3  = div_p%fs_to%get_ndf()
   
    div_p%local_stencil(:,:,:)    = 0.0_r_def
    m_w3_1_p%local_stencil(:,:,:) = 0.0_r_def
    m_w3_2_p%local_stencil(:,:,:) = 0.0_r_def

    map_w2(:) = 1_i_def
    undf_w2 = nlayers
    allocate( rho(undf_w2) )
    rho(:) = 2.0_r_def

    do i = 1,ndf_w2
      do j = 1,ndf_w3
        d(j,i) = real(i*j,r_def)
      end do
    end do
    do i = 1,ndf_w3
      do j = 1,ndf_w3
        m3_1(i,j) = real(i + j,r_def)
        m3_2(i,j) = real(7 - i*j,r_def)
      end do
    end do
    do cell = 1, div_p%ncell_3d
      div_p%local_stencil(:,:,cell) = d
      m_w3_1_p%local_stencil(:,:,cell) = m3_1
      m_w3_2_p%local_stencil(:,:,cell) = m3_2
    end do
    cell = 1
    
    call compound_operator_kernel_code( cell,                              &
                                        nlayers,                           &
                                        dstar_p%ncell_3d,                  & 
                                        dstar_p%local_stencil,             &
                                        m_w3_1_p%ncell_3d,                 &
                                        m_w3_1_p%local_stencil,            &
                                        m_w3_2_p%ncell_3d,                 &
                                        m_w3_2_p%local_stencil,            &
                                        div_p%ncell_3d,                    &
                                        div_p%local_stencil,               &
                                        rho,                               &
                                        tau,                               &
                                        ndf_w3,                            &
                                        ndf_w2, undf_w2, map_w2)

    answer = matmul(m3_1,matmul(m3_2,d))
    @assertEqual(answer, dstar_p%local_stencil(:, :, 1 ), tol)

  end subroutine test_all

end module compound_operator_kernel_mod_test
