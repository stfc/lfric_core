!-----------------------------------------------------------------------------
! Copyright (c) 2019,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the rtheta computation
!>
module rtheta_supg_kernel_mod_test

  use constants_mod,                 only : i_def, r_def
  use pFUnit_Mod
  use yaxt,                          only : xt_initialize, xt_finalize
  use mpi_mod,                       only : store_comm, clear_comm

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public :: rtheta_supg_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type rtheta_supg_test_type

  integer(i_def), parameter :: element_order = 0

  real(r_def),    parameter :: dt = 10.0
  real(r_def), parameter    :: alpha   = 0.5_r_def
  real(r_def), parameter    :: tau_u   = 0.5_r_def
  real(r_def), parameter    :: tau_t   = 0.5_r_def
  real(r_def), parameter    :: tau_r   = 0.5_r_def
  integer(i_def), parameter :: inner_iterations = 2
  integer(i_def), parameter :: outer_iterations = 2
  real(r_def),    parameter :: spinup_period = 0.0_r_def
  logical,        parameter :: spinup_winds  = .false.
  logical,        parameter :: spinup_alpha  = .false.

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use gungho_feign_config_mod,   only : feign_timestepping_config
    use timestepping_config_mod,   only : timestepping_method_semi_implicit, &
                                          timestepping_runge_kutta_method_ssp3

    implicit none

    class(rtheta_supg_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    !Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_timestepping_config(                &
         alpha=alpha,                              &
         method=timestepping_method_semi_implicit, &
         dt=dt,                                    &
         tau_u=tau_u,                              &
         tau_t=tau_t,                              &
         tau_r=tau_r,                              &
         outer_iterations=outer_iterations,        &
         inner_iterations=inner_iterations,        &
         runge_kutta_method=timestepping_runge_kutta_method_ssp3,&
         spinup_period=spinup_period,              &
         spinup_alpha=spinup_alpha,                &
         spinup_winds=spinup_winds  )

  end subroutine setUp

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use gungho_configuration_mod, only: final_configuration

    implicit none

    class(rtheta_supg_test_type), intent(inout) :: this

    call final_configuration()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_all( this )

    use rtheta_supg_kernel_mod,     only : rtheta_supg_code

    use get_unit_test_m3x3_q3x3x3_sizes_mod, only: get_w0_m3x3_q3x3x3_size, &
                                                   get_w2_m3x3_q3x3x3_size, &
                                                   get_w3_m3x3_q3x3x3_size

    use get_unit_test_m3x3_dofmap_mod, only: get_w0_m3x3_dofmap, &
                                             get_w2_m3x3_dofmap, &
                                             get_w3_m3x3_dofmap

    use get_unit_test_q3x3x3_quadrature_mod, only:             &
                    get_gaussian_q3x3x3_quadrature_points_xy,  &
                    get_gaussian_q3x3x3_quadrature_points_z,   &
                    get_gaussian_q3x3x3_quadrature_weights_xy, &
                    get_gaussian_q3x3x3_quadrature_weights_z

    use get_unit_test_q3x3x3_basis_mod, only: get_w0_q3x3x3_basis,        &
                                              get_w0_q3x3x3_diff_basis,   &
                                              get_w2_q3x3x3_basis,        &
                                              get_w3_q3x3x3_basis
    implicit none

    class(rtheta_supg_test_type), intent(inout) :: this

    real(r_def), parameter :: dx = 6000.0_r_def
    real(r_def), parameter :: dy = 1000.0_r_def
    real(r_def), parameter :: dz = 2000.0_r_def

    real(r_def) :: tol = 1.0e-6_r_def

    integer(i_def) :: i, j, k, cell

    ! Dummy variable for passing into multi-getter routines where item is not needed
    integer(i_def) :: unused

    ! Required for calling kernel
    real(r_def),allocatable :: r_theta_data(:)
    real(r_def),allocatable :: theta_data(:)
    real(r_def),allocatable :: theta_n_data(:)
    real(r_def),allocatable :: f_data(:)
    real(r_def),allocatable :: rho_data(:)
    real(r_def),allocatable :: chi_data(:,:)

    integer(i_def), allocatable    :: map_w0(:,:)
    integer(i_def), allocatable    :: map_w2(:,:)
    integer(i_def), allocatable    :: map_w3(:,:)

    real(r_def), allocatable :: basis_w0(:,:,:,:)
    real(r_def), allocatable :: basis_w2(:,:,:,:)
    real(r_def), allocatable :: basis_w3(:,:,:,:)
    real(r_def), allocatable :: diff_basis_w0(:,:,:,:)

    real(kind=r_def), allocatable :: xp(:,:)
    real(kind=r_def), allocatable :: zp(:)
    real(kind=r_def), allocatable :: wh(:)
    real(kind=r_def), allocatable :: wv(:)

    real(kind=r_def), allocatable :: answer(:)

    integer(kind=i_def)     :: nlayers, nqp_h, nqp_v
    integer(kind=i_def)     :: ndf_w0, undf_w0
    integer(kind=i_def)     :: ndf_w2, undf_w2
    integer(kind=i_def)     :: ndf_w3, undf_w3

    ! Use a 3 layer mesh
    nlayers=3

    ! Get sizes
    call get_w0_m3x3_q3x3x3_size( ndf_w0, undf_w0, unused, &
                                  unused, unused,          &
                                  unused, unused,          &
                                  nlayers )
    call get_w2_m3x3_q3x3x3_size( ndf_w2, undf_w2, unused, &
                                  unused, unused,          &
                                  unused, unused,          &
                                  nlayers )
    call get_w3_m3x3_q3x3x3_size( ndf_w3, undf_w3, unused, &
                                  unused, unused,          &
                                  unused, unused,          &
                                  nlayers )

    ! Get arrays of quadrature weights
    call get_gaussian_q3x3x3_quadrature_points_xy(xp)
    call get_gaussian_q3x3x3_quadrature_points_z(zp)
    call get_gaussian_q3x3x3_quadrature_weights_xy(wh)
    call get_gaussian_q3x3x3_quadrature_weights_z(wv)
    nqp_h=size(wh,1)
    nqp_v=size(wv,1)

   ! Get basis functions
    call get_w0_q3x3x3_basis(basis_w0)
    call get_w0_q3x3x3_diff_basis(diff_basis_w0)
    call get_w2_q3x3x3_basis(basis_w2)
    call get_w3_q3x3x3_basis(basis_w3)

    ! Get dofmaps
    call get_w0_m3x3_dofmap(map_w0)
    call get_w2_m3x3_dofmap(map_w2)
    call get_w3_m3x3_dofmap(map_w3)

    ! Create the data arrays
    allocate(theta_n_data(undf_w0))
    allocate(theta_data(undf_w0))
    allocate(r_theta_data(undf_w0))
    allocate(f_data(undf_w2))
    allocate(rho_data(undf_w3))
    allocate(chi_data(undf_w0,3))

    ! Compute coordinates
    cell = 1
    do j = 1,3
      do i = 1,3
        do k = 0,nlayers
          chi_data(map_w0(1,cell) + k,1) = real(i-1)*dx
          chi_data(map_w0(1,cell) + k,2) = real(j-1)*dy
          chi_data(map_w0(1,cell) + k,3) = real(k)  *dz
        end do
        cell = cell + 1
      end do
    end do

    ! Initialise the data
    r_theta_data(:) = 0.0_r_def
    theta_data(:)   = 300.0_r_def
    theta_n_data(:) = 300.0_r_def
    f_data(:)       = 2.0_r_def
    rho_data(:)     = 0.5_r_def

    do cell = 1, 9

      call rtheta_supg_code( nlayers,             &
                             r_theta_data,        &
                             theta_data,          &
                             theta_n_data,        &
                             f_data,              &
                             rho_data,            &
                             chi_data(:,1),       &
                             chi_data(:,2),       &
                             chi_data(:,3),       &
                             ndf_w0, undf_w0,     &
                             map_w0(:,cell),      &
                             basis_w0,            &
                             diff_basis_w0,       &
                             ndf_w2, undf_w2,     &
                             map_w2(:,cell),      &
                             basis_w2,            &
                             ndf_w3, undf_w3,     &
                             map_w3(:,cell),      &
                             basis_w3,            &
                             ndf_w0, undf_w0,     &
                             map_w0(:,cell),      &
                             diff_basis_w0,       &
                             nqp_h, nqp_v, wh, wv &
                             )
    end do
    allocate( answer(undf_w0) )
    ! Simple test, check that when theta=const, f/rho.grad(theta) = 0
    answer(:) = 0.0_r_def
    @assertEqual( answer, r_theta_data(:), tol )

    deallocate(answer)
    deallocate(r_theta_data)
    deallocate(theta_data)
    deallocate(theta_n_data)
    deallocate(f_data)
    deallocate(rho_data)
    deallocate(chi_data)
    deallocate(map_w0)
    deallocate(map_w2)
    deallocate(map_w3)
    deallocate(basis_w0)
    deallocate(basis_w2)
    deallocate(basis_w3)
    deallocate(diff_basis_w0)
    deallocate(xp)
    deallocate(zp)
    deallocate(wv)
    deallocate(wh)

  end subroutine test_all

end module rtheta_supg_kernel_mod_test
