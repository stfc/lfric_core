!-------------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-------------------------------------------------------------------------------
!> @brief Calculates the mass fluxes in the x and y direction using the
!>        symmetric COSMIC method.
!> @details The algorithm below outputs the mass fluxes at timestep n+1 (np1)
!>          given the wind fields at timestep n and n+1 and the density field at
!>          timestep n.
module cusph_split_transport_alg_mod

  use constants_mod,                     only: r_def, i_def, LARGE_REAL_NEGATIVE
  use field_mod,                         only: field_type
  use function_space_mod,                only: function_space_type
  use flux_direction_mod,                only: x_direction, y_direction
  use biperiodic_deppt_config_mod,       only: method
  use subgrid_config_mod,                only: dep_pt_stencil_extent
  use psykal_lite_mod,                   only: invoke_calc_deppts,           &
                                               invoke_extract_xy,            &
                                               invoke_cosmic_departure_wind, &
                                               invoke_correct_cosmic_wind

  use log_mod,                           only: LOG_LEVEL_INFO

  use oned_density_update_alg_mod,       only: oned_density_update_alg
  use conservative_flux_alg_mod,         only: conservative_flux_alg

  implicit none

  private
  public :: cusph_split_transport_alg

contains

  !> @brief   The algorithm returns mass flux in the x and y directions separately
  !>          with input the density field and winds at timestep n and n+1.
  !> @details The algorithm is composed of four main stages. The first stage is to 
  !>          derive the winds used to calculate the departure points for the 
  !>          Cosmic scheme. The second stage is to then calculate the departure
  !>          points.
  !>          The third and fourth stages are to perform the advective and conservative
  !>          updates respectively.
  !>          The wind fields for the Cosmic scheme need to be in finite-volume
  !>          form and in this algorithm we modify the given Piola winds to ensure
  !>          that the winds have the appropriate magnitude by dividing by detJ
  !>          at the W2 dofs and also ensuring that physically the winds have the
  !>          correct sign.
  !>          Once the appropriate winds are calculated the departure points are
  !>          then calculated.
  !> @param[in]     rho               Density at time level n
  !> @param[in]     cell_orientation  Orientation of cells held in W3 field
  !> @param[in,out] mass_flux_x       Mass fluxes in x direction used to update density
  !> @param[in,out] mass_flux_y       Mass fluxes in y direction used to update density
  !> @param[in]     dep_pts_x         Departure points in x direction
  !> @param[in]     dep_pts_y         Departure points in y direction
  !> @param[in]     detj_at_w2        Detj values at W2 dof locations
  subroutine cusph_split_transport_alg( rho,                &
                                        cell_orientation,   &
                                        mass_flux_x,        &
                                        mass_flux_y,        &
                                        dep_pts_x,          &
                                        dep_pts_y,          &
                                        detj_at_w2 )

    implicit none

    type(field_type),    intent(in)     :: rho
    type(field_type),    intent(in)     :: cell_orientation
    type(field_type),    intent(inout)  :: mass_flux_x
    type(field_type),    intent(inout)  :: mass_flux_y
    type(field_type),    intent(in)     :: dep_pts_x
    type(field_type),    intent(in)     :: dep_pts_y
    type(field_type),    intent(in)     :: detj_at_w2

    type( field_type ) :: rho_adv_x, rho_adv_y, rho_hat_adv_x, rho_hat_adv_y
    type( field_type ) :: rho_x, rho_y

    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()

    w3_fs => rho%get_function_space()
    w2_fs => mass_flux_x%get_function_space()

    rho_adv_x          = field_type( vector_space = w3_fs )
    rho_adv_y          = field_type( vector_space = w3_fs )
    rho_hat_adv_x      = field_type( vector_space = w3_fs )
    rho_hat_adv_y      = field_type( vector_space = w3_fs )
    rho_x              = field_type( vector_space = w3_fs )
    rho_y              = field_type( vector_space = w3_fs )

    ! Perform two 1D advective updates in the x and y directions (horizontal)
    call oned_density_update_alg(x_direction, dep_pts_x,       &
                                  cell_orientation, detj_at_w2, rho, rho_adv_x)
    call oned_density_update_alg(y_direction, dep_pts_y,       &
                                  cell_orientation, detj_at_w2, rho, rho_adv_y)

    ! Average the two advective density updates with the density at timestep level n
    call invoke( name = "average_rho_and_init_mass_fluxes",                       &
                 aX_plus_bY(rho_hat_adv_x, 0.5_r_def, rho, 0.5_r_def, rho_adv_x), &
                 aX_plus_bY(rho_hat_adv_y, 0.5_r_def, rho, 0.5_r_def, rho_adv_y), &

    ! Calculate separately the conservative fluxes in the x and y directions (horizontal)
                 setval_c(mass_flux_x, 0.0_r_def),                                &
                 setval_c(mass_flux_y, 0.0_r_def) )

    call conservative_flux_alg(dep_pts_x, dep_pts_y,             &
                           cell_orientation, rho_hat_adv_x, rho_hat_adv_y, mass_flux_x, mass_flux_y )

    nullify( w2_fs )
    nullify( w3_fs )

  end subroutine cusph_split_transport_alg

end module cusph_split_transport_alg_mod
