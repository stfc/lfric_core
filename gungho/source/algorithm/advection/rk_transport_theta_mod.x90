!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief To solve the advection equation of a theta-type tracer using a
!>        split-approach with a semi-Lagrangian in the vertical and a
!>        multi-step RK method in the horizontal.
!>
!> @todo There are number of workarounds in this algorithm for aspects which
!!       aren't yet supported by PSyclone/LFRic:
!!       1. Issue #868 Multidata fields are not natively supported in PSyclone.
!!                     Currently we treat these as normal fields but need to
!!                     additionally pass in ndata_h or ndata_v to the kernels
!!                     as extra integer arguments.
!!       2. Issue #1246 Region stencils require both the global maximum size of
!!                      the stencil and local column size of the stencil.
!!                      PSyclone currently only passes in the local size and so
!!                      until this is resolved we also pass in the global maximum
!!                      size as an integer argument.
module rk_transport_theta_mod

  use constants_mod,                      only: r_def, i_def, l_def, tiny_eps
  use log_mod,                            only: log_event,         &
                                                LOG_LEVEL_INFO,    &
                                                LOG_LEVEL_ERROR
  use fs_continuity_mod,                  only: W1, W2, Wtheta
  ! Configuration options
  use finite_element_config_mod,          only: element_order
  use runge_kutta_init_mod,               only: num_rk_stage, ak
  use fem_constants_mod,                  only: get_mass_matrix,               &
                                                get_mass_matrix_diagonal,      &
                                                get_multiplicity,              &
                                                get_qr
  use geometric_constants_mod,            only: get_coordinates,               &
                                                get_panel_id
  use transport_config_mod,               only: operators,                     &
                                                fv_flux_order,                 &
                                                fv_advective_order,            &
                                                operators_fv,                  &
                                                operators_fem,                 &
                                                oned_reconstruction,           &
                                                consistent_metric,             &
                                                theta_splitting_vh,            &
                                                theta_splitting_hv,            &
                                                theta_splitting_strang,        &
                                                cfl_mol_2d_stab

  ! PsyKAl PSYClone kernels
  use rtheta_kernel_mod,                  only: rtheta_kernel_type
  use poly_advective_kernel_mod,          only: poly_advective_kernel_type
  use consistent_wind_kernel_mod,         only: consistent_wind_kernel_type
  use sample_field_kernel_mod,            only: sample_field_kernel_type
  use poly1d_adv_recon_kernel_mod,        only: poly1d_adv_recon_kernel_type
  use poly1d_vert_adv_kernel_mod,         only: poly1d_vert_adv_kernel_type
  use poly2d_adv_recon_kernel_mod,        only: poly2d_adv_recon_kernel_type
  use matrix_vector_kernel_mod,           only: matrix_vector_kernel_type
  ! Derived Types
  use field_mod,                          only: field_type
  use function_space_mod,                 only: function_space_type
  use function_space_collection_mod,      only: function_space_collection
  use quadrature_xyoz_mod,                only: quadrature_xyoz_type
  use operator_mod,                       only: operator_type

  ! Algorithms
  use mass_matrix_solver_alg_mod,         only: mass_matrix_solver_alg
  ! Log
  use io_config_mod,                      only: subroutine_timers
  use timer_mod,                          only: timer
  use advective_update_alg_mod,           only: advective_update_alg_init,     &
                                                advective_update_alg_final,    &
                                                get_adv_coeffs,                &
                                                get_vert_adv_coeffs,           &
                                                get_chi3_at_wt,                &
                                                get_adv_stencil_extent,        &
                                                get_adv_2d_stencil_size,       &
                                                get_adv_ndata_h,               &
                                                get_adv_ndata_v

  use runtime_tools_mod,                  only: find_mesh_index

  implicit none

  private

  logical(kind=l_def) :: variables_allocated = .false.

  ! 'State' items that need to be created once but used every step
  type(field_type), allocatable :: mt_lumped(:)
  type(field_type), allocatable :: theta_av(:)
  type(field_type), allocatable :: theta_metrics(:)
  type(field_type), allocatable :: r_theta(:)
  type(field_type), allocatable :: theta_inc(:)
  type(field_type), allocatable :: rt_prediction(:,:)
  type(field_type), allocatable :: advective_av_chi3(:)

  public :: rk_transport_theta_step
  public :: rk_transport_theta_set_num_meshes
  public :: rk_transport_theta_init
  public :: rk_transport_theta_final

contains

  !=============================================================================
  !> @brief A Runge-Kutta time-discretisation of the advection equation.
  !> @details An algorithm for timstepping the advection equation using the
  !>          Runge-Kutta method.
  !> @param[in]     u 3D wind field
  !> @param[in,out] theta A theta/tracer type field
  !> @param[in]     dts Local timestep
  !=============================================================================
  subroutine rk_transport_theta_step( u, theta, dts )

    implicit none

    ! Prognostic fields
    type(field_type), intent(in)    :: u
    type(field_type), intent(inout) :: theta
    real(kind=r_def), intent(in)    :: dts

    ! The quadrature object
    type(quadrature_xyoz_type ), pointer :: qr => null()
    ! Coordinate fields
    type(field_type), pointer :: chi_sph(:) => null()
    type(field_type), pointer :: adv_coeffs => null()
    type(field_type), pointer :: vert_adv_coeffs => null()
    type(field_type), pointer :: chi3_at_wt => null()
    type(field_type), pointer :: w1_multiplicity => null()
    type(field_type)          :: consistent_wind
    type(field_type)          :: theta_n

    integer(kind=i_def)          :: stage, st, mesh_id, mesh_index
    integer(kind=i_def), pointer :: adv_stencil_extent => null()
    integer(kind=i_def), pointer :: adv_2d_stencil_size => null()
    integer(kind=i_def), pointer :: ndata_h => null()
    integer(kind=i_def), pointer :: ndata_v => null()

    if ( subroutine_timers ) call timer('rk_transport_theta_alg')

    mesh_id = u%get_mesh_id()
    mesh_index = find_mesh_index(mesh_id)

    ! Pointers to integer values
    adv_stencil_extent => get_adv_stencil_extent(mesh_id)
    adv_2d_stencil_size => get_adv_2d_stencil_size(mesh_id)
    ndata_h => get_adv_ndata_h(mesh_id)
    ndata_v => get_adv_ndata_v(mesh_id)
    ! Pointers to pre-computed fields
    adv_coeffs => get_adv_coeffs(mesh_id)
    vert_adv_coeffs =>  get_vert_adv_coeffs(mesh_id)
    chi3_at_wt => get_chi3_at_wt(mesh_id)
    w1_multiplicity => get_multiplicity(W1, mesh_id)

    qr => get_qr()
    chi_sph => get_coordinates(mesh_id)
    call theta%copy_field(theta_n)

    ! Runge-Kutta algorithm
    do stage = 1, num_rk_stage
      ! Compute advection terms
      select case(operators)
        case(operators_fv)
          ! Set default value (for theta_av)
          ! to be average of the field at W1 points and then update where the wind
          ! is non-zero using an upwind reconstruction
          call invoke( setval_c(theta_av(mesh_index), 0.0_r_def),              &
                       sample_field_kernel_type(theta_av(mesh_index),          &
                                                w1_multiplicity,               &
                                                theta) )
          if ( oned_reconstruction ) then
            call invoke( poly1d_adv_recon_kernel_type( theta_av(mesh_index),   &
                                                       u, theta,               &
                                                       adv_stencil_extent,     &
                                                       adv_coeffs,             &
                                                       ndata_h,                &
                                                       fv_advective_order ) )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then
              ! Set default value (for advective_av_chi3)
              ! to be average of the field at W1 points and then update where the wind
              ! is non-zero using an upwind reconstruction
              call invoke( setval_c(advective_av_chi3(mesh_index), 0.0_r_def), &
                           sample_field_kernel_type(                           &
                                                advective_av_chi3(mesh_index), &
                                                w1_multiplicity,               &
                                                chi3_at_wt),                   &
                           poly1d_adv_recon_kernel_type(                       &
                                                advective_av_chi3(mesh_index), &
                                                u, chi3_at_wt,                 &
                                                adv_stencil_extent,            &
                                                adv_coeffs,                    &
                                                ndata_h, fv_advective_order ) )
            end if
          else
            ! Use 2d flux code
            call invoke( poly2d_adv_recon_kernel_type(                         &
                                                  theta_av(mesh_index),        &
                                                  u, theta,                    &
                                                  adv_stencil_extent,          &
                                                  adv_coeffs,                  &
                                                  ndata_h,                     &
                                                  adv_2d_stencil_size ) )
            ! Horizontal advection of metric terms
            if ( consistent_metric ) then
              call invoke( sample_field_kernel_type(                           &
                                                advective_av_chi3(mesh_index), &
                                                w1_multiplicity,               &
                                                chi3_at_wt ),                  &
                           poly2d_adv_recon_kernel_type(                       &
                                                advective_av_chi3(mesh_index), &
                                                u, chi3_at_wt,                 &
                                                adv_stencil_extent,            &
                                                adv_coeffs,                    &
                                                ndata_h,                       &
                                                adv_2d_stencil_size ) )
            end if
          end if
          call invoke( poly_advective_kernel_type(                             &
                                              rt_prediction(stage,mesh_index), &
                                              u, theta_av(mesh_index)) )

          ! Compute vertical components of advective update
          call u%copy_field(consistent_wind)
          if ( consistent_metric ) then
            call invoke( poly_advective_kernel_type(                           &
                                              theta_metrics(mesh_index), u,    &
                                              advective_av_chi3(mesh_index)),  &
            ! Modify advecting wind
                         consistent_wind_kernel_type(                          &
                                              consistent_wind, u,              &
                                              theta_metrics(mesh_index),       &
                                              chi_sph) )
          end if
          call invoke( poly1d_vert_adv_kernel_type(                            &
                                              rt_prediction(stage,mesh_index), &
                                              consistent_wind, theta,          &
                                              vert_adv_coeffs,                 &
                                              ndata_v, fv_advective_order,     &
                                              0_i_def ) )
        case(operators_fem)
          ! Use FEM projection
          ! Initialise fields
          call invoke( name = "FEM advection of theta",                        &
                       setval_c(rt_prediction(stage,mesh_index), 0.0_r_def),   &
          ! Theta advection
                       rtheta_kernel_type( rt_prediction(stage,mesh_index),    &
                                           theta, u, qr) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select

      call invoke( setval_c(r_theta(mesh_index), 0.0_r_def) )

      do st = 1, stage
        call invoke( inc_X_plus_bY(r_theta(mesh_index), ak(stage,st),          &
                                   rt_prediction(st,mesh_index)) )
      end do

      ! Theta
      select case(operators)
        case(operators_fv) ! theta in Wtheta
          call invoke( inc_X_divideby_Y(r_theta(mesh_index),                   &
                                        mt_lumped(mesh_index)),                &
                       X_minus_bY(theta, theta_n,                              &
                                  dts, r_theta(mesh_index)) )
        case(operators_fem)
          call mass_matrix_solver_alg( theta_inc(mesh_index),                  &
                                       r_theta(mesh_index))
          call invoke( X_minus_bY(theta, theta_n, dts, theta_inc(mesh_index)) )
        case default
          call log_event( "Gungho: Invalid advection method", LOG_LEVEL_ERROR )
      end select
    end do

    nullify( chi_sph )
    if ( subroutine_timers ) call timer('rk_transport_theta_alg')

  end subroutine rk_transport_theta_step

  !=============================================================================
  !> @brief Allocates the lists of fields used in this module
  !> @param[in] number_of_meshes Number of meshes to have coefficients on.
  !=============================================================================
  subroutine rk_transport_theta_set_num_meshes( number_of_meshes )

    implicit none

    integer(kind=i_def), intent(in) :: number_of_meshes

    ! Allocate the arrays of variables
    if (.not. variables_allocated) then
      if (.not. allocated(advective_av_chi3)) allocate(advective_av_chi3(number_of_meshes))
      if (.not. allocated(theta_metrics)) allocate(theta_metrics(number_of_meshes))
      if (.not. allocated(mt_lumped)) allocate(mt_lumped(number_of_meshes))
      if (.not. allocated(theta_av)) allocate(theta_av(number_of_meshes))
      if (.not. allocated(r_theta)) allocate(r_theta(number_of_meshes))
      if (.not. allocated(theta_inc)) allocate(theta_inc(number_of_meshes))
      if (.not. allocated(rt_prediction)) allocate(rt_prediction(num_rk_stage, number_of_meshes))
      variables_allocated = .true.
    else
      call log_event('Variables have already been allocated for ' // &
                     'advective_update_alg', LOG_LEVEL_ERROR)
    end if

  end subroutine

  !=============================================================================
  !> @brief Initialise fields for the Runge-Kutta theta transport algorithm for
  !>        a particular mesh.
  !> @param[in] Mesh_id Mesh id of mesh on which the model runs
  !=============================================================================
  subroutine rk_transport_theta_init( mesh_id )

    implicit none

    ! Mesh id
    integer(i_def), intent(in) :: mesh_id

    integer(kind=i_def)  :: mesh_index, stage
    type(field_type) :: ones

    type(function_space_type), pointer :: theta_fs => null()
    type(function_space_type), pointer :: w1_fs => null()
    type(operator_type),       pointer :: mm_wt => null()

    if ( subroutine_timers ) call timer('rk_transport_theta_init')

    mesh_index = find_mesh_index(mesh_id)

    ! Get function spaces for this mesh
    theta_fs => function_space_collection%get_fs( mesh_id, element_order, Wtheta )
    w1_fs => function_space_collection%get_fs( mesh_id, element_order, W1 )

    ! Initialise the fields
    call r_theta(mesh_index)%initialise( vector_space = theta_fs )
    call theta_inc(mesh_index)%initialise( vector_space = theta_fs )
    call theta_av(mesh_index)%initialise( vector_space = w1_fs )
    if ( consistent_metric ) call theta_metrics(mesh_index)%initialise( vector_space = theta_fs )
    call advective_av_chi3(mesh_index)%initialise( vector_space = w1_fs )

    do stage = 1, num_rk_stage
      call rt_prediction(stage,mesh_index)%initialise( vector_space = theta_fs )
    end do

    ! Compute mt_lumped
    mm_wt => get_mass_matrix(Wtheta, mesh_id)
    call ones%initialise( vector_space = theta_fs )
    call mt_lumped(mesh_index)%initialise( vector_space = theta_fs )
    call invoke( name = "Compute mt_lumped",     &
                 setval_c(ones,      1.0_r_def), &
                 setval_c(mt_lumped(mesh_index), 0.0_r_def), &
                 matrix_vector_kernel_type(mt_lumped(mesh_index), ones, mm_wt) )

    call advective_update_alg_init(mesh_id)

    nullify( theta_fs, w1_fs, mm_wt )

    if ( subroutine_timers ) call timer('rk_transport_theta_init')

  end subroutine rk_transport_theta_init

  !===========================================================================
  !> @brief Deallocate arrays used in transport.
  !===========================================================================
  subroutine rk_transport_theta_final()

    implicit none

    if (allocated(mt_lumped)) deallocate(mt_lumped)
    if (allocated(theta_av)) deallocate(theta_av)
    if (allocated(theta_metrics)) deallocate(theta_metrics)
    if (allocated(r_theta)) deallocate(r_theta)
    if (allocated(theta_inc)) deallocate(theta_inc)
    if (allocated(rt_prediction)) deallocate(rt_prediction)

    call advective_update_alg_final()

  end subroutine rk_transport_theta_final

end module rk_transport_theta_mod
