!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!
!> @brief Contains methods and algorithms for solving a system A.x = b for known
!! input field b and matrix A and returns field x
!!
!! @details Contains a selction of solvers for inverting the matrix vector
!! system A.x = b to return x = A^{-1}.b Depending upom the type of system to
!! solve a number of iterative solver algorithms are possible or for
!! discontinuous systems an exact solver can be used
module solver_mod

  use constants_mod,             only : r_def, str_def, i_def
  use field_mod,                 only : field_type
  use fs_continuity_mod,         only : W0, W1, W2, W3, Wtheta, W2v, W2h, fs_name
  use function_space_mod,        only : function_space_type
  use log_mod,                   only : log_event,         &
                                        log_scratch_space, &
                                        LOG_LEVEL_ERROR,   &
                                        LOG_LEVEL_INFO,    &
                                        LOG_LEVEL_DEBUG,   &
                                        LOG_LEVEL_TRACE
  use matrix_vector_kernel_mod,  only : matrix_vector_kernel_type
  use enforce_bc_kernel_mod,     only : enforce_bc_kernel_type
  use operator_mod,              only : operator_type
  use solver_config_mod,         only : method,                         &
                                        solver_method_cg,               &
                                        solver_method_bicgstab,         &
                                        solver_method_jacobi,           &
                                        solver_method_gmres,            &
                                        solver_method_gcr,              &
                                        tolerance,                      &
                                        maximum_iterations,             &
                                        preconditioner,                 &
                                        solver_preconditioner_none,     &
                                        solver_preconditioner_diagonal, &
                                        gcrk
  use runtime_constants_mod,     only : get_coordinates, &
                                        get_mass_matrix, &
                                        get_mass_matrix_diagonal, &
                                        w3inv_id, w0_id, w1_id, w2_id, wt_id
  use output_config_mod,         only : subroutine_timers 
  use timer_mod,                 only : timer
  implicit none

  private
  real(r_def), parameter :: sc_err_min = 1.0e-16_r_def
  public :: solver_algorithm
  ! Auxiliary constants to group invokes
  real(kind=r_def), private :: const1

contains

!> @brief Wrapper for specific solver routines for solving system A.x = b
!! @details solves A.x = b for using a choice of solver where A is a mass
!! matrix for a given space and x and b are fields belonging to that space.
!! For a discontinous space the element mass matrix is exactly inverted, for
!! continuous spaces an iterative solver is used.
!! The current choices of iteratives solver are:
!! cg: Conjugate gradient method without preconditioning
!! bicgstab: bi-conjugate gradient, stabilised without preconditioning
!! jacobi: a fixed number of jacobi iterations
!> @param[inout] lhs Field to be solved for (x)
!> @param[inout] rhs Right hand side field (b)
!> @param[in] bc_flag Flag to overide default boundary condition application
  subroutine solver_algorithm( lhs, rhs, bc_flag )
    use dg_matrix_vector_kernel_mod,  only : dg_matrix_vector_kernel_type

    implicit none

    type(field_type), intent(inout) :: lhs
    type(field_type), intent(inout) :: rhs
    logical, intent(in), optional :: bc_flag

    type(operator_type), pointer :: mm => null()
    type(field_type),    pointer :: mmd => null()

    integer(i_def) :: fs_l, fs_r

    logical :: apply_bc

    if ( subroutine_timers ) call timer('solver_alg')


    fs_l = lhs%which_function_space()
    fs_r = rhs%which_function_space()

    if ( fs_l /= fs_r ) & 
      call log_event('Non matching function spaces in solver algorithm', LOG_LEVEL_ERROR )

    ! Check boundary conditions need to be applied
    if (fs_l == w1 .or. fs_l == w2 .or. fs_l == w2h .or. fs_l == w2v) then
      apply_bc = .true.
    else
      apply_bc = .false.
    end if
    ! Override the default with the value in bc_flag if it is present
    ! This allows us finer control in certain situations, e.g dont apply bc's where
    ! we naturally would
    if ( present(bc_flag) )  apply_bc = bc_flag

    if(fs_l == W3) then
      mm => get_mass_matrix(w3inv_id)
      call invoke( dg_matrix_vector_kernel_type(lhs, rhs, mm) )
    else
      ! Pull out correct operators
      select case ( fs_l )
        case ( W0 )
          mm  => get_mass_matrix(w0_id)
          mmd => get_mass_matrix_diagonal(w0_id)
        case ( W1 )
          mm  => get_mass_matrix(w1_id)
          mmd => get_mass_matrix_diagonal(w1_id)
        case ( W2 )
          mm  => get_mass_matrix(w2_id)
          mmd => get_mass_matrix_diagonal(w2_id)
        case ( Wtheta )
          mm  => get_mass_matrix(wt_id)
          mmd => get_mass_matrix_diagonal(wt_id)
        case default
          call log_event('Unsupported function space in solver algorithm', LOG_LEVEL_ERROR )
      end select
      select case ( method )
        case ( solver_method_cg )
          call cg_solver_algorithm(lhs, rhs, mm, mmd, apply_bc)
        case ( solver_method_bicgstab )
          call bicg_solver_algorithm(lhs, rhs, mm, mmd, apply_bc)
        case ( solver_method_jacobi )
          call jacobi_solver_algorithm(lhs, rhs, mm, apply_bc)
        case ( solver_method_gmres )
          call gmres_solver_algorithm( lhs, rhs, mm, mmd, apply_bc)
        case ( solver_method_gcr )
          call gcr_solver_algorithm(lhs, rhs, mm, mmd, apply_bc)
        case default
          write( log_scratch_space, '(A)' )  'Invalid linear solver choice, stopping'
          call log_event( log_scratch_space, LOG_LEVEL_ERROR )
      end select
    end if
    if ( subroutine_timers ) call timer('solver_alg')

  end subroutine solver_algorithm

!> @brief BiCGStab solver.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! the stabilised bi-conjugate gradient method. The choice of matrix is
!! encoded in the matrix vector kernel that is called
!! @param[in]  rhs_field Input b
!! @param[inout] lhs_field The answer, x
!! @param[in] mm operator type, Mass matrix
!! @param[in] mmd Mass matrix diagonal
!! @param[in] apply_bc Flag to determine if boundary conditions are applied
  subroutine bicg_solver_algorithm(lhs, rhs, mm, mmd, apply_bc)
    implicit none
    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(in)    :: mm
    type(field_type),    intent(in)    :: mmd
    logical ,intent(in) :: apply_bc

    type(function_space_type), pointer :: rhs_fs => null()

    ! The temporary fields
    type(field_type)                   :: res, p, v, s, t, z, y

    ! The scalars
    ! The greeks - standard BiCGStab
    real(kind=r_def)                   :: rho,alpha,omega,beta, norm
    real(kind=r_def)                   :: ts,tt
    ! Others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(i_def)                     :: iter
    integer(i_def)                     :: fs

    fs = lhs%which_function_space()

    ! Compute the residual this is a global sum to the PSy ---
    call invoke( X_innerproduct_X(sc_err, rhs) )
    sc_err = max(sqrt(sc_err), sc_err_min)
    write( log_scratch_space, '(A,E15.8)' ) &
         "solver_algorithm: bicgstab starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )

    alpha  = 1.0_r_def
    omega  = 1.0_r_def
    norm   = 1.0_r_def

    rhs_fs => rhs%get_function_space()

    v   = field_type( vector_space = rhs_fs )
    z   = field_type( vector_space = rhs_fs )
    p   = field_type( vector_space = rhs_fs )
    t   = field_type( vector_space = rhs_fs )
    s   = field_type( vector_space = rhs_fs )
    y   = field_type( vector_space = rhs_fs )
    res = field_type( vector_space = rhs_fs )

    call invoke( setval_c(lhs, 0.0_r_def), &
                 setval_X(res, rhs) )

    call invoke( X_innerproduct_X(err, res) )
    err = sqrt(err)/sc_err
    init_err=err
    if (err < tolerance) then
      write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)') &
          trim(fs_name(rhs_fs%which()))//                 &
          "-space solver_algorithm:converged in ", 0,     &
          " iters, init=", init_err,                      &
          " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
      return
   end if

    call invoke( setval_c(v, 0.0_r_def), & 
                 setval_c(p, 0.0_r_def) )

    do iter = 1, maximum_iterations

      call invoke( X_innerproduct_Y(rho, res, rhs) )
      beta = (rho/norm) * (alpha/omega)
      ! p = r + beta*(p - omega*v)
      call invoke( inc_aX_plus_Y(beta, p, res) )
      const1 = -beta*omega
      call invoke( inc_X_plus_bY(p, const1, v) )
      call precondition( y, p, preconditioner, mmd )
      call invoke( setval_c(v, 0.0_r_def), &
                   matrix_vector_kernel_type(v, y, mm) )
      if (apply_bc) call invoke( enforce_bc_kernel_type( v ) )
      call invoke( X_innerproduct_Y(norm, rhs, v) )
      alpha = rho/norm
      call invoke( X_minus_bY(s, res, alpha, v) )
      call precondition( z, s, preconditioner, mmd )
      call invoke( setval_c(t, 0.0_r_def), &
                   matrix_vector_kernel_type(t, z, mm) )
      if (apply_bc) call invoke( enforce_bc_kernel_type( t ) )

      call invoke( X_innerproduct_X(tt, t), &
                   X_innerproduct_Y(ts, t, s) )

      omega = ts/tt

      ! lhs = lhs + omega * z + alpha * y
      call invoke( inc_X_plus_bY(lhs, omega, z), &
                   inc_X_plus_bY(lhs, alpha, y), &
                   X_minus_bY(res, s, omega, t) )
      norm = rho

      ! Check for convergence
      call invoke( X_innerproduct_X(err, res) )
      err = sqrt(err)/sc_err

      write( log_scratch_space, '(A,I2,A, E15.8)' ) "solver_algorithm[", iter, &
                                                    "]: res = ", err
      call log_event(log_scratch_space, LOG_LEVEL_TRACE)

      if (err < tolerance) then
        write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)' ) &
            trim(fs_name(rhs_fs%which()))//                  &
            "-space solver_algorithm:converged in ", iter,   &
            " iters, init=", init_err,                       &
            " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if(iter >= maximum_iterations) then
      write(log_scratch_space, '(A, I3, A, E15.8)')     &
           "solver_algorithm: NOT converged in ", iter, &
           " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine bicg_solver_algorithm
!--------------------------------------------------

!> @brief CG solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! the conjugate gradient method. The choice of matrix is
!! encoded in the matrix vector kernel that is called.
!! @param[in] rhs_field Input b
!! @param[inout] lhs_field The answer, x
!! @param[in] mm Mass matrix
!! @param[in] mmd Mass matrix diagonal
!! @param[in] apply_bc Flag to determine if boundary conditions are applied
  subroutine cg_solver_algorithm(lhs, rhs, mm, mmd, apply_bc)
    implicit none
    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(in)    :: mm
    type(field_type),    intent(in)    :: mmd
    logical,             intent(in)    :: apply_bc

    type(function_space_type), pointer :: rhs_fs => null()

    ! The temporary fields
    type(field_type)                   :: res, p, Ap, z

    ! The scalars
    real(kind=r_def)                   :: alpha, beta
    real(kind=r_def)                   :: rs_new, rs_old
    ! Others
    real(kind=r_def)                   :: err,sc_err, init_err
    integer(i_def)                     :: iter
    integer(i_def)                     :: fs

    fs = lhs%which_function_space()

    call invoke( X_innerproduct_X(rs_old, rhs) )

    ! Compute the residual this is a global sum to the PSy ---

    rhs_fs => rhs%get_function_space()

    res = field_type(vector_space = rhs_fs )
    p   = field_type(vector_space = rhs_fs )
    Ap  = field_type(vector_space = rhs_fs )
    z   = field_type(vector_space = rhs_fs )

    call invoke( setval_c(lhs, 0.0_r_def), &
                 matrix_vector_kernel_type(Ap, lhs, mm) )
    if (apply_bc) call invoke( enforce_bc_kernel_type( Ap ) )

    call invoke( X_minus_Y(res, rhs, Ap) )
    call precondition( z, res, preconditioner, mmd )
    call invoke( setval_X(p, z) )

    call invoke( X_innerproduct_Y(rs_old, res, z) )
    err = sqrt(rs_old)
    sc_err = max(err, sc_err_min)
    init_err=sc_err
    write( log_scratch_space, '(A,E15.8)' ) &
         "cg solver_algorithm: starting ... ||b|| = ", sc_err
    call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
    if (err < tolerance) then
      write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
           "cg solver_algorithm:converged in ", 0,              &
           " iters, init=", init_err,                           &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if

    do iter = 1, maximum_iterations
       call invoke( setval_c(Ap, 0.0_r_def), &
                    matrix_vector_kernel_type(Ap, p, mm) )
       if (apply_bc) call invoke( enforce_bc_kernel_type( Ap ) )

      call invoke( X_innerproduct_Y(rs_new, p, Ap) )
      alpha = rs_old/rs_new

      call invoke( inc_X_plus_bY(lhs, alpha, p), &
                   inc_X_minus_bY(res, alpha, Ap) )

      ! Check for convergence
      call invoke( X_innerproduct_X(rs_new, res) )
      err = sqrt(rs_new)/sc_err

      write( log_scratch_space, '(A, I2, A, E15.8)' ) &
           "cg solver_algorithm[", iter, "]: res = ", err
      call log_event( log_scratch_space, LOG_LEVEL_TRACE )
      if (err < tolerance) then
        write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)' )  &
            trim(fs_name(rhs_fs%which()))//                   &
            "-space cg solver_algorithm:converged in ", iter, &
            " iters, init=", init_err,                        &
            " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if

      call precondition( z, res, preconditioner, mmd )
      call invoke( X_innerproduct_Y(rs_new, z, res) )
      beta = rs_new/rs_old
      rs_old = rs_new
      call invoke( inc_aX_plus_Y(beta, p, z) )

    end do

    if(iter >= maximum_iterations) then
      write( log_scratch_space, '(A, I3, A, E15.8)' )      &
           "cg solver_algorithm: NOT converged in ", iter, &
           " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine cg_solver_algorithm

!--------------------------------------------------

!> @brief Jacobi solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! a fixed (n_iter) number of iterations. The choice of matrix is
!! encoded in the matrix vector kernel that is called. No measure of convergence
!! is used instead the algorithm is assumed to have converged sufficiently
!! after (n_iter) iterations
!! @param[in] rhs_field Input b
!! @param[inout] lhs_field The answer, x
!! @param[in] mm Mass matrix
!! @param[in] apply_bc Flag to determine if boundary conditions are applied
  subroutine jacobi_solver_algorithm(lhs, rhs, mm, apply_bc)

  use mm_diagonal_kernel_mod, only: mm_diagonal_kernel_type
  implicit none

  type(field_type),    intent(inout) :: lhs, rhs
  type(operator_type), intent(in)    :: mm
  logical,             intent(in)    :: apply_bc
  type(field_type)                   :: Ax, diagonal, res

  real(kind=r_def), parameter :: MU = 0.9_r_def

  integer(i_def) :: iter

  type(function_space_type), pointer :: rhs_fs => null()
  integer(i_def)                     :: fs

  fs = lhs%which_function_space()

  rhs_fs => rhs%get_function_space()

  diagonal = field_type( vector_space = rhs_fs )
  res      = field_type( vector_space = rhs_fs )

  call invoke( mm_diagonal_kernel_type(diagonal, mm), &
               X_divideby_Y(lhs, rhs, diagonal) )

! Initial guess
  call invoke( setval_c(lhs, 0.0_r_def) )

  do iter = 1,maximum_iterations
    call invoke( setval_c(Ax, 0.0_r_def), &
                 matrix_vector_kernel_type(Ax, lhs, mm) )
    if (apply_bc) call invoke( enforce_bc_kernel_type( Ax ) )

    call invoke( X_minus_Y(res, rhs, Ax),         &
                 inc_X_divideby_Y(res, diagonal), &
                 inc_X_plus_bY(lhs, MU, res) )

! Ready for next iteration
  end do

  end subroutine jacobi_solver_algorithm

!--------------------------------------------------

!> @brief GMRes solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! GMRes algorithm. The choice of matrix is
!! encoded in the matrix vector kernel that is called. No measure of convergence
!! is used instead the algorithm is assumed to have converged sufficiently
!! after (n_iter) iterations
!! @param[in] rhs Input b
!! @param[inout] lhs Answer, x
!! @param[in] mm Mass matrix
!! @param[in] mmd Diagonal mass matrix used for conditioning
!! @param[in] apply_bc Flag to determine if boundary conditions are applied
  subroutine gmres_solver_algorithm(lhs, rhs, mm, mmd, apply_bc)

    implicit none
    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(in)    :: mm
    type(field_type),    intent(in)    :: mmd
    logical,             intent(in)    :: apply_bc
 
    ! The temporary fields
    type(field_type)                   :: Ax, r, s, w, v(GCRK)

    ! The scalars
    real(kind=r_def)                   :: h(GCRK+1, GCRK), u(GCRK), g(GCRK+1)
    real(kind=r_def)                   :: beta, si, ci, nrm, h1, h2, p, q
    ! Others
    real(kind=r_def)                   :: err, sc_err, init_err
    integer(i_def)                     :: iter, i, j, k, m

    type(function_space_type), pointer :: rhs_fs => null()
    integer(i_def) :: precond_option, postcond_option
    integer(i_def) :: fs

    fs = lhs%which_function_space()

    precond_option  = solver_preconditioner_none
    postcond_option = preconditioner

    rhs_fs => rhs%get_function_space() 

    Ax = field_type(vector_space = rhs_fs)
    r  = field_type(vector_space = rhs_fs)
    s  = field_type(vector_space = rhs_fs)
    w  = field_type(vector_space = rhs_fs)

    do iter = 1,GCRK
      v(iter) = field_type(vector_space = rhs_fs)
    end do

    call invoke( X_innerproduct_X(err, rhs) )
    sc_err = max( sqrt(err), sc_err_min )
    init_err = sc_err

    if (err < tolerance) then
      write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
           "gmres solver_algorithm:converged in ", 0,           &
           " iters, init=", init_err,                           &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if
    call invoke( setval_c(Ax, 0.0_r_def), &
                 matrix_vector_kernel_type(Ax, lhs, mm) )
    if (apply_bc) call invoke( enforce_bc_kernel_type( Ax ) )

    call invoke( X_minus_Y(r, rhs, Ax) )

    call precondition( s, r, precond_option, mmd )

    call invoke( X_innerproduct_X(err, s) )
    beta = sqrt(err)

    const1 = 1.0_r_def/beta
    call invoke( a_times_X(v(1), const1, s) )


    h(:,:) = 0.0_r_def
    g(:)   = 0.0_r_def
    g(1)   = beta

    do iter = 1, maximum_iterations

      do j = 1, GCRk

        call precondition( w, v(j), postcond_option, mmd )
        call invoke( setval_c(s, 0.0_r_def), &
                     matrix_vector_kernel_type(s, w, mm) )
        if (apply_bc) call invoke( enforce_bc_kernel_type( s ) )
 
        call precondition( w, s, precond_option, mmd )

        do k = 1, j
          call invoke( X_innerproduct_Y(h(k,j), v(k), w), &
                       inc_X_minus_bY(w, h(k,j), v(k)) )
        end do
        call invoke( X_innerproduct_X(err, w) )
        h(j+1,j) = sqrt( err )
        if( j < GCRk ) then
          const1 = 1.0_r_def/h(j+1,j)
          call invoke( a_times_X(v(j+1), const1, w) )
        end if
      end do

      ! Solve (7.23) of Wesseling (see Saad's book)
      do m = 1, GCRK
        nrm    = sqrt( h(m,m)*h(m,m) + h(m+1,m)*h(m+1,m) )
        si     = h(m+1,m)/nrm
        ci     = h(m,m)/nrm
        p      = ci*g(m) + si*g(m+1)
        q      = -si*g(m) + ci*g(m+1)
        g(m)   = p
        g(m+1) = q
        do j = m, GCRK
          h1       = ci*h(m,j)   + si*h(m+1,j)
          h2       =-si*h(m,j)   + ci*h(m+1,j)
          h(m,j)   = h1
          h(m+1,j) = h2
        end do
      end do

      u(GCRK) = g(GCRK)/h(GCRK,GCRK)
      do i = GCRK-1, 1, -1
        u(i) = g(i)
        do j = i+1, GCRK
          u(i) = u(i) - h(i,j)*u(j)
        end do
        u(i) = u(i)/h(i,i)
      end do

      do i = 1, GCRK
        call precondition( s, v(i), postcond_option, mmd )
        call invoke( inc_X_plus_bY(lhs, u(i), s) )
      end do

      ! Check for convergence
      call invoke( setval_c(Ax, 0.0_r_def), &
                   matrix_vector_kernel_type(Ax, lhs, mm) )
      if (apply_bc) call invoke( enforce_bc_kernel_type( Ax ) )

      call invoke( X_minus_Y(r, rhs, Ax) )

      call invoke( X_innerproduct_X(err, r) )
      beta = sqrt(err)

      err = beta/sc_err
      if( err <  tolerance ) then
        write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
             "GMRES solver_algorithm:converged in ", iter,        &
             " iters, init=", init_err,                           &
             " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if

      call precondition( s, r, precond_option, mmd )
      const1 = 1.0_r_def/beta
      call invoke( a_times_X(v(1), const1, s) )

      g(:) = 0.0_r_def
      g(1) = beta

    end do

    if( iter >= maximum_iterations .and. err >  tolerance ) then
      write( log_scratch_space, '(A, I3, A, E15.8)')          &
           "GMRES solver_algorithm: NOT converged in ", iter, &
           " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine gmres_solver_algorithm

!--------------------------------------------------

!> @brief GCR solver for the system A.x = b.
!! @details solves A.x = b where the operation A.x is encoded in a kernel using
!! the Preconditioned GCR(k) algorithm from Wesseling. The choice of matrix is
!! encoded in the matrix vector kernel that is called. No measure of convergence
!! is used instead the algorithm is assumed to have converged sufficiently
!! after (n_iter) iterations
!! @param[in] rhs_field Input b
!! @param[inout] lhs_field Answer, x
!! @param[in] mm Mass matrix
!! @param[in] mmd Mass matrix diagonal
!! @param[in] apply_bc Flag to determine if boundary conditions are applied
  subroutine gcr_solver_algorithm( lhs, rhs, mm, mmd, apply_bc )

    implicit none

    type(field_type),    intent(inout) :: lhs
    type(field_type),    intent(in)    :: rhs
    type(operator_type), intent(in)    :: mm
    type(field_type),    intent(in)    :: mmd
    logical,             intent(in)    :: apply_bc
    ! The temporary fields
    type(field_type)                   :: Ax, r, s(GCRK), v(GCRK)

    ! The scalars
    real(kind=r_def)                   :: alpha
    ! Others
    real(kind=r_def)                   :: err, sc_err, init_err
    integer(i_def)                     :: iter, m, n

    type(function_space_type), pointer :: rhs_fs => null()
    integer(i_def)                     :: fs

    fs = lhs%which_function_space()

    rhs_fs =>  rhs%get_function_space()

    Ax = field_type(vector_space = rhs_fs)
    r  = field_type(vector_space = rhs_fs)

    do iter = 1,GCRK
      s(iter)  = field_type (vector_space = rhs_fs)
      v(iter)  = field_type (vector_space = rhs_fs)
    end do
    call invoke( X_innerproduct_X(err, rhs) )
    sc_err = max( sqrt(err), sc_err_min )
    init_err = sc_err

    if (err < tolerance) then
      write( log_scratch_space, '(A, I2, A, E12.4, A, E15.8)' ) &
           "gcr solver_algorithm:converged in ", 0,             &
           " iters, init=", init_err,                           &
           " final=", err
      call log_event( log_scratch_space, LOG_LEVEL_DEBUG )
      return
    end if
    call invoke( setval_c(Ax, 0.0_r_def), &
                 matrix_vector_kernel_type(Ax, lhs, mm) )
    if (apply_bc) call invoke( enforce_bc_kernel_type( Ax ) )

    call invoke( X_minus_Y(r, rhs, Ax) )

    do iter = 1, maximum_iterations
      do m = 1, GCRk
        ! This is the correct settings -> call Precon(s(:,:,m),r,prit,prec)
        call precondition( s(m), r, preconditioner, mmd )
        call invoke( setval_c(v(m), 0.0_r_def), &
                     matrix_vector_kernel_type(v(m), s(m), mm) )
        if (apply_bc) call invoke( enforce_bc_kernel_type( v(m) ) )


        do n = 1, m-1
          call invoke( X_innerproduct_Y(alpha, v(m), v(n)), &
                       inc_X_minus_bY(v(m), alpha, v(n)),   &
                       inc_X_minus_bY(s(m), alpha, s(n)) )
        end do
        call invoke( X_innerproduct_X(err, v(m)) )
        alpha = sqrt(err)
        const1 = 1.0_r_def/alpha
        call invoke( inc_a_times_X(const1, v(m)),      &
                     inc_a_times_X(const1, s(m)),      &
                     X_innerproduct_Y(alpha, r, v(m)), &
                     inc_X_plus_bY(lhs, alpha, s(m)),  &
                     inc_X_minus_bY(r, alpha, v(m)) )
      end do

      call invoke( X_innerproduct_X(err, r) )
      err = sqrt( err )/sc_err
      if ( err <  tolerance ) then
        write( log_scratch_space, '(A,I2,A,E12.4,A,E15.8)' )   &
            trim(fs_name(rhs_fs%which()))//                    &
            "-space GCR solver_algorithm:converged in ", iter, &
            " iters, init=", init_err,                         &
            " final=", err
        call log_event( log_scratch_space, LOG_LEVEL_INFO )
        exit
      end if
    end do

    if( iter >= maximum_iterations .and. err >  tolerance ) then
      write( log_scratch_space, '(A, I3, A, E15.8)' )       &
           "GCR solver_algorithm: NOT converged in ", iter, &
           " iters, Res=", err
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

end subroutine gcr_solver_algorithm


!> @brief Applies a selected prconditioner to a vector x
!! @details Applies one of s number of preconditioners to a field x
!! and returns the preconditioned field y. Currently no preconditioner
!! is applied and y = x.
!! @param[in]    x Input field
!! @param[inout] y Output field
!! @param[in] preconditioner Type of preconditioner to be used
!! routine to use
  subroutine precondition(y, x, preconditioner, diagonal)

    implicit none

    type(field_type), intent(inout) :: y
    type(field_type), intent(in)    :: x
    integer(i_def),   intent(in)    :: preconditioner
    type(field_type), intent(in)    :: diagonal

    select case ( preconditioner )
      case ( solver_preconditioner_diagonal )
        call invoke( X_divideby_Y(y, x, diagonal) )
      case default ! Do nothing
        call invoke( setval_X(y, x) )
    end select

  end subroutine precondition

end module solver_mod
