!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Calls to the fast physics schemes
module fast_physics_alg_mod

  use section_choice_config_mod, only: boundary_layer,    &
                                       boundary_layer_um, &
                                       convection,        &
                                       convection_um

  use constants_mod,        only: i_def,r_def
  use log_mod,              only: log_event,       &
                                  LOG_LEVEL_ERROR, &
                                  LOG_LEVEL_INFO
  use io_config_mod,        only: subroutine_timers
  use timer_mod,            only: timer

  use physics_config_mod,   only: heldsuarez_wind_placement,   &
                                  heldsuarez_thermo_placement, &
                                  blayer_placement,            &
                                  convection_placement,        &
                                  convection_placement_fast,   &
                                  blayer_placement_fast
  use formulation_config_mod,    only: use_moisture
  use convection_config_mod,only: cv_scheme,                   &
                                  cv_scheme_lambert_lewis,     &
                                  cv_scheme_gregory_rowntree
  use cloud_config_mod,     only: scheme,                      &
                                  scheme_pc2

  ! Derived Types
  use field_mod,            only: field_type
  use field_collection_mod, only: field_collection_type

  ! Moisture species
  use mr_indices_mod,       only: nummr, imr_v
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type

#ifdef UM_PHYSICS
  ! UM BL scheme
  use bl_imp_alg_mod,  only: bl_imp_alg_step
  ! UM conv scheme
  use conv_ll_alg_mod, only: conv_ll_alg_step
  use conv_gr_alg_mod, only: conv_gr_alg_step
  use pc2_conv_coupling_alg_mod, only: pc2_conv_coupling_alg_step
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          within the outer loop of the solver
  !> @param[in,out] du                Increment to wind field
  !> @param[in,out] dtheta            Increment to theta field
  !> @param[in,out] mr                Mixing ratios
  !> @param[in]     theta             Theta field
  !> @param[in]     rho               Rho on w3 space
  !> @param[in]     exner             Exner pressure on w3 space
  !> @param[in]     mr_n              Mixing ratios at time level n
  !> @param[in]     derived_fields    Group of derived fields
  !> @param[in]     radition_fields   Fields for radiation scheme
  !> @param[in]     orography_fields  Fields for orog drag scheme
  !> @param[in,out] turbulence_fields Fields for turbulence scheme
  !> @param[in,out] convection_fields Fields for convection scheme
  !> @param[in,out] cloud_fields      Fields for cloud scheme
  !> @param[in,out] surface_fields    Fields for surface scheme
  !> @param[in]     soil_fields       Fields for soil hydrology scheme
  !> @param[in]     snow_fields       Fields for snow scheme
  !> @param[in]     dA                Areas of faces
  !> @param[in]     height_w3         Height in w3
  !> @param[in]     height_wth        Height in wth
  !> @param[in]     delta             Edge length on wtheta points
  !> @param[in]     outer             Outer loop counter
    subroutine fast_physics(du, dtheta, mr, theta, rho, exner, mr_n,           &
                            derived_fields, radiation_fields, orography_fields,&
                            turbulence_fields, convection_fields, cloud_fields,&
                            surface_fields, soil_fields, snow_fields,          &
                            dA, height_w3, height_wth, delta, outer)

    implicit none

    ! Fields
    type( field_type ), intent( inout ) :: du, dtheta
    type( field_type ), intent( in )    :: theta, rho, exner

    ! Field bundles
    type( field_type ), intent( inout )    :: mr(nummr)
    type( field_type ), intent( in )       :: mr_n(nummr)

    ! Field groups
    type( field_collection_type ), intent(in)    :: derived_fields
    type( field_collection_type ), intent(in)    :: radiation_fields
    type( field_collection_type ), intent(in)    :: orography_fields
    type( field_collection_type ), intent(inout) :: turbulence_fields
    type( field_collection_type ), intent(inout) :: convection_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: surface_fields
    type( field_collection_type ), intent(in)    :: soil_fields
    type( field_collection_type ), intent(in)    :: snow_fields

    ! Coordinate fields
    type( field_type ), intent( in )    :: dA, height_w3, height_wth
    type( field_type ), intent( in )    :: delta

    ! scalars
    integer(kind=i_def), intent(in)     :: outer

    ! Local fields (should be created at initialization, but done here for the time being)
    type( field_type ) :: dtheta_bl
    type( field_type ) :: du_bl

    type( field_type), pointer :: dmv_conv => null()

    logical :: boundary_layer_done ! Flag to indicate that boundary_layer has been calculated
    logical :: convection_done ! Flag to indicate that convection has been calculated

    integer(i_def) :: i_mr

    if ( subroutine_timers ) call timer("fast_physics")

    boundary_layer_done=.false.
    convection_done=.false.

    if (heldsuarez_wind_placement > 0)then
      call log_event( &
         'fast_physics: Held-Suarez wind forcing is not currently available in fast physics.', &
         LOG_LEVEL_ERROR )
    end if

    if (heldsuarez_thermo_placement > 0)then
      call log_event( &
         'fast_physics: Held-Suarez thermal forcing is not currently available in fast physics.', &
         LOG_LEVEL_ERROR )
    end if

#ifdef UM_PHYSICS
    if (convection == convection_um .and.                       &
        convection_placement == convection_placement_fast) then
      if ( cv_scheme == cv_scheme_lambert_lewis ) then
        ! Algorithm that calls the UM Lambert Lewis convection scheme
        call log_event( 'fast_physics: Running the LL convection scheme', LOG_LEVEL_INFO )
        call conv_ll_alg_step(mr, exner, derived_fields, convection_fields,    &
                              outer)
      else if ( cv_scheme == cv_scheme_gregory_rowntree ) then
        ! Algorithm that calls the UM Gregory Rowntree convection scheme
        call log_event( 'fast_physics: Running the GR convection scheme', LOG_LEVEL_INFO )
        call conv_gr_alg_step(mr, rho, exner, derived_fields,                  &
                              turbulence_fields, convection_fields,            &
                              cloud_fields, surface_fields, height_w3,         &
                              height_wth, delta, outer)
      end if

      if ( scheme == scheme_pc2 ) then
        call pc2_conv_coupling_alg_step( mr, derived_fields,                  &
                                         convection_fields, cloud_fields )
      else if (cv_scheme == cv_scheme_gregory_rowntree) then
        ! Without PC2, just update vapour field
        ! @todo This should also be done for LL, but currently the increment is
        ! @todo added in the algorithm above - this will be fixed in #2006
        dmv_conv => convection_fields%get_field('dmv_conv')
        call invoke( inc_X_plus_Y(mr(imr_v), dmv_conv) )
      end if

      ! Flag that convection has been done in this timestep and increments
      ! need adding later in BL scheme
      convection_done=.true.
    end if

    if (boundary_layer == boundary_layer_um .and. &
        blayer_placement == blayer_placement_fast) then
      ! Algorithm that calls the UM implicit Boundary Layer scheme
      call log_event( 'fast_physics: Running implicit Boundary layer', LOG_LEVEL_INFO )
      call dtheta%copy_field_properties(dtheta_bl)
      call du%copy_field_properties(du_bl)
      call invoke( setval_c(dtheta_bl, 0.0_r_def), &
                   setval_c(du_bl, 0.0_r_def) )
      call bl_imp_alg_step(dtheta_bl, du_bl, mr, theta, exner, mr_n,           &
                           derived_fields, radiation_fields, orography_fields, &
                           turbulence_fields, convection_fields, cloud_fields, &
                           surface_fields, soil_fields, snow_fields,           &
                           dA, height_w3, height_wth, outer)
      boundary_layer_done=.true. ! We've done it, so need to collect this term later on
    end if
#endif

    !=====================================
    ! collect individual terms in parallel
    ! N.B. as currently coded, the convection increments are added in the
    ! boundary layer as part of the implicit solution
    !=====================================
    if (boundary_layer_done) then
      call invoke(inc_X_plus_Y(du, du_bl), &
                  inc_X_plus_Y(dtheta, dtheta_bl) )
    else if (convection_done) then
      call log_event(&
         'fast_physics: Cannot call convection without boundary-layer.', &
         LOG_LEVEL_ERROR )
    end if

    call dtheta%log_minmax(LOG_LEVEL_INFO, 'fast physics: dtheta' )
    call du%log_minmax(LOG_LEVEL_INFO, 'fast physics: du' )

    if (use_moisture) then
      do i_mr = 1, nummr
        call invoke( enforce_lower_bound_kernel_type (mr(i_mr), 0.0_r_def) )
      end do
    end if

    if ( subroutine_timers ) call timer("fast_physics")

  end subroutine fast_physics

end module fast_physics_alg_mod
