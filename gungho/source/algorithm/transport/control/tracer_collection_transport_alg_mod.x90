!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Contains routine for transporting a field collection of tracers.

module tracer_collection_transport_mod

  use constants_mod,                  only: r_def, i_def, l_def
  use field_mod,                      only: field_type
  use field_collection_mod,           only: field_collection_type
  use field_collection_iterator_mod,  only: field_collection_real_iterator_type
  use function_space_collection_mod,  only: function_space_collection
  use io_config_mod,                  only: subroutine_timers
  use log_mod,                        only: log_event,       &
                                            LOG_LEVEL_ERROR, &
                                            LOG_LEVEL_INFO
  use timer_mod,                      only: timer
  use transport_enumerated_types_mod, only: equation_form_advective, &
                                            equation_form_consistent
  use transport_field_mod,            only: transport_field
  use transport_metadata_mod,         only: transport_metadata_type

  implicit none

  private

  public :: tracer_collection_transport_alg

contains

  !> @brief Central routine for transporting a field collection of tracers.
  !> @details Performs a whole transport time step for a field collection of
  !!          tracers, for instance the cloud fields.
  !> @param[in,out] fields_out         Tracer field collection after transport
  !> @param[in]     fields_in          Tracer field collection before transport
  !> @param[in]     model_dt           Model timestep
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting these fields
  !> @param[in]     fields_prev        (Optional) variable that stores fields from
  !!                                   previous outer iteration
  !> @param[in]     cheap_update       (Optional) logical, true if cheap update
  !!                                   is being used
  !> @param[in]     outer              (Optional) outer iteration number

  subroutine tracer_collection_transport_alg(fields_out, fields_in, model_dt, &
                                             transport_metadata, fields_prev, &
                                             cheap_update, outer)

    implicit none

    ! Arguments
    type(field_collection_type),   intent(inout) :: fields_out
    type(field_collection_type),   intent(in)    :: fields_in
    real(kind=r_def),              intent(in)    :: model_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    type(field_collection_type),   intent(in), optional :: fields_prev
    logical(kind=l_def),           intent(in), optional :: cheap_update
    integer(kind=i_def),           intent(in), optional :: outer

    ! Iterator for field collection
    type(field_collection_real_iterator_type) :: iterator

    ! One of the single fields out of the fields_out collection
    type(field_type), pointer :: single_field_out => null()

    ! The saved version of field after slow physics
    type(field_type), pointer :: single_field_in => null()
    type(field_type), pointer :: single_field_prev => null()

    if ( subroutine_timers ) call timer('tracer collection transport')

    ! Choose form of transport equation
    select case ( transport_metadata%get_equation_form() )

    ! ------------------------------------------------------------------------ !
    ! Advective form of transport equation
    ! ------------------------------------------------------------------------ !
  case ( equation_form_advective, equation_form_consistent )

      if ( fields_in%get_length() > 0 ) then

        call iterator%initialise( fields_in )

        do
          if ( .not. iterator%has_next() ) exit

          single_field_in => iterator%next()
          call fields_out%get_field( trim(single_field_in%get_name() ), &
                                     single_field_out )

          call log_event( "Advecting "//  trim(single_field_in%get_name()), &
                           LOG_LEVEL_INFO)

          call transport_field(single_field_out, single_field_in, model_dt, &
                               transport_metadata)

          if ( present(fields_prev) .AND. present(cheap_update) .AND. present(outer) ) then
            if ( cheap_update .AND. outer > 1 ) then
              ! Add previous iteration transported field for cheap transport update
              ! On the second outer iteration we have
              ! field_prev = field_in - dt increment(field,wind_n)
              ! field_out  = field_in - dt increment(field,(wind_np1-wind_n)/2)
              ! To get
              ! field_out = field_in - dt increment(field,(wind_np1+wind_n)/2)
              ! we set
              ! field_out = field_out + field_prev - field_in
              ! This carries forward for further outer iterations
              call fields_prev%get_field( trim(single_field_in%get_name() ), &
                                            single_field_prev )
              call invoke( inc_X_plus_Y(single_field_out,single_field_prev), &
                           inc_X_minus_Y(single_field_out,single_field_in) )
            end if
          end if

        end do
      end if

    ! ---------------------------------------------------------------------- !
    ! Default form of transport equation
    ! ---------------------------------------------------------------------- !
    case default
      call log_event('Form of tracer collection transport equation either ' // &
                     'not compatible or not implemented', LOG_LEVEL_ERROR)

    end select

    if ( subroutine_timers ) call timer('tracer collection transport')

  end subroutine tracer_collection_transport_alg

end module tracer_collection_transport_mod
