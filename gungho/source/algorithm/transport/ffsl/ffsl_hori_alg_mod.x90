!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module for horizontal (2D) FFSL transport.
!> @details Contains algorithms for first and final horizontal FFSL transport
!!          steps. Also contains a control routine for 2D COSMIC splitting.
module ffsl_hori_alg_mod

  ! Constants and types
  use base_mesh_config_mod,             only: topology, topology_non_periodic
  use boundaries_config_mod,            only: limited_area, transport_boundary_depth
  use constants_mod,                    only: r_tran, i_def, l_def
  use fem_constants_mod,                only: get_inverse_w3_mass_matrix, &
                                              get_detj_at_w3_r_tran
  use field_mod,                        only: field_type
  use fs_continuity_mod,                only: W2H, W2Hbroken
  use function_space_mod,               only: function_space_type
  use function_space_collection_mod,    only: function_space_collection
  use geometric_constants_mod,          only: get_panel_id
  use integer_field_mod,                only: integer_field_type
  use limited_area_lbc_alg_mod,         only: overwrite_blending_zone_rtran
  use log_mod,                          only: log_event, LOG_LEVEL_ERROR
  use mesh_mod,                         only: mesh_type
  use operator_mod,                     only: operator_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use timer_mod,                        only: timer
  use transport_enumerated_types_mod,   only: equation_form_advective,    &
                                              equation_form_conservative, &
                                              equation_form_consistent,   &
                                              direction_h,                &
                                              splitting_strang_hvh,       &
                                              horizontal_monotone_none,   &
                                              consistent_ffsl_splitting_swift
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime
  use check_configuration_mod,          only: get_required_stencil_depth

  ! Kernels
  use break_flux_kernel_mod,            only: break_flux_kernel_type
  use consist_ffsl_flux_first_x_kernel_mod, &
                                        only: consist_ffsl_flux_first_x_kernel_type
  use consist_ffsl_flux_first_y_kernel_mod, &
                                        only: consist_ffsl_flux_first_y_kernel_type
  use consist_ffsl_flux_final_x_kernel_mod, &
                                        only: consist_ffsl_flux_final_x_kernel_type
  use consist_ffsl_flux_final_y_kernel_mod, &
                                        only: consist_ffsl_flux_final_y_kernel_type
  use ffsl_flux_first_x_kernel_mod,     only: ffsl_flux_first_x_kernel_type
  use ffsl_flux_final_x_kernel_mod,     only: ffsl_flux_final_x_kernel_type
  use ffsl_flux_first_y_kernel_mod,     only: ffsl_flux_first_y_kernel_type
  use ffsl_flux_final_y_kernel_mod,     only: ffsl_flux_final_y_kernel_type
  use ffsl_unify_flux_kernel_mod,       only: ffsl_unify_flux_kernel_type
  use fv_divergence_x_kernel_mod,       only: fv_divergence_x_kernel_type
  use fv_divergence_y_kernel_mod,       only: fv_divergence_y_kernel_type

  ! Configuration options
  use io_config_mod,                    only: subroutine_timers
  use subgrid_config_mod,               only: inner_order, outer_order
  use finite_element_config_mod,        only: element_order
  use transport_config_mod,             only: extended_mesh, dry_field_name, &
                                              special_edges_treatment

  implicit none

  private

  public  :: ffsl_hori_splitting_alg
  public  :: ffsl_hori_first_alg
  public  :: ffsl_hori_final_alg
  public  :: consistent_ffsl_hori_first_alg
  private :: ffsl_extra_points

contains

  !> @brief Algorithm to control 2D horizontal FFSL splitting.
  !> @details Solves the 2D transport equation, in advective or conservative
  !!          form, including controlling the splitting between different
  !!          dimensions. Returns an updated field for advective form and a mass
  !!          flux for conservative form (these are then passed to the generic
  !!          end_of_transport routines).
  !!          One-dimensional flux differences are denoted F and G (while
  !!          the advective differences are f and g).
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !!                                   This is only used when the equation is in
  !!                                   conservative form.
  !> @param[in,out] field_np1          The updated advected field from the time
  !!                                   step. Only used when specified through
  !!                                   the optional logical argument.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     compute_field_np1  Optional argument as to whether advected
  !!                                   field should be computed
  subroutine ffsl_hori_splitting_alg( mass_flux, field_np1, field_n,           &
                                      step_dt, transport_metadata,             &
                                      compute_field_np1 )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),         intent(inout) :: mass_flux
    type(r_tran_field_type),         intent(inout) :: field_np1
    type(r_tran_field_type),         intent(in)    :: field_n
    real(kind=r_tran),               intent(in)    :: step_dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata
    logical(kind=l_def), optional,   intent(in)    :: compute_field_np1

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(mesh_type),              pointer :: mesh => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()

    ! Transport options
    logical(kind=l_def) :: to_compute_field_np1

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'transport.ffsl_horizontal'

    ! Density substeps in given direction
    type(r_tran_field_type) :: field_x
    type(r_tran_field_type) :: field_y

    ! Field increments and fluxes in given direction
    type(r_tran_field_type) :: first_increment_x
    type(r_tran_field_type) :: first_increment_y
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y
    type(r_tran_field_type) :: flux_x
    type(r_tran_field_type) :: flux_y
    type(r_tran_field_type) :: flux_x_first
    type(r_tran_field_type) :: flux_y_first

    ! Useful constants
    real(kind=r_tran)   :: half_dt
    logical(kind=l_def) :: swift_splitting

    if ( subroutine_timers ) call timer(routine_name)

    ! Get pre-computed objects and set pointers --------------------------------
    mesh => field_n%get_mesh()

    ! Function spaces
    field_fs => field_n%get_function_space()
    w2h_fs => function_space_collection%get_fs( mesh, element_order, W2H )

    if (present(compute_field_np1)) then
      to_compute_field_np1 = compute_field_np1
    else
      to_compute_field_np1 = .true.
    end if

    swift_splitting = (transport_metadata%get_consistent_ffsl_splitting() == &
                       consistent_ffsl_splitting_swift)

    ! Initialise fields used by all splitting options --------------------------
    call field_x%initialise( vector_space = field_fs )
    call field_y%initialise( vector_space = field_fs )
    call mass_flux%initialise( vector_space = w2h_fs )

    ! Set constants
    half_dt = 0.5_r_tran * step_dt

    ! COSMIC/Lin-Rood splitting (Leonard et al. 1996, Lin and Rood 1996).
    ! It has the form
    !
    !   rho_x = rho - dt/2 * f(rho)
    !   rho_y = rho - dt/2 * g(rho)
    !
    ! Output: F(rho_y) + G(rho_x)

    ! 1st advective step -------------------------------------------------------
    if (transport_metadata%get_equation_form() == equation_form_consistent &
        .and. swift_splitting) then
      call consistent_ffsl_hori_first_alg(flux_x_first, flux_y_first,          &
                                          field_x, field_y, field_n,           &
                                          step_dt, transport_metadata,         &
                                          outer_order)
    else
      call ffsl_hori_first_alg( first_increment_x, first_increment_y, field_n, &
                                step_dt, transport_metadata )
      call invoke( X_minus_bY(field_x, field_n, half_dt, first_increment_x),   &
                   X_minus_bY(field_y, field_n, half_dt, first_increment_y) )
    end if

    ! Final step (advective or conservative) -----------------------------------
    call ffsl_hori_final_alg( flux_x, flux_y, increment_x, increment_y,        &
                              field_np1, field_n, field_x, field_y,            &
                              step_dt, transport_metadata, outer_order,        &
                              compute_adv_inc=.false.,                         &
                              compute_field_np1=to_compute_field_np1 )

    ! Compute combined mass flux, if required ----------------------------------
    if (transport_metadata%get_equation_form() == equation_form_conservative &
        .or. transport_metadata%get_equation_form() == equation_form_consistent) then
      if (transport_metadata%get_equation_form() == equation_form_consistent &
          .and. swift_splitting) then
        call invoke( aX_minus_bY(mass_flux, 0.5_r_tran, flux_x,                &
                                            0.5_r_tran, flux_y),               &
                     inc_X_plus_bY(mass_flux, 0.5_r_tran, flux_x_first),       &
                     inc_X_minus_bY(mass_flux, 0.5_r_tran, flux_y_first) )
      else
        call invoke( X_minus_Y(mass_flux, flux_x, flux_y) )
      end if
    end if

    if ( subroutine_timers ) call timer(routine_name)

    nullify( mesh, w2h_fs, field_fs )

  end subroutine ffsl_hori_splitting_alg

  !> @brief Performs the first advective step of X and Y horizontal FFSL sweeps
  !> @details Calculates the advective increment fields corresponding to X and Y
  !           transport sweeps, from a single input field.
  !> @param[in,out] increment_x        Advective increment from x-sweep.
  !> @param[in,out] increment_y        Advective increment from y-sweep.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     dt                 The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  subroutine ffsl_hori_first_alg( increment_x, increment_y, field_n, &
                                  dt, transport_metadata )

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),         intent(inout) :: increment_x
    type(r_tran_field_type),         intent(inout) :: increment_y
    type(r_tran_field_type), target, intent(in)    :: field_n
    real(kind=r_tran),               intent(in)    :: dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_x => null()
    type(r_tran_field_type),      pointer :: dep_pts_y => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(field_type),             pointer :: panel_id => null()
    type(r_tran_field_type),      pointer :: adv_one_x => null()
    type(r_tran_field_type),      pointer :: adv_one_y => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_x => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_y => null()
    type(operator_type),          pointer :: m3_inv => null()

    ! Fields and increments
    type(r_tran_field_type)         :: flux_x
    type(r_tran_field_type)         :: flux_y
    type(r_tran_field_type)         :: flux_broken
    type(r_tran_field_type)         :: conservative_field_x
    type(r_tran_field_type)         :: conservative_field_y
    type(r_tran_field_type)         :: divide_part
    type(r_tran_field_type)         :: inc_part
    type(r_tran_field_type), target :: dep_pts_x_half
    type(r_tran_field_type), target :: dep_pts_y_half

    ! Pointer to field, to avoid unnecessary setval calculation
    type(r_tran_field_type) :: field_big_halo

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2b_fs => null()

    ! Transport options
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: strang
    logical(kind=l_def) :: monotone_remap

    ! Constants
    integer(kind=i_def) :: mesh_id
    integer(kind=i_def) :: stencil_extent_x
    integer(kind=i_def) :: stencil_extent_y
    integer(kind=i_def) :: cfl_stencil_x
    integer(kind=i_def) :: cfl_stencil_y
    real(kind=r_tran)   :: one_over_dt
    integer(kind=i_def) :: extra_points
    integer(kind=i_def) :: remap_depth

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_n%get_mesh_id()
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)

    ! Get pre-computed fields
    dep_pts_x => transport_runtime%get_departure_points_x_w2(mesh_id)
    dep_pts_y => transport_runtime%get_departure_points_y_w2(mesh_id)
    detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)
    panel_id => get_panel_id(mesh_id)
    dep_stencil_extent_x => transport_runtime%get_dep_stencil_extent_x(mesh_id)
    dep_stencil_extent_y => transport_runtime%get_dep_stencil_extent_y(mesh_id)

    ! Function spaces
    w2h_fs => dep_pts_x%get_function_space()
    field_fs => field_n%get_function_space()

    ! Get options
    monotone = transport_metadata%get_horizontal_monotone()
    strang = (transport_metadata%get_splitting() == splitting_strang_hvh)

    ! Get unity transport
    if ( strang ) then
      adv_one_x => transport_runtime%get_adv_unity_half_x(mesh_id)
      adv_one_y => transport_runtime%get_adv_unity_half_y(mesh_id)
    else
      adv_one_x => transport_runtime%get_adv_unity_x(mesh_id)
      adv_one_y => transport_runtime%get_adv_unity_y(mesh_id)
    end if

    ! Halve the departure points if using Strang
    if ( strang ) then
      call dep_pts_x_half%initialise( vector_space = w2h_fs )
      call dep_pts_y_half%initialise( vector_space = w2h_fs )
      call invoke( a_times_X(dep_pts_x_half, 0.5_r_tran, dep_pts_x), &
                   a_times_X(dep_pts_y_half, 0.5_r_tran, dep_pts_y) )
      dep_pts_x => dep_pts_x_half
      dep_pts_y => dep_pts_y_half
    end if

    ! Initialise fields
    call increment_x%initialise( vector_space = field_fs )
    call increment_y%initialise( vector_space = field_fs )
    call flux_x%initialise( vector_space = w2h_fs )
    call flux_y%initialise( vector_space = w2h_fs )
    call conservative_field_x%initialise( vector_space = field_fs )
    call conservative_field_y%initialise( vector_space = field_fs )
    call inc_part%initialise( vector_space = field_fs )
    call divide_part%initialise( vector_space = field_fs )

    ! Set constant values
    extra_points = ffsl_extra_points(special_edges_treatment)
    one_over_dt = 1.0_r_tran / dt
    stencil_extent_x = dep_stencil_extent_x + extra_points + inner_order
    stencil_extent_y = dep_stencil_extent_y + extra_points + inner_order
    ! PSyclone needs these to be different variables to the stencil_extents
    cfl_stencil_x = stencil_extent_x
    cfl_stencil_y = stencil_extent_y

    ! remap the field on an extended cubed sphere, if required -----------------
    ! If needed remap the field on an extended cubed sphere
    if ( extended_mesh ) then
      monotone_remap = ( monotone /= horizontal_monotone_none )
      remap_depth = max(cfl_stencil_x, cfl_stencil_y)
      call transport_runtime%remap_on_extended_mesh(                  &
                          field_big_halo, field_n, monotone_remap,    &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value(),         &
                          remap_depth)
    else
      call field_big_halo%initialise( field_n%get_function_space(), &
                                      halo_depth = get_required_stencil_depth() )
      call invoke( setval_x(field_big_halo, field_n) )
    end if

    if ( subroutine_timers ) call timer('transport.ffsl_hori_sweeps')
    ! Compute the mass fluxes: x-direction -------------------------------------
    call invoke( setval_c(flux_x, 0.0_r_tran),                                   &
                 ffsl_flux_first_x_kernel_type(flux_x,                           &
                                               field_big_halo, stencil_extent_x, &
                                               panel_id, stencil_extent_x,       &
                                               dep_pts_x,                        &
                                               detj_at_w3, stencil_extent_x,     &
                                               inner_order, monotone,            &
                                               cfl_stencil_x, dt,                &
                                               special_edges_treatment),         &
    ! Compute the mass fluxes: y-direction -------------------------------------
                 setval_c(flux_y, 0.0_r_tran),                                   &
                 ffsl_flux_first_y_kernel_type(flux_y,                           &
                                               field_big_halo, stencil_extent_y, &
                                               panel_id, stencil_extent_y,       &
                                               dep_pts_y,                        &
                                               detj_at_w3, stencil_extent_y,     &
                                               inner_order, monotone,            &
                                               cfl_stencil_y, dt,                &
                                               special_edges_treatment) )
    if ( subroutine_timers ) call timer('transport.ffsl_hori_sweeps')

    ! fluxes may need unifying to guarantee a unique flux for each face --------
    if ( extended_mesh ) then
      if ( subroutine_timers ) call timer('transport.ffsl_flux_unify')
      w2b_fs => function_space_collection%get_fs(mesh, element_order, W2Hbroken)
      call flux_broken%initialise( w2b_fs )
      call invoke( break_flux_kernel_type(flux_broken, flux_x, flux_y),        &
                   ffsl_unify_flux_kernel_type(flux_x, flux_y, flux_broken,    &
                                               1, panel_id, 1) )
      if ( subroutine_timers ) call timer('transport.ffsl_flux_unify')
    end if

    ! Compute updated advective fields -----------------------------------------
    if ( subroutine_timers ) call timer('transport.ffsl_hori_update')
    call invoke( fv_divergence_x_kernel_type(increment_x, flux_x, m3_inv),     &
                 fv_divergence_y_kernel_type(increment_y, flux_y, m3_inv),     &
                 X_minus_bY(conservative_field_x, field_n, dt, increment_x),   &
                 X_minus_bY(conservative_field_y, field_n, dt, increment_y),   &
    ! Compute advective increments, through division by unity transport --------
    ! Following Putman and Lin, JCP, 2007:
    ! conservative_field = q - dt * F(q)
    ! adv_one   = 1 - dt * F(1)
    ! inc_part  = q - conservative_field / adv_one
    ! increment = inc_part / dt
                 X_divideby_Y(divide_part, conservative_field_x, adv_one_x),   &
                 X_minus_Y(inc_part, field_n, divide_part),                    &
                 a_times_X(increment_x, one_over_dt, inc_part),                &
                 X_divideby_Y(divide_part, conservative_field_y, adv_one_y),   &
                 X_minus_Y(inc_part, field_n, divide_part),                    &
                 a_times_X(increment_y, one_over_dt, inc_part) )
    if ( subroutine_timers ) call timer('transport.ffsl_hori_update')

    nullify(transport_runtime, mesh, dep_pts_x, dep_pts_y, detj_at_w3, &
            panel_id, adv_one_x, adv_one_y, m3_inv, field_fs,          &
            dep_stencil_extent_x, dep_stencil_extent_y, w2h_fs, w2b_fs)

  end subroutine ffsl_hori_first_alg


  !> @brief Performs the final horizontal steps of X and Y horizontal FFSL sweeps
  !> @details Calculates the advective increment fields and/or updated fields
  !!          and/or mass fluxes from 1D X and Y horizontal FFSL sweeps, in
  !!          which the inputs to the sweeps are different fields.
  !> @param[in,out] flux_x             Mass flux from x-sweep
  !> @param[in,out] flux_y             Mass flux from y-sweep
  !> @param[in,out] increment_x        Advective increment from x-sweep
  !> @param[in,out] increment_y        Advective increment from y-sweep
  !> @param[in,out] field_np1          The updated advected field from the time
  !!                                   step. Only used when specified through
  !!                                   the optional logical argument.
  !> @param[in]     field_n            Input field the start of the horizontal
  !!                                   transport step
  !> @param[in]     field_x            Input field from steps in x direction
  !> @param[in]     field_y            Input field from steps in y direction
  !> @param[in]     dt                 The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to use.
  !> @param[in]     compute_adv_inc    Optional argument as to whether advective
  !!                                   increments should be computed
  !> @param[in]     compute_field_np1  Optional argument as to whether advected
  !!                                   field should be computed
  subroutine ffsl_hori_final_alg( flux_x, flux_y, increment_x, increment_y,    &
                                  field_np1, field_n, field_x, field_y, dt,    &
                                  transport_metadata, order, compute_adv_inc,  &
                                  compute_field_np1 )

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),         intent(inout) :: increment_x
    type(r_tran_field_type),         intent(inout) :: increment_y
    type(r_tran_field_type),         intent(inout) :: flux_x
    type(r_tran_field_type),         intent(inout) :: flux_y
    type(r_tran_field_type),         intent(inout) :: field_np1
    type(r_tran_field_type), target, intent(in)    :: field_n
    type(r_tran_field_type), target, intent(in)    :: field_x
    type(r_tran_field_type), target, intent(in)    :: field_y
    real(kind=r_tran),               intent(in)    :: dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata
    integer(kind=i_def),             intent(in)    :: order
    logical(kind=l_def), optional,   intent(in)    :: compute_adv_inc
    logical(kind=l_def), optional,   intent(in)    :: compute_field_np1

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_x => null()
    type(r_tran_field_type),      pointer :: dep_pts_y => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(field_type),             pointer :: panel_id => null()
    type(r_tran_field_type),      pointer :: adv_one_x => null()
    type(r_tran_field_type),      pointer :: adv_one_y => null()
    type(r_tran_field_type),      pointer :: rho_d_x => null()
    type(r_tran_field_type),      pointer :: rho_d_y => null()
    type(r_tran_field_type),      pointer :: rho_d_n => null()
    type(r_tran_field_type),      pointer :: rho_d_np1 => null()
    type(r_tran_field_type),      pointer :: frac_flux_x => null()
    type(r_tran_field_type),      pointer :: frac_flux_y => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_x => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_y => null()
    type(operator_type),          pointer :: m3_inv => null()
    type(integer_field_type),     pointer :: cosmic_istart_x => null()
    type(integer_field_type),     pointer :: cosmic_iend_x   => null()
    type(integer_field_type),     pointer :: cosmic_istart_y => null()
    type(integer_field_type),     pointer :: cosmic_iend_y   => null()

    ! Fields and increments
    type(r_tran_field_type)         :: remap_field_x
    type(r_tran_field_type)         :: remap_field_y
    type(r_tran_field_type), target :: dep_pts_x_half
    type(r_tran_field_type), target :: dep_pts_y_half

    type(r_tran_field_type) :: flux_broken
    type(r_tran_field_type) :: conservative_field_x
    type(r_tran_field_type) :: conservative_field_y
    type(r_tran_field_type) :: conservative_field_n
    type(r_tran_field_type) :: conservative_field_np1
    type(r_tran_field_type) :: divide_part
    type(r_tran_field_type) :: inc_part_x
    type(r_tran_field_type) :: inc_part_y
    type(r_tran_field_type) :: increment

    ! Flux parts
    type(r_tran_field_type) :: flux_x_high
    type(r_tran_field_type) :: flux_x_low
    type(r_tran_field_type) :: flux_x_int
    type(r_tran_field_type) :: flux_y_high
    type(r_tran_field_type) :: flux_y_low
    type(r_tran_field_type) :: flux_y_int

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2b_fs => null()

    ! Transport options
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: strang
    logical(kind=l_def) :: monotone_remap
    integer(kind=i_def) :: equation_form
    logical(kind=l_def) :: swift_splitting

    ! Constants
    integer(kind=i_def) :: mesh_id, step
    integer(kind=i_def) :: stencil_extent_x
    integer(kind=i_def) :: stencil_extent_y
    integer(kind=i_def) :: cfl_stencil_x
    integer(kind=i_def) :: cfl_stencil_y
    integer(kind=i_def) :: remap_depth

    real(kind=r_tran)   :: one_over_dt
    real(kind=r_tran)   :: half_dt
    logical(kind=l_def) :: to_compute_adv_inc
    logical(kind=l_def) :: to_compute_field_np1
    integer(kind=i_def) :: extra_points
    logical(kind=l_def) :: outer
    logical(kind=l_def) :: is_dry_field

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_x%get_mesh_id()
    mesh => field_x%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)

    ! Get options
    monotone = transport_metadata%get_horizontal_monotone()
    strang = (transport_metadata%get_splitting() == splitting_strang_hvh)
    equation_form = transport_metadata%get_equation_form()
    swift_splitting = (transport_metadata%get_consistent_ffsl_splitting() &
                       == consistent_ffsl_splitting_swift)

    ! Get pre-computed fields
    detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)
    panel_id => get_panel_id(mesh_id)

    if (equation_form == equation_form_consistent) then
      step = transport_runtime%get_tracer_step_ctr()
      if (swift_splitting) then
        outer = .true.
        rho_d_x => transport_runtime%get_rho_d_ffsl_x(mesh_id, step)
        rho_d_y => transport_runtime%get_rho_d_ffsl_y(mesh_id, step)
      else
        ! Same density used for both steps
        outer = .false.
        rho_d_x => transport_runtime%get_rho_d(mesh_id, step)
        rho_d_y => transport_runtime%get_rho_d(mesh_id, step)
      end if
      dep_pts_x => transport_runtime%get_tracer_dep_pts_x(mesh_id, step, outer)
      dep_pts_y => transport_runtime%get_tracer_dep_pts_y(mesh_id, step, outer)
      dep_stencil_extent_x => transport_runtime%get_tracer_stencil_extent_x(mesh_id, step, outer)
      dep_stencil_extent_y => transport_runtime%get_tracer_stencil_extent_y(mesh_id, step, outer)
      frac_flux_x => transport_runtime%get_dry_frac_flux_x(mesh_id, step, outer)
      frac_flux_y => transport_runtime%get_dry_frac_flux_y(mesh_id, step, outer)
      cosmic_istart_x => transport_runtime%get_tracer_istart_x(mesh_id, step, outer)
      cosmic_iend_x => transport_runtime%get_tracer_iend_x(mesh_id, step, outer)
      cosmic_istart_y => transport_runtime%get_tracer_istart_y(mesh_id, step, outer)
      cosmic_iend_y => transport_runtime%get_tracer_iend_y(mesh_id, step, outer)
    else
      dep_pts_x => transport_runtime%get_departure_points_x_w2(mesh_id)
      dep_pts_y => transport_runtime%get_departure_points_y_w2(mesh_id)
      dep_stencil_extent_x => transport_runtime%get_dep_stencil_extent_x(mesh_id)
      dep_stencil_extent_y => transport_runtime%get_dep_stencil_extent_y(mesh_id)
      cosmic_istart_x => transport_runtime%get_cosmic_istart_x(mesh_id)
      cosmic_iend_x => transport_runtime%get_cosmic_iend_x(mesh_id)
      cosmic_istart_y => transport_runtime%get_cosmic_istart_y(mesh_id)
      cosmic_iend_y => transport_runtime%get_cosmic_iend_y(mesh_id)
    end if

    ! Function spaces
    w2h_fs => dep_pts_x%get_function_space()
    field_fs => field_x%get_function_space()

    if (present(compute_adv_inc)) then
      to_compute_adv_inc = compute_adv_inc
    else
      to_compute_adv_inc = .true.
    end if

    if (present(compute_field_np1)) then
      to_compute_field_np1 = compute_field_np1
    else
      to_compute_field_np1 = .true.
    end if

    is_dry_field = ( trim(transport_metadata%get_name()) == trim(dry_field_name) )

    ! Halve the departure points if using Strang
    ! This is not necessary for the consistent equation, as this is already
    ! taken into account in the tracer departure points
    if ( strang .and. equation_form /= equation_form_consistent) then
      call dep_pts_x_half%initialise( vector_space = w2h_fs )
      call dep_pts_y_half%initialise( vector_space = w2h_fs )
      call invoke( a_times_X(dep_pts_x_half, 0.5_r_tran, dep_pts_x), &
                   a_times_X(dep_pts_y_half, 0.5_r_tran, dep_pts_y) )
      dep_pts_x => dep_pts_x_half
      dep_pts_y => dep_pts_y_half
    end if

    ! Initialise fields --------------------------------------------------------
    call flux_x%initialise( vector_space = w2h_fs )
    call flux_y%initialise( vector_space = w2h_fs )
    call flux_x_high%initialise( vector_space = w2h_fs )
    call flux_y_high%initialise( vector_space = w2h_fs )
    call flux_x_low%initialise( vector_space = w2h_fs )
    call flux_y_low%initialise( vector_space = w2h_fs )
    call flux_x_int%initialise( vector_space = w2h_fs )
    call flux_y_int%initialise( vector_space = w2h_fs )

    ! Set constant values
    extra_points = ffsl_extra_points(special_edges_treatment)
    one_over_dt = 1.0_r_tran / dt
    stencil_extent_x = dep_stencil_extent_x + extra_points + order
    stencil_extent_y = dep_stencil_extent_y + extra_points + order


    ! PSyclone needs these to be different variables to the stencil_extents
    cfl_stencil_x = stencil_extent_x
    cfl_stencil_y = stencil_extent_y

    ! remap the field on an extended cubed sphere, if required -----------------
    ! If needed remap the field on an extended cubed sphere
    if ( extended_mesh ) then
      monotone_remap = ( monotone /= horizontal_monotone_none )
      remap_depth = max(cfl_stencil_x, cfl_stencil_y)
      call transport_runtime%remap_on_extended_mesh(                  &
                          remap_field_x, field_x, monotone_remap,     &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value(),         &
                          remap_depth)
      call transport_runtime%remap_on_extended_mesh(                  &
                          remap_field_y, field_y, monotone_remap,     &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value(),         &
                          remap_depth)
    else
      call remap_field_x%initialise( field_x%get_function_space(), &
                                     halo_depth = get_required_stencil_depth() )
      call remap_field_y%initialise( field_y%get_function_space(), &
                                     halo_depth = get_required_stencil_depth() )
      call invoke( setval_x(remap_field_x, field_x), &
                   setval_x(remap_field_y, field_y) )
    end if

    if ( subroutine_timers ) call timer('transport.ffsl_hori_sweeps')

    if (equation_form == equation_form_consistent) then

      ! Compute the mass fluxes: x-direction -----------------------------------
      call invoke( setval_c(flux_x_high, 0.0_r_tran),                          &
                   setval_c(flux_x_low, 0.0_r_tran),                           &
                   setval_c(flux_x_int, 0.0_r_tran),                           &
                   consist_ffsl_flux_final_x_kernel_type(                      &
                                              flux_x_high,                     &
                                              flux_x_low, flux_x_int,          &
                                              remap_field_x, stencil_extent_x, &
                                              remap_field_y, stencil_extent_x, &
                                              detj_at_w3, stencil_extent_x,    &
                                              rho_d_x, stencil_extent_x,       &
                                              rho_d_y, stencil_extent_x,       &
                                              panel_id, stencil_extent_x,      &
                                              cosmic_istart_y, cosmic_iend_y,  &
                                              dep_pts_x, frac_flux_x, order,   &
                                              monotone, cfl_stencil_x, dt,     &
                                              special_edges_treatment),        &
      ! Compute the mass fluxes: y-direction -----------------------------------
                   setval_c(flux_y_high, 0.0_r_tran),                          &
                   setval_c(flux_y_low, 0.0_r_tran),                           &
                   setval_c(flux_y_int, 0.0_r_tran),                           &
                   consist_ffsl_flux_final_y_kernel_type(                      &
                                              flux_y_high,                     &
                                              flux_y_low, flux_y_int,          &
                                              remap_field_x, stencil_extent_y, &
                                              remap_field_y, stencil_extent_y, &
                                              detj_at_w3, stencil_extent_y,    &
                                              rho_d_x, stencil_extent_y,       &
                                              rho_d_y, stencil_extent_y,       &
                                              panel_id, stencil_extent_y,      &
                                              cosmic_istart_x, cosmic_iend_x,  &
                                              dep_pts_y, frac_flux_y, order,   &
                                              monotone, cfl_stencil_y, dt,     &
                                              special_edges_treatment),        &
      ! Combine integer and fractional fluxes ----------------------------------
                   X_plus_Y(flux_x, flux_x_high, flux_x_int),                  &
                   ! Minus sign here to correct for FFSL having the opposite
                   ! sign for the y-direction
                   X_minus_Y(flux_y, flux_y_int, flux_y_high) )

    else  ! Conservative/advective forms of the transport equation
      ! Compute the mass fluxes: x-direction -----------------------------------
      call invoke( setval_c(flux_x_high, 0.0_r_tran),                          &
                   setval_c(flux_x_low, 0.0_r_tran),                           &
                   setval_c(flux_x_int, 0.0_r_tran),                           &
                   ffsl_flux_final_x_kernel_type(                              &
                                              flux_x_high,                     &
                                              flux_x_low, flux_x_int,          &
                                              remap_field_x, stencil_extent_x, &
                                              remap_field_y, stencil_extent_x, &
                                              panel_id, stencil_extent_x,      &
                                              cosmic_istart_y, cosmic_iend_y,  &
                                              dep_pts_x, detj_at_w3,           &
                                              stencil_extent_x, order,         &
                                              monotone, cfl_stencil_x, dt,     &
                                              special_edges_treatment),        &
      ! Compute the mass fluxes: y-direction -----------------------------------
                   setval_c(flux_y_high, 0.0_r_tran),                          &
                   setval_c(flux_y_low, 0.0_r_tran),                           &
                   setval_c(flux_y_int, 0.0_r_tran),                           &
                   ffsl_flux_final_y_kernel_type(                              &
                                              flux_y_high,                     &
                                              flux_y_low, flux_y_int,          &
                                              remap_field_x, stencil_extent_y, &
                                              remap_field_y, stencil_extent_y, &
                                              panel_id, stencil_extent_y,      &
                                              cosmic_istart_x, cosmic_iend_x,  &
                                              dep_pts_y, detj_at_w3,           &
                                              stencil_extent_y, order,         &
                                              monotone, cfl_stencil_y, dt,     &
                                              special_edges_treatment),        &
      ! Combine integer and fractional fluxes ----------------------------------
                   X_plus_Y(flux_x, flux_x_high, flux_x_int),                  &
                   X_plus_Y(flux_y, flux_y_int, flux_y_high) )
    end if
    if ( subroutine_timers ) call timer('transport.ffsl_hori_sweeps')

    ! fluxes may need unifying to guarantee a unique flux for each face --------
    if ( extended_mesh ) then
      if ( subroutine_timers ) call timer('transport.ffsl_flux_unify')
      w2b_fs => function_space_collection%get_fs(mesh, element_order, W2Hbroken)
      call flux_broken%initialise( w2b_fs )
      call invoke( break_flux_kernel_type(flux_broken, flux_x, flux_y),        &
                   ffsl_unify_flux_kernel_type(flux_x, flux_y, flux_broken,    &
                                               1, panel_id, 1) )
      if ( subroutine_timers ) call timer('transport.ffsl_flux_unify')
    end if

    ! Compute advective increments, if required --------------------------------
    if (to_compute_adv_inc .or. to_compute_field_np1 .or. is_dry_field) then
      if ( subroutine_timers ) call timer('transport.ffsl_hori_update')
      select case ( equation_form )
      case ( equation_form_conservative, equation_form_advective )
        call increment_x%initialise( vector_space = field_fs )
        call increment_y%initialise( vector_space = field_fs )
        call conservative_field_x%initialise( vector_space = field_fs )
        call conservative_field_y%initialise( vector_space = field_fs )
        call inc_part_x%initialise( vector_space = field_fs )
        call inc_part_y%initialise( vector_space = field_fs )
        call divide_part%initialise( vector_space = field_fs )

        if ( strang ) then
          adv_one_x => transport_runtime%get_adv_unity_half_x(mesh_id)
          adv_one_y => transport_runtime%get_adv_unity_half_y(mesh_id)
        else
          adv_one_x => transport_runtime%get_adv_unity_x(mesh_id)
          adv_one_y => transport_runtime%get_adv_unity_y(mesh_id)
        end if

        ! Compute updated conservative fields
        call invoke( fv_divergence_x_kernel_type(increment_x, flux_x,          &
                                                 m3_inv),                      &
                     fv_divergence_y_kernel_type(increment_y, flux_y,          &
                                                 m3_inv),                      &
                     X_minus_bY(conservative_field_x, field_y, dt,             &
                                increment_x),                                  &
                     X_minus_bY(conservative_field_y, field_x, dt,             &
                                increment_y),                                  &

        ! Following Putman and Lin, JCP, 2007:
        ! conservative_field = q - dt * F(q)
        ! adv_one   = 1 - dt * F(1)
        ! inc_part  = q - conservative_field / adv_one
        ! increment = inc_part / dt
                     X_divideby_Y(divide_part, conservative_field_x,           &
                                  adv_one_x),                                  &
                     X_minus_Y(inc_part_x, field_y, divide_part),              &
                     X_divideby_Y(divide_part, conservative_field_y,           &
                                  adv_one_y),                                  &
                     X_minus_Y(inc_part_y, field_x, divide_part) )

        ! Need to pause here to compute rho_d_ffsl that is stored for consistent transport
        if ( is_dry_field ) then
          ! Compute stored FFSL density fields by adding increments the
          ! previous conservative rho fields, and not the advective rho predictor
          step = transport_runtime%get_tracer_step_ctr()
          if (step == 1) then
            rho_d_n => field_n
          else
            rho_d_n => transport_runtime%get_rho_d(mesh_id, step)
          end if
          call invoke( X_minus_bY(conservative_field_x, rho_d_n, dt,           &
                                                                increment_x),  &
                       X_minus_bY(conservative_field_y, rho_d_n, dt,           &
                                                                increment_y) )

          if ( limited_area .and. topology == topology_non_periodic ) then
            call overwrite_blending_zone_rtran(conservative_field_x, rho_d_n, depth=transport_boundary_depth)
            call overwrite_blending_zone_rtran(conservative_field_y, rho_d_n, depth=transport_boundary_depth)
          end if

          call transport_runtime%set_rho_d_ffsl_x(conservative_field_x, step)
          call transport_runtime%set_rho_d_ffsl_y(conservative_field_y, step)
        end if

        if ( to_compute_adv_inc ) then
          call invoke( a_times_X(increment_x, one_over_dt, inc_part_x),        &
                       a_times_X(increment_y, one_over_dt, inc_part_y) )
        end if

        if ( to_compute_field_np1 ) then
          call invoke( X_minus_Y(field_np1, field_n, inc_part_x),              &
                       inc_X_minus_Y(field_np1, inc_part_y) )
        end if

      case ( equation_form_consistent )
        step = transport_runtime%get_tracer_step_ctr()
        rho_d_np1 => transport_runtime%get_rho_d(mesh_id, step+1)
        half_dt = 0.5_r_tran*dt
        call conservative_field_np1%initialise( vector_space = field_fs )
        call conservative_field_n%initialise( vector_space = field_fs )
        call increment%initialise( vector_space = field_fs )
        call increment_x%initialise( vector_space = field_fs )
        call increment_y%initialise( vector_space = field_fs )

        if (swift_splitting) then
          call conservative_field_x%initialise( vector_space = field_fs )
          call conservative_field_y%initialise( vector_space = field_fs )

          call invoke( X_times_Y(conservative_field_x, field_x, rho_d_x),      &
                       X_times_Y(conservative_field_y, field_y, rho_d_y),      &
                       aX_plus_bY(conservative_field_n,                        &
                                            0.5_r_tran, conservative_field_x,  &
                                            0.5_r_tran, conservative_field_y), &
                       ! Calculate increment to tracer density
                       fv_divergence_x_kernel_type(increment_x, flux_x,        &
                                                                      m3_inv), &
                       fv_divergence_y_kernel_type(increment_y, flux_y,        &
                                                                      m3_inv), &
                       X_plus_Y(increment, increment_x, increment_y),          &
                       X_minus_bY(conservative_field_np1,                      &
                                  conservative_field_n, half_dt, increment),   &
                       ! Obtain updated mixing ratio by dividing by updated density
                       X_divideby_Y(field_np1, conservative_field_np1,         &
                                    rho_d_np1) )
        else

          ! Multiply tracer mixing ratio by dry density to get tracer density
          rho_d_n => transport_runtime%get_rho_d(mesh_id, step)

          call invoke( X_times_Y(conservative_field_n, field_n, rho_d_n),      &
                       ! Calculate increment to tracer density
                       fv_divergence_x_kernel_type(increment_x, flux_x,        &
                                                                      m3_inv), &
                       fv_divergence_y_kernel_type(increment_y, flux_y,        &
                                                                      m3_inv), &
                       X_plus_Y(increment, increment_x, increment_y),          &
                       X_minus_bY(conservative_field_np1,                      &
                                  conservative_field_n, dt, increment),        &
                       ! Obtain updated mixing ratio by dividing by updated density
                       X_divideby_Y(field_np1, conservative_field_np1,         &
                                    rho_d_np1) )
        end if

        if ( to_compute_adv_inc ) then
          call log_event('Computation of advective increments for final ' // &
                         'horizontal step of consistent FFSL is not ' //     &
                         'implemented', LOG_LEVEL_ERROR)
        end if

      case default
        call log_event( "ffsl_hori_final_alg: Unrecognized equation form", LOG_LEVEL_ERROR )

      end select
      if ( subroutine_timers ) call timer('transport.ffsl_hori_update')
    end if

    nullify(transport_runtime, mesh, dep_pts_x, dep_pts_y, detj_at_w3,      &
            panel_id, adv_one_x, adv_one_y, m3_inv,                         &
            cosmic_istart_x, cosmic_istart_y, cosmic_iend_x, cosmic_iend_y, &
            dep_stencil_extent_x, dep_stencil_extent_y, field_fs, w2h_fs,   &
            rho_d_n, w2b_fs)

  end subroutine ffsl_hori_final_alg

  !> @brief The first horizontal sweeps for consistent FFSL with Swift splitting
  !> @details Calculates the mass fluxes and updated mixing ratio fields from
  !!          1D X and Y horizontal consistent FFSL sweeps,.
  !> @param[in,out] flux_x             Mass flux from x-sweep
  !> @param[in,out] flux_y             Mass flux from y-sweep
  !> @param[in,out] field_x            Updated mixing ratio field from x-sweep
  !> @param[in,out] field_y            Updated mixing ratio field from y-sweep
  !> @param[in]     field_n            Input field the start of the horizontal
  !!                                   transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to use.
  subroutine consistent_ffsl_hori_first_alg( flux_x, flux_y, field_x, field_y, &
                                             field_n, step_dt,                 &
                                             transport_metadata, order )

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),         intent(inout) :: field_x
    type(r_tran_field_type),         intent(inout) :: field_y
    type(r_tran_field_type),         intent(inout) :: flux_x
    type(r_tran_field_type),         intent(inout) :: flux_y
    type(r_tran_field_type), target, intent(in)    :: field_n
    real(kind=r_tran),               intent(in)    :: step_dt
    type(transport_metadata_type),   intent(in)    :: transport_metadata
    integer(kind=i_def),             intent(in)    :: order

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_x => null()
    type(r_tran_field_type),      pointer :: dep_pts_y => null()
    type(r_tran_field_type),      pointer :: detj_at_w3 => null()
    type(r_tran_field_type),      pointer :: frac_flux_x => null()
    type(r_tran_field_type),      pointer :: frac_flux_y => null()
    type(r_tran_field_type),      pointer :: rho_d_n => null()
    type(r_tran_field_type),      pointer :: rho_d_x => null()
    type(r_tran_field_type),      pointer :: rho_d_y => null()
    type(field_type),             pointer :: panel_id => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_x => null()
    integer(kind=i_def),          pointer :: dep_stencil_extent_y => null()
    type(operator_type),          pointer :: m3_inv => null()

    ! Fields and increments
    type(r_tran_field_type) :: field_big_halo

    type(r_tran_field_type) :: flux_broken
    type(r_tran_field_type) :: conservative_field_x
    type(r_tran_field_type) :: conservative_field_y
    type(r_tran_field_type) :: conservative_field_n
    type(r_tran_field_type) :: increment_x
    type(r_tran_field_type) :: increment_y

    ! Flux parts
    type(r_tran_field_type) :: flux_x_high
    type(r_tran_field_type) :: flux_x_low
    type(r_tran_field_type) :: flux_x_int
    type(r_tran_field_type) :: flux_y_high
    type(r_tran_field_type) :: flux_y_low
    type(r_tran_field_type) :: flux_y_int

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()
    type(function_space_type), pointer :: w2b_fs => null()

    ! Transport options
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: monotone_remap

    ! Constants
    integer(kind=i_def) :: mesh_id, step
    integer(kind=i_def) :: stencil_extent_x
    integer(kind=i_def) :: stencil_extent_y
    integer(kind=i_def) :: cfl_stencil_x
    integer(kind=i_def) :: cfl_stencil_y
    integer(kind=i_def) :: extra_points
    integer(kind=i_def) :: remap_depth

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_x%get_mesh_id()
    mesh => field_x%get_mesh()
    transport_runtime => get_transport_runtime(mesh)
    m3_inv => get_inverse_w3_mass_matrix(mesh_id)

    ! Get options
    monotone = transport_metadata%get_horizontal_monotone()

    step = transport_runtime%get_tracer_step_ctr()
    detj_at_w3 => get_detj_at_w3_r_tran(mesh_id)
    rho_d_n => transport_runtime%get_rho_d(mesh_id, step)
    rho_d_x => transport_runtime%get_rho_d_ffsl_x(mesh_id, step)
    rho_d_y => transport_runtime%get_rho_d_ffsl_y(mesh_id, step)
    dep_pts_x => transport_runtime%get_tracer_dep_pts_x(mesh_id, step, outer_step=.false.)
    dep_pts_y => transport_runtime%get_tracer_dep_pts_y(mesh_id, step, outer_step=.false.)
    dep_stencil_extent_x => transport_runtime%get_tracer_stencil_extent_x(mesh_id, step, outer_step=.false.)
    dep_stencil_extent_y => transport_runtime%get_tracer_stencil_extent_y(mesh_id, step, outer_step=.false.)
    frac_flux_x => transport_runtime%get_dry_frac_flux_x(mesh_id, step, outer_step=.false.)
    frac_flux_y => transport_runtime%get_dry_frac_flux_y(mesh_id, step, outer_step=.false.)
    panel_id => get_panel_id(mesh_id)

    ! Function spaces
    w2h_fs => dep_pts_x%get_function_space()
    field_fs => field_x%get_function_space()

    ! Initialise fields --------------------------------------------------------
    call flux_x%initialise( vector_space = w2h_fs )
    call flux_y%initialise( vector_space = w2h_fs )
    call flux_x_high%initialise( vector_space = w2h_fs )
    call flux_y_high%initialise( vector_space = w2h_fs )
    call flux_x_low%initialise( vector_space = w2h_fs )
    call flux_y_low%initialise( vector_space = w2h_fs )
    call flux_x_int%initialise( vector_space = w2h_fs )
    call flux_y_int%initialise( vector_space = w2h_fs )
    call conservative_field_n%initialise( vector_space = field_fs )
    call conservative_field_x%initialise( vector_space = field_fs )
    call conservative_field_y%initialise( vector_space = field_fs )
    call increment_x%initialise( vector_space = field_fs )
    call increment_y%initialise( vector_space = field_fs )

    ! Set constant values
    extra_points = ffsl_extra_points(special_edges_treatment)
    stencil_extent_x = dep_stencil_extent_x + extra_points + order
    stencil_extent_y = dep_stencil_extent_y + extra_points + order
    ! PSyclone needs these to be different variables to the stencil_extents
    cfl_stencil_x = stencil_extent_x
    cfl_stencil_y = stencil_extent_y

    ! remap the field on an extended cubed sphere, if required -----------------
    ! If needed remap the field on an extended cubed sphere
    if ( extended_mesh ) then
      monotone_remap = ( monotone /= horizontal_monotone_none )
      remap_depth = max( cfl_stencil_x, cfl_stencil_y )
      call transport_runtime%remap_on_extended_mesh(                  &
                          field_big_halo, field_n, monotone_remap,    &
                          transport_metadata%get_enforce_min_value(), &
                          transport_metadata%get_min_value(),         &
                          remap_depth)
    else
      call field_big_halo%initialise( field_n%get_function_space(), &
                                      halo_depth = get_required_stencil_depth() )
      call invoke( setval_x(field_big_halo, field_n) )
    end if

    ! Compute the mass fluxes: x-direction -------------------------------------
    if ( subroutine_timers ) call timer('transport.ffsl_hori_sweeps')
    call invoke( setval_c(flux_x_high, 0.0_r_tran),                            &
                 setval_c(flux_x_low, 0.0_r_tran),                             &
                 setval_c(flux_x_int, 0.0_r_tran),                             &
                 consist_ffsl_flux_first_x_kernel_type(                        &
                                            flux_x_high,                       &
                                            flux_x_low, flux_x_int,            &
                                            field_big_halo, stencil_extent_x,  &
                                            detj_at_w3, stencil_extent_x,      &
                                            rho_d_n, stencil_extent_x,         &
                                            panel_id, stencil_extent_x,        &
                                            dep_pts_x, frac_flux_x, order,     &
                                            monotone, cfl_stencil_x, step_dt,  &
                                            special_edges_treatment),          &
    ! Compute the mass fluxes: y-direction -------------------------------------
                 setval_c(flux_y_high, 0.0_r_tran),                            &
                 setval_c(flux_y_low, 0.0_r_tran),                             &
                 setval_c(flux_y_int, 0.0_r_tran),                             &
                 consist_ffsl_flux_first_y_kernel_type(                        &
                                            flux_y_high,                       &
                                            flux_y_low, flux_y_int,            &
                                            field_big_halo, stencil_extent_y,  &
                                            detj_at_w3, stencil_extent_y,      &
                                            rho_d_n, stencil_extent_y,         &
                                            panel_id, stencil_extent_y,        &
                                            dep_pts_y, frac_flux_y, order,     &
                                            monotone, cfl_stencil_y, step_dt,  &
                                            special_edges_treatment),          &
    ! Combine integer and fractional fluxes ------------------------------------
                  X_plus_Y(flux_x, flux_x_high, flux_x_int),                   &
                  ! Minus sign here to correct for FFSL having the opposite
                  ! sign for the y-direction
                  X_minus_Y(flux_y, flux_y_int, flux_y_high) )
    if ( subroutine_timers ) call timer('transport.ffsl_hori_sweeps')

    ! fluxes may need unifying to guarantee a unique flux for each face --------
    if ( extended_mesh ) then
      if ( subroutine_timers ) call timer('transport.ffsl_flux_unify')
      w2b_fs => function_space_collection%get_fs(mesh, element_order, W2Hbroken)
      call flux_broken%initialise( w2b_fs )
      call invoke( break_flux_kernel_type(flux_broken, flux_x, flux_y),        &
                   ffsl_unify_flux_kernel_type(flux_x, flux_y, flux_broken,    &
                                               1, panel_id, 1) )
      if ( subroutine_timers ) call timer('transport.ffsl_flux_unify')
    end if

    ! Compute advected fields
    if ( subroutine_timers ) call timer('transport.ffsl_hori_update')
    call invoke( X_times_Y(conservative_field_n, field_n, rho_d_n),            &
                 fv_divergence_x_kernel_type(increment_x, flux_x, m3_inv),     &
                 fv_divergence_y_kernel_type(increment_y, flux_y, m3_inv),     &
                 X_minus_bY(conservative_field_x, conservative_field_n,        &
                                                        step_dt, increment_x), &
                 X_minus_bY(conservative_field_y, conservative_field_n,        &
                                                        step_dt, increment_y), &
                 X_divideby_Y(field_x, conservative_field_x, rho_d_x),         &
                 X_divideby_Y(field_y, conservative_field_y, rho_d_y) )

    if ( subroutine_timers ) call timer('transport.ffsl_hori_update')

    nullify(transport_runtime, mesh, dep_pts_x, dep_pts_y, detj_at_w3, &
            panel_id, m3_inv,  rho_d_n, rho_d_x, rho_d_y, w2b_fs,      &
            dep_stencil_extent_x, dep_stencil_extent_y, field_fs, w2h_fs)

  end subroutine consistent_ffsl_hori_first_alg

  !----------------------------------------------------------------------------
  !> @brief  Returns the number of extra points required for ffsl stencil
  !! @param[in]   special_edges_treatment    Logical special_edges_treatment=T/F
  !! @return      extra_points               The number of extra points required
  !----------------------------------------------------------------------------
  function ffsl_extra_points(special_edges_treatment) result(extra_points)

   implicit none

   logical(kind=l_def), intent(in) :: special_edges_treatment
   integer(kind=i_def)             :: extra_points

   if ( special_edges_treatment ) then
       extra_points = 2_i_def
    else
       extra_points = 1_i_def
   end if
  end function ffsl_extra_points

end module ffsl_hori_alg_mod
