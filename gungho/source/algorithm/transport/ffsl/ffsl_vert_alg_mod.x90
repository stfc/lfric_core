!-----------------------------------------------------------------------------
! (C) Crown copyright 2023 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module for controlling 1D vertical FFSL steps.
!> @details Solves the 1D transport equation using the flux-form semi-Lagrangian
!!         (FFSL) transport scheme for vertical transport.
module ffsl_vert_alg_mod

  ! Constants and types
  use constants_mod,                    only: r_tran, i_def, l_def
  use fem_constants_mod,                only: get_inverse_w3_mass_matrix
  use field_mod,                        only: field_type
  use fs_continuity_mod,                only: W2V
  use function_space_mod,               only: function_space_type
  use function_space_collection_mod,    only: function_space_collection
  use geometric_constants_mod,          only: get_dz_w3
  use mesh_mod,                         only: mesh_type
  use operator_mod,                     only: operator_type
  use r_tran_field_mod,                 only: r_tran_field_type
  use timer_mod,                        only: timer
  use transport_enumerated_types_mod,   only: equation_form_advective,    &
                                              equation_form_conservative, &
                                              equation_form_consistent,   &
                                              splitting_strang_vhv,       &
                                              direction_v,                &
                                              vertical_monotone_none,     &
                                              vertical_monotone_strict,   &
                                              vertical_monotone_relaxed
  use transport_metadata_mod,           only: transport_metadata_type
  use transport_runtime_alg_mod,        only: transport_runtime_type
  use transport_runtime_collection_mod, only: get_transport_runtime

  ! Kernels
  use fv_divergence_z_kernel_mod,       only: fv_divergence_z_kernel_type
  use vert_int_low_kernel_mod,          only: vert_int_low_kernel_type
  use vert_nirvana_kernel_mod,          only: vert_nirvana_kernel_type
  use vert_nirvana_strict_kernel_mod,   only: vert_nirvana_strict_kernel_type
  use vert_nirvana_relax_kernel_mod,    only: vert_nirvana_relax_kernel_type
  use vert_nirvana_reversible_kernel_mod, &
                                        only: vert_nirvana_reversible_kernel_type
  use vert_nirvana_reversible_strict_kernel_mod, &
                                        only: vert_nirvana_reversible_strict_kernel_type
  use vert_nirvana_reversible_relax_kernel_mod, &
                                        only: vert_nirvana_reversible_relax_kernel_type
  use vert_ppm_limiter_kernel_mod,      only: vert_ppm_limiter_kernel_type
  use vert_ppm_no_limiter_kernel_mod,   only: vert_ppm_no_limiter_kernel_type
  use vert_ppm_strict_limiter_kernel_mod, &
                                        only: vert_ppm_strict_limiter_kernel_type

  ! Configuration options
  use io_config_mod,                    only: subroutine_timers
  use finite_element_config_mod,        only: element_order

  ! PSyKAl-lite code
  use psykal_lite_mod,                  only: invoke_copy_to_rtran

  implicit none

  private

  public :: ffsl_vert_transport_alg
  public :: ffsl_1d_vert_flux_alg

contains


  !> @brief Algorithm for a step of 1D vertical FFSL transport.
  !> @details Solves the 1D transport equation, in either advective or
  !!          conservative form. If needed, the mass flux or field increment
  !!          will be returned.
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !> @param[in,out] increment          Increment for the field change over the
  !!                                   time step (per unit time). Only used when
  !!                                   specified through the optional argument
  !> @param[in,out] field_np1          The updated advected field from the time
  !!                                   step. Only used when specified through
  !!                                   the optional logical argument.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to pass to
  !!                                   the underlying vertical flux algorithm
  !> @param[in]     compute_adv_inc    Optional argument as to whether advective
  !!                                   increment should be computed
  !> @param[in]     compute_field_np1  Optional argument as to whether advected
  !!                                   field should be computed
  subroutine ffsl_vert_transport_alg( mass_flux, increment,               &
                                      field_np1, field_n,                 &
                                      step_dt, transport_metadata, order, &
                                      compute_adv_inc, compute_field_np1 )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(inout) :: increment
    type(r_tran_field_type),       intent(inout) :: field_np1
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    integer(kind=i_def),           intent(in)    :: order
    logical(kind=l_def), optional, intent(in)    :: compute_adv_inc
    logical(kind=l_def), optional, intent(in)    :: compute_field_np1

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: adv_one => null()
    type(operator_type),          pointer :: m3_inv => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()

    ! Transport options
    logical(kind=l_def) :: to_compute_adv_inc
    logical(kind=l_def) :: to_compute_field_np1

    ! Subroutine name for timer
    character(*), parameter :: routine_name = 'ffsl_vert_transport_alg'

    type(r_tran_field_type) :: conservative_field_np1
    type(r_tran_field_type) :: divide_part
    type(r_tran_field_type) :: inc_part

    ! Useful constants
    integer(kind=i_def) :: mesh_id
    real(kind=r_tran)   :: one_over_dt

    if ( subroutine_timers ) call timer(routine_name)

    if (present(compute_adv_inc)) then
      to_compute_adv_inc = compute_adv_inc
    else
      to_compute_adv_inc = .true.
    end if

    if (present(compute_field_np1)) then
      to_compute_field_np1 = compute_field_np1
    else
      to_compute_field_np1 = .true.
    end if

    ! Vertical FFSL ------------------------------------------------------------
    call ffsl_1d_vert_flux_alg( mass_flux, field_n, step_dt, &
                                transport_metadata, order )

    ! Compute advected field, if required --------------------------------------
    if (to_compute_adv_inc .or. to_compute_field_np1) then
      ! Get pre-computed objects
      mesh_id = field_n%get_mesh_id()
      mesh => field_n%get_mesh()
      transport_runtime => get_transport_runtime(mesh)
      field_fs => field_n%get_function_space()
      m3_inv => get_inverse_w3_mass_matrix(mesh_id)

      one_over_dt = 1.0_r_tran / step_dt

      call increment%initialise( vector_space = field_fs )
      call conservative_field_np1%initialise( vector_space = field_fs )
      call inc_part%initialise( vector_space = field_fs )
      call divide_part%initialise( vector_space = field_fs )

      ! Get unity transport
      if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
        adv_one => transport_runtime%get_adv_unity_half_z(mesh_id)
      else
        adv_one => transport_runtime%get_adv_unity_z(mesh_id)
      end if

      call invoke( fv_divergence_z_kernel_type(increment, mass_flux,           &
                                                m3_inv),                       &
                   X_minus_bY(conservative_field_np1, field_n,                 &
                              step_dt, increment),                             &

      ! Get the advective increment from these conservative increments
      ! conservative_field_np1 = q - dt * F(q)
      ! adv_one   = 1 - dt * F(1)
      ! inc_part  = q - conservative_field_np1 / adv_one
      ! increment = inc_part / dt
                   X_divideby_Y(divide_part, conservative_field_np1,           &
                                adv_one),                                      &
                   X_minus_Y(inc_part, field_n, divide_part) )

      if (to_compute_adv_inc) call invoke( a_times_X(increment, one_over_dt, inc_part) )
      if (to_compute_field_np1) call invoke( X_minus_Y(field_np1, field_n, inc_part) )
    end if

    nullify( mesh, transport_runtime, field_fs, adv_one, m3_inv )

    if ( subroutine_timers ) call timer(routine_name)

  end subroutine ffsl_vert_transport_alg

  !----------------------------------------------------------------------------
  !> @brief   Computes the mass flux associated with a vertical FFSL step.
  !> @details Performs a conservative flux calculation using vertical FFSL.
  !> @param[in,out] mass_flux          Mass flux used to transport the field.
  !> @param[in]     field_n            Field at the start of the transport step
  !> @param[in]     step_dt            The dt for this time step
  !> @param[in]     transport_metadata Contains the configuration options for
  !!                                   transporting this field
  !> @param[in]     order              The reconstruction order to use
  subroutine ffsl_1d_vert_flux_alg( mass_flux, field_n, step_dt, &
                                    transport_metadata, order )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type),       intent(inout) :: mass_flux
    type(r_tran_field_type),       intent(in)    :: field_n
    real(kind=r_tran),             intent(in)    :: step_dt
    type(transport_metadata_type), intent(in)    :: transport_metadata
    integer(kind=i_def),           intent(in)    :: order

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(transport_runtime_type), pointer :: transport_runtime => null()
    type(mesh_type),              pointer :: mesh => null()
    type(r_tran_field_type),      pointer :: dep_pts_z_ptr => null()
    type(r_tran_field_type),      pointer :: frac_wind   => null()
    type(r_tran_field_type),      pointer :: detj_at_w2v => null()
    type(field_type),             pointer :: dz_w3_rdef => null()

    ! Function spaces
    type(function_space_type), pointer :: dep_fs_v => null()
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    ! Transport options
    logical(kind=l_def) :: log_space
    integer(kind=i_def) :: monotone
    logical(kind=l_def) :: reversible
    logical(kind=l_def) :: strang_vhv

    ! Internal fields
    type(r_tran_field_type) :: dep_pts_z
    type(r_tran_field_type) :: dz_w3
    type(r_tran_field_type) :: mass_flux_low
    type(r_tran_field_type) :: mass_flux_high
    type(r_tran_field_type) :: mass_flux_int

    ! Useful constants
    integer(kind=i_def) :: mesh_id

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = field_n%get_mesh_id()
    mesh => field_n%get_mesh()
    transport_runtime => get_transport_runtime(mesh)

    ! Determine if VHV splitting for departure points
    if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
      strang_vhv = .true.
    else
      strang_vhv = .false.
    end if

    ! Get pre-computed fields
    dep_pts_z_ptr => transport_runtime%get_departure_points_z_w2(mesh_id, strang_vhv)
    detj_at_w2v => transport_runtime%get_detj_at_w2_transport(mesh_id, direction_v)
    dz_w3_rdef => get_dz_w3(mesh_id)

    ! Function spaces
    dep_fs_v => dep_pts_z_ptr%get_function_space()
    field_fs => field_n%get_function_space()
    w2v_fs => function_space_collection%get_fs( mesh, element_order, W2V )

    ! Get options
    monotone = transport_metadata%get_vertical_monotone()
    log_space = transport_metadata%get_log_space()
    reversible = transport_metadata%get_reversible()

    ! Initialise fields used by all splitting options --------------------------
    call mass_flux%initialise( vector_space = w2v_fs )
    call mass_flux_low%initialise( vector_space = w2v_fs )
    call mass_flux_high%initialise( vector_space = w2v_fs )
    call mass_flux_int%initialise( vector_space = w2v_fs )
    call dz_w3%initialise( vector_space = field_fs )
    call dep_pts_z%initialise( vector_space = dep_fs_v )

    ! Get the correct fractional wind
    if ( transport_metadata%get_splitting() ==  splitting_strang_vhv ) then
      frac_wind => transport_runtime%get_frac_wind_z_half(mesh_id)
    else
      frac_wind => transport_runtime%get_frac_wind_z(mesh_id)
    end if

    ! Set vertical departure points
    call invoke( setval_X(dep_pts_z, dep_pts_z_ptr) )

    ! Initialise variables
    call invoke( setval_c(mass_flux, 0.0_r_tran) )
    call invoke_copy_to_rtran(dz_w3, dz_w3_rdef)

    ! Compute low order and integer fluxes -----------------------------------
    call invoke(vert_int_low_kernel_type(mass_flux_low,  &
                                         mass_flux_int,  &
                                         frac_wind,      &
                                         dep_pts_z,      &
                                         detj_at_w2v,    &
                                         field_n,        &
                                         dz_w3,          &
                                         step_dt) )

    ! Compute high order fractional flux -------------------------------------
    if (order == 0) then
      ! Reuse low order flux
      call invoke( setval_X(mass_flux_high, mass_flux_low) )
    else if (order == 1) then
      if (reversible) then
        ! Reversible Nirvana reconstruction
        if ( monotone == vertical_monotone_none) then
          call invoke( vert_nirvana_reversible_kernel_type(mass_flux_high,       &
                                                           frac_wind,            &
                                                           dep_pts_z, field_n,   &
                                                           dz_w3, log_space) )
        else if ( monotone == vertical_monotone_strict ) then
          call invoke( vert_nirvana_reversible_strict_kernel_type(               &
                                                           mass_flux_high,       &
                                                           frac_wind,            &
                                                           dep_pts_z, field_n,   &
                                                           dz_w3, log_space) )
        else
          call invoke( vert_nirvana_reversible_relax_kernel_type(                &
                                                           mass_flux_high,       &
                                                           frac_wind,            &
                                                           dep_pts_z, field_n,   &
                                                           dz_w3, log_space) )
        end if
      else
        ! Standard Nirvana reconstruction
        if ( monotone == vertical_monotone_none) then
          call invoke( vert_nirvana_kernel_type(mass_flux_high, &
                                                frac_wind,      &
                                                dep_pts_z,      &
                                                field_n, dz_w3) )
        else if ( monotone == vertical_monotone_strict ) then
          call invoke( vert_nirvana_strict_kernel_type(         &
                                                mass_flux_high, &
                                                frac_wind,      &
                                                dep_pts_z,      &
                                                field_n, dz_w3) )
        else
          call invoke( vert_nirvana_relax_kernel_type(          &
                                                mass_flux_high, &
                                                frac_wind,      &
                                                dep_pts_z,      &
                                                field_n, dz_w3) )
        end if
      end if
    else
      if ( monotone == vertical_monotone_none) then
          ! Unlimited PPM
          call invoke( vert_ppm_no_limiter_kernel_type(mass_flux_high,     &
                                                       frac_wind,          &
                                                       dep_pts_z, field_n, &
                                                       dz_w3, log_space) )
      else if ( monotone == vertical_monotone_strict ) then
          ! Strict monotone PPM
          call invoke( vert_ppm_strict_limiter_kernel_type(                &
                                                       mass_flux_high,     &
                                                       frac_wind,          &
                                                       dep_pts_z, field_n, &
                                                       dz_w3, log_space) )
      else
          ! Relaxed monotone PPM
          call invoke( vert_ppm_limiter_kernel_type( mass_flux_high,       &
                                                     frac_wind,            &
                                                     dep_pts_z, field_n,   &
                                                     dz_w3, log_space) )
      end if
    end if

    ! Combine integer and fractional fluxes
    call invoke( X_plus_Y(mass_flux, mass_flux_high, mass_flux_int) )

    nullify( dep_pts_z_ptr, detj_at_w2v, field_fs, dep_fs_v, w2v_fs,           &
             dz_w3_rdef, frac_wind, transport_runtime, mesh )

  end subroutine ffsl_1d_vert_flux_alg

end module ffsl_vert_alg_mod
