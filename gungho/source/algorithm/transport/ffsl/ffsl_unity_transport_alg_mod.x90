!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief   Computes the transport of a unity field for use in advective form
!!          FFSL transport.
!> @details For FFSL, the advective increment f(q) is calculated using the
!!          flux F(q) following Putman and Lin, JCP, 2007. As
!!          \f$q - dt f (q)  = (q - dt F(q)) / (1 - dt F(1))\f$
!!          therefore the conservative increment of a constant, F(1), is
!!          required. This algorithm computes such an increment and outputs
!!          1 - dt F(1), where 1 is the unity field.
!!          A circular dependency will be created if this algorithm uses other
!!          FFSL algorithms (as this algorithm is called by transport_runtime,
!!          which is called by the other algorithms). Therefore this algorithm
!!          directly calls the FFSL kernels.
module ffsl_unity_transport_alg_mod

  use check_configuration_mod,          only: check_horz_dep_pts, &
                                              check_vert_dep_pts, &
                                              check_any_splitting_vhv
  use constants_mod,                    only: r_tran, i_def, l_def
  use fem_constants_mod,                only: get_inverse_w3_mass_matrix
  use ffsl_flux_first_x_kernel_mod,     only: ffsl_flux_first_x_kernel_type
  use ffsl_flux_first_y_kernel_mod,     only: ffsl_flux_first_y_kernel_type
  use ffsl_vert_constant_flux_kernel_mod, &
                                        only: ffsl_vert_constant_flux_kernel_type
  use field_mod,                        only: field_type
  use flux_direction_mod,               only: x_direction, y_direction
  use function_space_mod,               only: function_space_type
  use fv_divergence_x_kernel_mod,       only: fv_divergence_x_kernel_type
  use fv_divergence_y_kernel_mod,       only: fv_divergence_y_kernel_type
  use fv_divergence_z_kernel_mod,       only: fv_divergence_z_kernel_type
  use geometric_constants_mod,          only: get_panel_id, get_dz_w3
  use operator_mod,                     only: operator_type
  use psykal_lite_mod,                  only: invoke_copy_to_rtran
  use r_tran_field_mod,                 only: r_tran_field_type
  use transport_enumerated_types_mod,   only: horizontal_monotone_none, &
                                              vertical_monotone_none


  implicit none

  private

  public :: ffsl_unity_transport_alg
  public :: ffsl_vert_unity_transport_alg

contains


  !===========================================================================!
  !> @brief   Algorithm to calculate the FFSL transport of a unity field.
  !> @details The algorithm calculates the conservative transport of unity using
  !!          the FFSL scheme. This is required for advective form FFSL transport.
  !!          The unity transport is performed using half departure points if
  !!          any of the schemes use Strang splitting.
  !!
  !> @param[in]     dep_pts_x         Departure points in x
  !> @param[in]     dep_pts_y         Departure points in y
  !> @param[in]     dep_pts_z         Departure points in z
  !> @param[in]     dep_pts_z_half    Departure points in z with dt/2
  !> @param[in]     detj_at_w2h       Det(J) at W2H dofs
  !> @param[in]     detj_at_w2v       Det(J) at W2V dofs
  !> @param[in]     dep_stencil_x     Stencil extent due to departure points in x
  !> @param[in]     dep_stencil_y     Stencil extent due to departure points in y
  !> @param[in]     dt                The model timestep length
  !> @param[in,out] np1_x             Conservative transport of unity in x
  !> @param[in,out] np1_y             Conservative transport of unity in y
  !> @param[in,out] np1_z             Conservative transport of unity in z
  !> @param[in,out] np1_half_x        Conservative transport of unity in x
  !!                                  using half dt for Strang HVH splitting
  !> @param[in,out] np1_half_y        Conservative transport of unity in y
  !!                                  using half dt for Strang HVH splitting
  !> @param[in,out] np1_half_z        Conservative transport of unity in z
  !!                                  using half dt for Strang VHV splitting
  subroutine ffsl_unity_transport_alg( dep_pts_x,      &
                                       dep_pts_y,      &
                                       dep_pts_z,      &
                                       dep_pts_z_half, &
                                       detj_at_w2h,    &
                                       detj_at_w2v,    &
                                       dep_stencil_x,  &
                                       dep_stencil_y,  &
                                       dt,             &
                                       np1_x,          &
                                       np1_y,          &
                                       np1_z,          &
                                       np1_half_x,     &
                                       np1_half_y,     &
                                       np1_half_z )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type), intent(in)    :: dep_pts_x
    type(r_tran_field_type), intent(in)    :: dep_pts_y
    type(r_tran_field_type), intent(in)    :: dep_pts_z
    type(r_tran_field_type), intent(in)    :: dep_pts_z_half
    type(r_tran_field_type), intent(in)    :: detj_at_w2h
    type(r_tran_field_type), intent(in)    :: detj_at_w2v
    integer(kind=i_def),     intent(in)    :: dep_stencil_x
    integer(kind=i_def),     intent(in)    :: dep_stencil_y
    real(kind=r_tran),       intent(in)    :: dt
    type(r_tran_field_type), intent(inout) :: np1_x
    type(r_tran_field_type), intent(inout) :: np1_y
    type(r_tran_field_type), intent(inout) :: np1_z
    type(r_tran_field_type), intent(inout) :: np1_half_x
    type(r_tran_field_type), intent(inout) :: np1_half_y
    type(r_tran_field_type), intent(inout) :: np1_half_z

    ! Internal variables -------------------------------------------------------
    ! Pointers to existing objects
    type(field_type),    pointer :: panel_id => null()
    type(operator_type), pointer :: m3_inv => null()

    ! Function spaces
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2h_fs => null()

    ! Parameters for unity transport
    integer(kind=i_def), parameter :: hori_monotone = horizontal_monotone_none
    integer(kind=i_def), parameter :: vert_monotone = vertical_monotone_none
    integer(kind=i_def), parameter :: order = 0_i_def

    ! Unity fields, increments, and fluxes
    type(r_tran_field_type) :: inc_one_x
    type(r_tran_field_type) :: inc_one_y
    type(r_tran_field_type) :: ini_one
    type(r_tran_field_type) :: flux_x
    type(r_tran_field_type) :: flux_y

    ! Half time step and flags for departure points
    integer(kind=i_def) :: mesh_id
    logical(kind=l_def) :: any_horz_dep_pts, any_vert_dep_pts, any_splitting_vhv
    integer(kind=i_def) :: stencil_extent
    integer(kind=i_def) :: cfl_stencil_extent
    real(kind=r_tran)   :: half_dt

    ! Get pre-computed objects and set pointers --------------------------------
    mesh_id = np1_x%get_mesh_id()
    half_dt = 0.5_r_tran * dt

    ! Function spaces
    field_fs => np1_x%get_function_space()

    ! Check which unity transport directions are needed
    any_horz_dep_pts = check_horz_dep_pts()
    any_vert_dep_pts = check_vert_dep_pts()
    any_splitting_vhv = check_any_splitting_vhv()

    ! Initialise fields
    call ini_one%initialise( vector_space = field_fs )

    ! Check if we need increment of unity in x and y directions ----------------
    if (any_horz_dep_pts) then
      w2h_fs => dep_pts_x%get_function_space()
      panel_id => get_panel_id( ini_one%get_mesh_id() )
      m3_inv => get_inverse_w3_mass_matrix(ini_one%get_mesh_id())

      call inc_one_x%initialise( vector_space = field_fs )
      call inc_one_y%initialise( vector_space = field_fs )
      call flux_x%initialise( vector_space = w2h_fs )
      call flux_y%initialise( vector_space = w2h_fs )

      ! Set initial values to zero (except from unity field)
      call invoke( setval_c(inc_one_x, 0.0_r_tran), &
                   setval_c(inc_one_y, 0.0_r_tran), &
                   setval_c(ini_one,   1.0_r_tran), &
                   setval_c(flux_x,    0.0_r_tran), &
                   setval_c(flux_y,    0.0_r_tran)  )

      ! x-direction ------------------------------------------------------------
      stencil_extent = dep_stencil_x + 1_i_def + order
      cfl_stencil_extent = stencil_extent
      call invoke( ffsl_flux_first_x_kernel_type(flux_x, ini_one,              &
                                                 stencil_extent, dep_pts_x,    &
                                                 detj_at_w2h, order,           &
                                                 hori_monotone,                &
                                                 cfl_stencil_extent, dt) )
      ! y-direction ------------------------------------------------------------
      stencil_extent = dep_stencil_y + 1_i_def + order
      cfl_stencil_extent = stencil_extent
      call invoke( ffsl_flux_first_y_kernel_type(flux_y, ini_one,              &
                                                 stencil_extent, dep_pts_y,    &
                                                 detj_at_w2h, order,           &
                                                 hori_monotone,                &
                                                 cfl_stencil_extent, dt ) )
      call invoke( fv_divergence_x_kernel_type( inc_one_x, flux_x, m3_inv ),   &
                   fv_divergence_y_kernel_type( inc_one_y, flux_y, m3_inv ),   &
                   ! Get the updated unity values: np1 = 1 - dt * F(1)
                   X_minus_bY(np1_x, ini_one, dt, inc_one_x),                  &
                   X_minus_bY(np1_y, ini_one, dt, inc_one_y),                  &
                   X_minus_bY(np1_half_x, ini_one, half_dt, inc_one_x),        &
                   X_minus_bY(np1_half_y, ini_one, half_dt, inc_one_y) )

      nullify( w2h_fs, panel_id, m3_inv )
    end if

    ! Check if we need increment of unity in z direction ----------------------
    if (any_vert_dep_pts) then

      ! Check if we need half increment of unity in z direction ---------------
      ! TODO #4160: this assumes that if any_splitting_vhv=.true. then all transport uses VHV splitting
      if (any_splitting_vhv) then
        call ffsl_vert_unity_transport_alg( dep_pts_z_half, &
                                            detj_at_w2v,    &
                                            half_dt,        &
                                            np1_half_z )
      else
        call ffsl_vert_unity_transport_alg( dep_pts_z,   &
                                            detj_at_w2v, &
                                            dt,          &
                                            np1_z )
      end if

    end if

  end subroutine ffsl_unity_transport_alg


  !===========================================================================!
  !> @brief   Algorithm to calculate the vertical FFSL transport of a unity field.
  !> @details The algorithm calculates the conservative vertical transport of unity using
  !!          the FFSL scheme. This is required for advective form FFSL transport.
  !!
  !> @param[in]     dep_pts_z         Departure points in z
  !> @param[in]     detj_at_w2v       Det(J) at W2V dofs
  !> @param[in]     dt                The timestep length
  !> @param[in,out] np1_z             Conservative transport of unity in z
  subroutine ffsl_vert_unity_transport_alg( dep_pts_z,      &
                                            detj_at_w2v,    &
                                            dt,             &
                                            np1_z )

    implicit none

    ! Arguments ----------------------------------------------------------------
    type(r_tran_field_type), intent(in)    :: dep_pts_z
    type(r_tran_field_type), intent(in)    :: detj_at_w2v
    real(kind=r_tran),       intent(in)    :: dt
    type(r_tran_field_type), intent(inout) :: np1_z

    ! Unity fields, increments, and fluxes
    type(r_tran_field_type) :: inc_one_z
    type(r_tran_field_type) :: ini_one
    type(r_tran_field_type) :: flux_z
    type(r_tran_field_type) :: flux_z_high, flux_z_low, flux_z_int
    type(r_tran_field_type) :: dz_w3

    ! Function spaces, height and volume pointers
    type(function_space_type), pointer :: field_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()
    type(operator_type),       pointer :: m3_inv => null()
    type(field_type),          pointer :: dz_w3_rdef => null()

    ! Function spaces
    field_fs => np1_z%get_function_space()
    w2v_fs   => dep_pts_z%get_function_space()

    ! Initialise fields
    call ini_one%initialise( vector_space = field_fs )
    call inc_one_z%initialise( vector_space = field_fs )
    call dz_w3%initialise( vector_space = field_fs )
    call flux_z%initialise( vector_space = w2v_fs )
    call flux_z_high%initialise( vector_space = w2v_fs )
    call flux_z_low%initialise( vector_space = w2v_fs )
    call flux_z_int%initialise( vector_space = w2v_fs )

    ! Set up fields for vertical unity transport
    dz_w3_rdef => get_dz_w3(np1_z%get_mesh_id())
    m3_inv => get_inverse_w3_mass_matrix(np1_z%get_mesh_id())

    ! Copy vertical spacing to r_tran precision
    call invoke_copy_to_rtran(dz_w3, dz_w3_rdef)

    ! Set initial values to zero (except from unity field)
    call invoke( setval_c(inc_one_z, 0.0_r_tran), &
                 setval_c(ini_one,   1.0_r_tran), &
                 setval_c(flux_z,    0.0_r_tran)  )

    ! Compute unity fluxes
    call invoke( ffsl_vert_constant_flux_kernel_type(flux_z_high, flux_z_low, &
                                                     flux_z_int, dep_pts_z,   &
                                                     detj_at_w2v, ini_one,    &
                                                     dz_w3, dt) )
    ! Combine integer and fractional fluxes
    call invoke( X_plus_Y(flux_z, flux_z_high, flux_z_int) )

    ! Take divergence of mass flux and multiply by inverse mass matrix to get increment
    call invoke( fv_divergence_z_kernel_type(inc_one_z, flux_z, m3_inv),      &
                 ! Get the updated unity values: np1 = 1 - dt * F(1)
                 X_minus_bY(np1_z, ini_one, dt, inc_one_z) )

    nullify( field_fs, w2v_fs, m3_inv, dz_w3_rdef )

  end subroutine ffsl_vert_unity_transport_alg


end module ffsl_unity_transport_alg_mod
