!-----------------------------------------------------------------------------
! (c) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief A two time-level iterative time-discretisation of the nonlinear
!!        3D equations.
module semi_implicit_timestep_alg_mod

  use constants_mod,             only: i_def, r_def, l_def
  use log_mod,                   only: log_event,         &
                                       log_scratch_space, &
                                       LOG_LEVEL_INFO
  use mesh_mod,                  only: mesh_type
  use model_clock_mod,           only: model_clock_type
  use reference_element_mod,     only: T

  ! Configuration options
  use section_choice_config_mod,  only: cloud, cloud_um, &
                                        aerosol, aerosol_um
  use physics_config_mod,         only: blayer_placement,                  &
                                        blayer_placement_fast,             &
                                        convection_placement,              &
                                        convection_placement_fast,         &
                                        stochastic_physics_placement,      &
                                        stochastic_physics_placement_fast, &
                                        smagorinsky_placement,             &
                                        smagorinsky_placement_outer

  use aerosol_config_mod,         only: glomap_mode,               &
                                        glomap_mode_dust_and_clim, &
                                        glomap_mode_ukca

  use microphysics_config_mod,    only: microphysics_casim

  use formulation_config_mod,     only: use_physics, dlayer_on,   &
                                        use_wavedynamics,         &
                                        moisture_formulation,     &
                                        moisture_formulation_dry, &
                                        exner_from_eos
  use io_config_mod,              only: subroutine_timers,                    &
                                        write_conservation_diag, write_diag,  &
                                        use_xios_io, diagnostic_frequency
  use mixed_solver_config_mod,    only: guess_np1,                            &
                                        reference_reset_freq
  use timestepping_config_mod,    only: alpha,                                &
                                        outer_iterations, inner_iterations,   &
                                        spinup_period, spinup_alpha, spinup_winds
  use transport_config_mod,       only: cheap_update, &
                                        transport_ageofair
  use derived_config_mod,         only: bundle_size
  use boundaries_config_mod,      only: limited_area, blend_frequency, &
                                        blend_frequency_inner, &
                                        blend_frequency_outer, &
                                        blend_frequency_final
  use fem_constants_mod,          only: get_mass_matrix,       &
                                        get_qr

  use field_bundle_builtins_mod,  only: clone_bundle,      &
                                        bundle_axpy,       &
                                        add_bundle,        &
                                        copy_bundle,       &
                                        set_bundle_scalar, &
                                        bundle_inc_axpby
  use fs_continuity_mod,          only: Wtheta, W2

  ! PsyKAl PSYClone kernels
  use matrix_vector_kernel_mod,   only: matrix_vector_kernel_type
  use dg_inc_matrix_vector_kernel_mod, &
                                  only: dg_inc_matrix_vector_kernel_type
  use enforce_bc_kernel_mod,      only: enforce_bc_kernel_type
  use set_any_dof_kernel_mod,     only: set_any_dof_kernel_type

  ! Derived Types
  use field_mod,                  only: field_type
  use field_collection_mod,       only: field_collection_type
  use quadrature_xyoz_mod,        only: quadrature_xyoz_type
  use operator_mod,               only: operator_type

  ! Algorithms
  use rhs_alg_mod,                only: rhs_alg
  use gungho_transport_control_alg_mod, &
                                  only: gungho_transport_control_alg_init, &
                                        gungho_transport_control_alg,      &
                                        gungho_transport_control_alg_final

  use si_operators_alg_mod,       only: create_si_operators,  &
                                        compute_si_operators, &
                                        final_si_operators
  use fast_physics_alg_mod,       only: fast_physics
  use slow_physics_alg_mod,       only: slow_physics
  use checks_and_balances_alg_mod,   &
                                  only: check_fields

  use semi_implicit_solver_alg_mod,  &
                                  only: semi_implicit_solver_alg_init,       &
                                        semi_implicit_solver_alg_step,       &
                                        semi_implicit_solver_alg_final
  use derive_exner_from_eos_alg_mod, &
                                  only: derive_exner_from_eos
  use mass_matrix_solver_alg_mod, only: mass_matrix_solver_alg
  use moist_dyn_factors_alg_mod,  only: moist_dyn_factors_alg
  use update_prognostic_scalars_alg_mod, &
                                  only: update_prognostic_scalars_alg
  use mixing_alg_mod,             only: mixing_alg
  use si_diagnostics_mod,         only: output_diags_for_si
  use predictors_alg_mod,         only: predictors_alg

  ! LAM
  use limited_area_lbc_alg_mod,   only: lam_solver_lbc, &
                                        lam_blend_lbc
  use lam_rhs_alg_mod,            only: calc_rhs_lbc,   &
                                        apply_mask_rhs

  ! Field mappings
  use calc_phys_predictors_alg_mod, &
                                  only: calc_phys_predictors_alg
  use map_physics_fields_alg_mod, only: map_physics_fields_alg

  ! Moisture species
  use mr_indices_mod,             only: nummr, imr_v, imr_cl
  use moist_dyn_mod,              only: num_moist_factors, gas_law

  ! Field indices
  use field_indices_mod,          only: igh_u, igh_t, igh_d, igh_p

  ! Mixing settings
  use mixing_config_mod,          only: smagorinsky
  use smagorinsky_alg_mod,        only: smagorinsky_alg
  ! Physics routines called
#ifdef UM_PHYSICS
  use cld_alg_mod,                only: cld_alg
  use aerosol_ukca_alg_mod,       only: aerosol_ukca_alg
  use casim_activate_alg_mod,     only: casim_activate_alg
#endif

  use log_mod,                    only: LOG_LEVEL_ERROR
  use timer_mod,                  only: timer
  use ageofair_alg_mod,           only: ageofair_update

  implicit none

  private

  logical(kind=l_def) :: use_moisture

  ! 'State' items private to the algorithm that need to be
  !  created once but used every step

  ! latest estimate of the prognostic fields through the iterative solver
  type( field_type ), allocatable :: state(:)
  ! prognostic fields at time level n, i.e. start of timestep
  type( field_type ), allocatable :: state_n(:)
  ! prognostic fields after slow physics, i.e. state_n + slow incs
  type( field_type ), allocatable :: state_after_slow(:)
  type( field_type ), allocatable :: advected_state(:)
  type( field_type ), allocatable :: mr_n(:), mr_after_adv(:), mr_after_slow(:)
  type( field_type ), allocatable :: rhs_n(:), rhs_np1(:), rhs_adv(:)
  type( field_type ), allocatable :: adv_inc_prev(:)
  type( field_type ), allocatable :: rhs_phys(:), rhs_lbc(:)
  type( field_type ) :: dtheta, dtheta_cld ! increment to theta
  type( field_type ) :: du ! increment to u
  type( field_type ) :: wind_prev  ! u from previous iteration used for cheap transport update
  type( field_type ) :: wind_fv_inc  ! u fv transport increment used for cheap transport update
  type( field_type ) :: theta_fv_inc ! theta fv transport increment to change to weak form

  type( field_type ) :: visc_m ! Smagorinsky diffusion coefficient for momentum
  type( field_type ) :: visc_h ! Smagorinsky diffusion coefficient for scalars

  public  :: semi_implicit_alg_init
  public  :: semi_implicit_alg_step
  public  :: semi_implicit_alg_final
  public  :: conditional_collection_copy

contains

  !> @details Initialisation procedure for the timestepping algorithm
  !>          Initialises various internal fields
  !> @param[in]     mesh  Mesh  on which the model runs
  !> @param[in,out] u     3D wind field
  !> @param[in,out] rho   Density
  !> @param[in,out] theta Potential temperature
  !> @param[in,out] exner Exner pressure
  !> @param[in,out] mr    Mixing ratios
  subroutine semi_implicit_alg_init( mesh, u, rho, theta, exner, mr)

    implicit none

    ! Mesh
    type(mesh_type), intent(in), pointer :: mesh

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta, exner
    type( field_type ), intent( inout ) :: mr(nummr)

    !--------------------------------------------------------------------
    ! Allocate internal state field arrays
    !--------------------------------------------------------------------

    allocate(state(bundle_size))
    allocate(state_n(bundle_size))
    allocate(state_after_slow(bundle_size))
    allocate(advected_state(bundle_size))
    allocate(rhs_n(bundle_size))
    allocate(rhs_np1(bundle_size))
    allocate(rhs_adv(bundle_size))
    allocate(adv_inc_prev(bundle_size))
    allocate(rhs_phys(bundle_size))
    allocate(rhs_lbc(bundle_size))
    allocate(mr_n(nummr))
    allocate(mr_after_slow(nummr))
    allocate(mr_after_adv(nummr))

    use_moisture = ( moisture_formulation /= moisture_formulation_dry )

    !--------------------------------------------------------------------
    ! Initialise internal state field objects
    !--------------------------------------------------------------------

    call u%copy_field_properties( state(igh_u) )
    call theta%copy_field_properties( state(igh_t) )
    call rho%copy_field_properties( state(igh_d) )
    call exner%copy_field_properties( state(igh_p) )

    call clone_bundle(state, state_n,          bundle_size)
    call clone_bundle(state, state_after_slow, bundle_size)
    call clone_bundle(state, advected_state,   bundle_size)
    call clone_bundle(state, rhs_n,            bundle_size)
    call clone_bundle(state, rhs_np1,          bundle_size)
    call clone_bundle(state, rhs_adv,          bundle_size)
    call clone_bundle(state, rhs_phys,         bundle_size)
    call clone_bundle(state, rhs_lbc,          bundle_size)
    call clone_bundle(state, adv_inc_prev,     bundle_size)

    call theta%copy_field_properties(dtheta)
    call theta%copy_field_properties(dtheta_cld)
    call theta%copy_field_properties(theta_fv_inc)
    call u%copy_field_properties(du)
    call u%copy_field_properties(wind_prev)
    call u%copy_field_properties(wind_fv_inc)

    call clone_bundle(mr, mr_n, nummr)
    call clone_bundle(mr, mr_after_slow, nummr)
    if (use_moisture) then
      call clone_bundle(mr, mr_after_adv, nummr)
    else
      call set_bundle_scalar(0.0_r_def, mr_n, nummr)
      call set_bundle_scalar(0.0_r_def, mr_after_slow, nummr)
    end if

    if ( use_physics ) then
      ! Set up the diffusion coefficient fields to be in the same space as theta
      call theta%copy_field_properties( visc_m )
      call theta%copy_field_properties( visc_h )
      if ( smagorinsky) then
        ! Initialise to zero
        call invoke( setval_c(visc_m , 0.0_r_def),  &
                     setval_c(visc_h , 0.0_r_def) )
      end if
    end if

    !--------------------------------------------------------------------
    ! Initialise the physics increments to 0
    !--------------------------------------------------------------------
    call set_bundle_scalar(0.0_r_def, rhs_phys, bundle_size)

    !--------------------------------------------------------------------
    ! Operators for si solves
    !--------------------------------------------------------------------
    call create_si_operators( mesh )

    call gungho_transport_control_alg_init( mesh )

    ! Construct semi-implicit solver
    call semi_implicit_solver_alg_init( state )

    call log_event( "semi_implicit_timestep: initialised timestepping algorithm", LOG_LEVEL_INFO )

  end subroutine semi_implicit_alg_init



  !> @details An algorithm for timestepping the 3D nonlinear equations
  !>          using an iterative process of the same form as endgame.
  !>          The algorithm splits all processes into one of three parts.
  !>          Old time level forcings computed once per timestep.
  !>          Advection terms computed in an outer loop using time-averaged
  !>          fields.
  !>          New time level forcings computed in an inner loop.
  !>          If matching ENDGame, 2 outer and 2 inner loops are used per timestep
  !>          by default. This means that there is one evaluation of old time
  !>          level terms, 2 evaluation of advective terms and 4 evaluations
  !>          of new time level terms and increment updates per timestep
  !> @param[in,out] u                      3D wind field
  !> @param[in,out] rho                    Density
  !> @param[in,out] theta                  Potential temperature
  !> @param[in,out] exner                  Exner pressure
  !> @param[in,out] mr                     Mixing ratios
  !> @param[in,out] moist_dyn              Factors for moist dynamics
  !> @param[in,out] adv_tracer_all_outer   Group of fields to be advected
  !> @param[in,out] adv_tracer_last_outer  Group of fields to be advected
  !> @param[in,out] con_tracer_all_outer   Second group of fields to be advected
  !> @param[in,out] con_tracer_last_outer  Second group of fields to be advected
  !> @param[in,out] derived_fields         Group of derived fields
  !> @param[in,out] radition_fields        Fields for radiation scheme
  !> @param[in,out] microphysics_fields    Fields for mphys scheme
  !> @param[in,out] electric_fields        Fields for electric (lighting) scheme
  !> @param[in]     orography_fields       Fields for orog drag scheme
  !> @param[in,out] turbulence_fields      Fields for turbulence scheme
  !> @param[in,out] convection_fields      Fields for convection scheme
  !> @param[in,out] cloud_fields           Fields for cloud scheme
  !> @param[in,out] surface_fields         Fields for surface scheme
  !> @param[in,out] soil_fields            Fields for soil hydrology scheme
  !> @param[in,out] snow_fields            Fields for snow scheme
  !> @param[in,out] chemistry_fields       Fields for chemistry scheme
  !> @param[in,out] aerosol_fields         Fields for aerosol scheme
  !> @param[in,out] stph_fields            Fields for stohcastic physics schemes
  !> @param[in,out] lbc_fields             Fields for lateral boundaries
  !> @param[in]     model_clock            Time in the model.
  !> @param[in]     dtemp_encorr           Temperature increment for energy
  !>                                       correction
  !> @param[in]     mesh                   The current mesh
  !> @param[in]     twod_mesh              The current 2d mesh
  subroutine semi_implicit_alg_step(u, rho, theta, exner, mr, moist_dyn,       &
                                    adv_tracer_all_outer,adv_tracer_last_outer,&
                                    con_tracer_all_outer,con_tracer_last_outer,&
                                    derived_fields, radiation_fields,          &
                                    microphysics_fields, electric_fields,      &
                                    orography_fields,                          &
                                    turbulence_fields, convection_fields,      &
                                    cloud_fields, surface_fields, soil_fields, &
                                    snow_fields, chemistry_fields,             &
                                    aerosol_fields, stph_fields, lbc_fields,   &
                                    model_clock, dtemp_encorr, mesh, twod_mesh)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u, rho, theta, exner
    type( field_type ), intent( inout ) :: mr(nummr)
    type( field_type ), intent( inout ) :: moist_dyn(num_moist_factors)
    ! field groups
    type( field_collection_type ), intent( inout ) :: adv_tracer_all_outer
    type( field_collection_type ), intent( inout ) :: adv_tracer_last_outer
    type( field_collection_type ), intent( inout ) :: con_tracer_all_outer
    type( field_collection_type ), intent( inout ) :: con_tracer_last_outer
    type( field_collection_type ), intent( inout ) :: derived_fields
    type( field_collection_type ), intent( inout ) :: radiation_fields
    type( field_collection_type ), intent( inout ) :: microphysics_fields
    type( field_collection_type ), intent( inout ) :: electric_fields
    type( field_collection_type ), intent( in )    :: orography_fields
    type( field_collection_type ), intent( inout ) :: turbulence_fields
    type( field_collection_type ), intent( inout ) :: convection_fields
    type( field_collection_type ), intent( inout ) :: cloud_fields
    type( field_collection_type ), intent( inout ) :: surface_fields
    type( field_collection_type ), intent( inout ) :: soil_fields
    type( field_collection_type ), intent( inout ) :: snow_fields
    type( field_collection_type ), intent( inout ) :: chemistry_fields
    type( field_collection_type ), intent( inout ) :: aerosol_fields
    type( field_collection_type ), intent( inout ) :: stph_fields
    type( field_collection_type ), intent( inout ) :: lbc_fields

    class(model_clock_type), intent(in) :: model_clock

    real(kind=r_def), intent(in)  :: dtemp_encorr

    type(mesh_type), intent(in), pointer :: mesh
    type(mesh_type), intent(in), pointer :: twod_mesh

    real(kind=r_def) :: cast_dt

    type(field_type), pointer :: ageofair  => null()

    ! Quadrature object
    type( quadrature_xyoz_type ), pointer :: qr => null()

    type(operator_type), pointer :: mm_wt   => null()
    type(operator_type), pointer :: mm_vel  => null()

    integer(kind=i_def) :: outer, inner, reset_ref_state
    real(kind=r_def)    :: varalpha, varbeta ! alpha, beta weight to use
                                             ! these may differ from input values
                                             ! during the spinup period

    ! Density field used for moisture conservation diagnostics and predictor
    logical(kind=l_def) :: write_moisture_diag

    ! Fields after slow physics to be advected (i.e. field_n + slow phys inc)
    type( field_collection_type ) :: adv_tracer_all_outer_after_slow
    type( field_collection_type ) :: adv_tracer_last_outer_after_slow
    type( field_collection_type ) :: con_tracer_all_outer_after_slow
    type( field_collection_type ) :: con_tracer_last_outer_after_slow
    ! Cloud fields after advection / before fast physics updates
    type( field_collection_type ) :: cloud_fields_after_adv

    if ( subroutine_timers ) call timer('semi_implicit_timestep_alg')

    cast_dt = real(model_clock%get_seconds_per_step(), r_def)

    qr => get_qr()

    mm_wt  => get_mass_matrix(Wtheta, mesh%get_id())
    mm_vel => get_mass_matrix(W2, mesh%get_id())

    !--------------------------------------------------------------------
    ! Copy prognostic field data to state arrays
    !--------------------------------------------------------------------
    call invoke( name = "copy_init_fields_to_state", &
                 setval_X(state(igh_u), u    ),      &
                 setval_X(state(igh_t), theta),      &
                 setval_X(state(igh_d), rho  ),      &
                 setval_X(state(igh_p), exner) )

    !--------------------------------------------------------------------
    ! If winds are being spunup overwrite the local copy of the winds
    ! with the driver level representation
    !--------------------------------------------------------------------
    if (model_clock%is_spinning_up()) then
       if (spinup_winds) then
         call invoke( setval_X(state(igh_u), u ) )
       end if
    end if

    !--------------------------------------------------------------------
    ! If off-centring is being spun up then modify the alpha value
    !--------------------------------------------------------------------
    if (spinup_alpha .and. model_clock%is_spinning_up()) then
      varalpha = 1.0_r_def
    else
      varalpha = alpha
    end if
    varbeta = 1.0 - varalpha

    ! Perform some checking on the fields.
    call check_fields(state, cast_dt)

    !--------------------------------------------------------------------
    ! Update state_n and mr_n with start of timestep values
    !--------------------------------------------------------------------
    if (use_moisture) then
      call copy_bundle(mr, mr_n, nummr)
      call copy_bundle(mr, mr_after_slow, nummr)
    end if
    call copy_bundle(state, state_n, bundle_size)
    call copy_bundle(state, state_after_slow, bundle_size)

    !--------------------------------------------------------------------
    ! Compute slow physic updates
    !--------------------------------------------------------------------
    if (use_physics) then
      call slow_physics( du, dtheta, mr_after_slow, visc_m, visc_h,           &
                         state_n(igh_t), state_n(igh_u),                      &
                         state_n(igh_d), state_n(igh_p),                      &
                         mr_n, derived_fields, radiation_fields,              &
                         microphysics_fields, electric_fields,                &
                         orography_fields,                                    &
                         turbulence_fields, convection_fields, cloud_fields,  &
                         surface_fields, soil_fields, snow_fields,            &
                         chemistry_fields, aerosol_fields, model_clock,       &
                         cast_dt, dtemp_encorr, mesh, twod_mesh )
      call invoke(name="update_from_slow_physics",                             &
                  inc_X_plus_Y(state_after_slow(igh_t), dtheta),               &
                  inc_X_plus_Y(state_after_slow(igh_u), du)                    &
                  )
    end if !use_physics

    !--------------------------------------------------------------------
    ! Compute the time-level n dynamics terms
    !--------------------------------------------------------------------
    call rhs_alg( rhs_n, varbeta*cast_dt, state_after_slow, state_n, &
                  moist_dyn, .false., .false. )

    call copy_bundle(state_after_slow, advected_state,  bundle_size)
    ! Set predictors for transport
    call predictors_alg(advected_state,state_n(igh_u),rhs_n(igh_u),varbeta,model_clock)

    !==========================================================================
    ! Start the Outer (advection) loop
    !==========================================================================
    call conditional_collection_copy(adv_tracer_all_outer_after_slow,  &
              generic_fields_to_copy=adv_tracer_all_outer,             &
              field_list=adv_tracer_all_outer)
    call conditional_collection_copy(adv_tracer_last_outer_after_slow, &
              generic_fields_to_copy=adv_tracer_last_outer,            &
              field_list=adv_tracer_last_outer)
    call conditional_collection_copy(con_tracer_all_outer_after_slow,  &
              generic_fields_to_copy=con_tracer_all_outer,             &
              field_list=con_tracer_all_outer)
    call conditional_collection_copy(con_tracer_last_outer_after_slow, &
              generic_fields_to_copy=con_tracer_last_outer,            &
              field_list=con_tracer_last_outer)
    call invoke( setval_X(wind_prev, state(igh_u)) )

    outer_dynamics_loop: do outer = 1,outer_iterations

      if (use_wavedynamics) then
        call gungho_transport_control_alg( rhs_adv, advected_state,          &
                                           state(igh_u), state_n(igh_u),     &
                                           mr, mr_after_slow, model_clock,   &
                                           outer, cheap_update,              &
                                           adv_inc_prev, wind_prev,          &
                                           adv_tracer_all_outer,             &
                                           adv_tracer_all_outer_after_slow,  &
                                           adv_tracer_last_outer,            &
                                           adv_tracer_last_outer_after_slow, &
                                           con_tracer_all_outer,             &
                                           con_tracer_all_outer_after_slow,  &
                                           con_tracer_last_outer,            &
                                           con_tracer_last_outer_after_slow  &
                                           )

        if ( cheap_update .AND. (outer < outer_iterations) ) then
          ! Copy transport increments to use in next outer iteration
          ! for the cheap transport update
          call copy_bundle(rhs_adv, adv_inc_prev, bundle_size)
          ! Update advected state, moisture, and tracers
          call mass_matrix_solver_alg( wind_fv_inc, rhs_adv(igh_u) )
          call invoke( inc_X_plus_Y(advected_state(igh_d), rhs_adv(igh_d) ), &
                       inc_X_plus_Y(advected_state(igh_t), rhs_adv(igh_t) ),   &
                       inc_X_plus_Y(advected_state(igh_u), wind_fv_inc ) )
          call conditional_collection_copy(adv_tracer_all_outer_after_slow, &
                      generic_fields_to_copy=adv_tracer_all_outer,          &
                      field_list=adv_tracer_all_outer)
          call conditional_collection_copy(con_tracer_all_outer_after_slow, &
                      generic_fields_to_copy=con_tracer_all_outer,          &
                      field_list=con_tracer_all_outer)
          if (use_moisture) then
            call copy_bundle(mr, mr_after_slow, nummr)
          end if
          ! Store latest estimate of the wind for cheap transport update
          call invoke( setval_X(wind_prev, state(igh_u)) )
        end if

        ! Convert theta increment to weak form
        call invoke( setval_X(theta_fv_inc, rhs_adv(igh_t)),          &
                     setval_c(rhs_adv(igh_t), 0.0_r_def),             &
                     dg_inc_matrix_vector_kernel_type(rhs_adv(igh_t), &
                                                      theta_fv_inc, mm_wt) )

        ! Compute the time-level n+1 dynamics terms
        call rhs_alg( rhs_np1, -varalpha*cast_dt, state, state, moist_dyn, &
                      .true., dlayer_on )
      else
        if (use_moisture) call copy_bundle(mr_after_slow, mr, nummr)
      end if

      if (use_physics) then
        !--------------------------------------------------------------------
        ! setting predictors for fast physics
        !--------------------------------------------------------------------
        if (blayer_placement == blayer_placement_fast .or.                     &
             convection_placement == convection_placement_fast .or.            &
             stochastic_physics_placement == stochastic_physics_placement_fast)&
             then
          call calc_phys_predictors_alg( derived_fields, rhs_np1, rhs_adv, &
                                         rhs_n, state, state_after_slow,   &
                                         lbc_fields, model_clock )
        end if
        if (use_moisture) call copy_bundle(mr, mr_after_adv, nummr)
        ! cloud fields are stored in the advective tracers
        call conditional_collection_copy(cloud_fields_after_adv,               &
                  generic_fields_to_copy=cloud_fields,                         &
                  field_list=adv_tracer_all_outer)

        !--------------------------------------------------------------------
        ! Call the fast physics terms
        !--------------------------------------------------------------------
        call fast_physics(du, dtheta, mr,                                      &
                          state_n(igh_t), state_n(igh_d), state_n(igh_u),      &
                          state_n(igh_p), mr_n, visc_m, visc_h, derived_fields,&
                          radiation_fields, microphysics_fields,               &
                          orography_fields, turbulence_fields,                 &
                          convection_fields, cloud_fields,                     &
                          surface_fields, soil_fields, snow_fields,            &
                          chemistry_fields, aerosol_fields, stph_fields,       &
                          outer, model_clock, cast_dt)

        if (smagorinsky .and. smagorinsky_placement == smagorinsky_placement_outer) then
          call smagorinsky_alg(dtheta, du, mr, state(igh_t), state(igh_u),   &
                               visc_m, visc_h, derived_fields, state(igh_d), &
                               cast_dt)
        end if

        if (use_wavedynamics) then
          ! copy increments into rhs_phys, including premultiplication by mass matrix
          ! need to reset rhs_phys to 0 because matrix_vector_kernel_type
          ! increments the field rather than over-writing it
          call set_bundle_scalar(0.0_r_def, rhs_phys, bundle_size)
          call invoke(name="update_rhs_phys_from_fast_physics",                &
                    dg_inc_matrix_vector_kernel_type(rhs_phys(igh_t), dtheta,  &
                                                                       mm_wt), &
                    matrix_vector_kernel_type(rhs_phys(igh_u), du, mm_vel ),   &
                    enforce_bc_kernel_type(rhs_phys(igh_u))                    &
                    )
        end if

      end if !use_physics

      if (use_wavedynamics) then

        ! Use advective update to guess n+1 level scalar fields.
        if ( guess_np1 ) then
          ! Update factors for moist dynamics
          if (use_moisture) call moist_dyn_factors_alg(moist_dyn, mr)
          call update_prognostic_scalars_alg(state, rhs_n, rhs_adv, &
                                             rhs_phys,              &
                                             moist_dyn(gas_law))
        end if

        !============================================================================
        ! Start the Inner (nonlinear, coriolis) loop
        !============================================================================
        inner_dynamics_loop: do inner = 1,inner_iterations
          write( log_scratch_space, '(A,2I3)' ) 'loop indices (o, i): ', &
                                                outer, inner
          call log_event( log_scratch_space, LOG_LEVEL_INFO )

          ! Reset reference state using latest guess of state
          reset_ref_state = mod(inner + (outer-1)*inner_iterations - 1_i_def, &
                                reference_reset_freq)
          if ( reset_ref_state == 0_i_def ) &
            call compute_si_operators(state, cast_dt)

          !--------------------------------------------------------------------
          ! Compute the time-level n+1 dynamics terms
          !--------------------------------------------------------------------
          if (inner > 1) call rhs_alg( rhs_np1, -varalpha*cast_dt, &
                                       state, state, moist_dyn,    &
                                       .true., dlayer_on )

          !--------------------------------------------------------------------
          ! Compute the LAM LBCs and RHS
          !--------------------------------------------------------------------
          if ( limited_area ) then
            call lam_solver_lbc(state(igh_u), lbc_fields)
            call calc_rhs_lbc(rhs_lbc, lbc_fields)
          end if

          !--------------------------------------------------------------------
          ! Compute the residuals
          !
          ! Add on advective terms: rhs = rhs_n - rhs_np1 + rhs_adv + rhs_phys
          ! (reuse rhs_np1 for rhs)
          !--------------------------------------------------------------------
          call bundle_axpy(-1.0_r_def, rhs_np1, rhs_n, rhs_np1, bundle_size)
          call add_bundle(rhs_np1, rhs_adv, rhs_np1, bundle_size)
          call add_bundle(rhs_np1, rhs_phys, rhs_np1, bundle_size)

          if ( limited_area ) then
            ! Add on the RHS for LBCs
            call add_bundle(rhs_np1, rhs_lbc, rhs_np1, bundle_size)
            ! Apply masks to RHS
            call apply_mask_rhs(rhs_np1)
          end if

          ! Accelerators for inner loop convergence
          if ( inner > 1 ) then
            call invoke( setval_c(rhs_np1(igh_d), 0.0_r_def), &
                         setval_c(rhs_np1(igh_t), 0.0_r_def) )
          end if


          write_moisture_diag = write_conservation_diag .and. &
                                outer == outer_iterations .and. &
                                inner == inner_iterations .and. &
                                use_moisture
          !--------------------------------------------------------------------
          ! Solve semi-implicit system: A*inc = rhs, and incement state by inc
          !--------------------------------------------------------------------
          call semi_implicit_solver_alg_step( state, rhs_np1,     &
                                              moist_dyn(gas_law), &
                                              mr,                 &
                                              write_moisture_diag )

          ! If not already done update factors for moist dynamics
          if ( .not. guess_np1 .and. use_moisture ) &
            call moist_dyn_factors_alg(moist_dyn, mr)

          if (exner_from_eos) then
            call derive_exner_from_eos( state, &
                                        moist_dyn(gas_law) )
          end if

          ! For poorly balanced initial conditions, we set the vertical
          ! component of W2 wind to zero
          if (spinup_alpha .and. model_clock%is_spinning_up()) then
            call invoke( set_any_dof_kernel_type(state(igh_u), T, 0.0_r_def) )
          end if

          !--------------------------------------------------------------------
          ! LAM Overwrite and Blend LBCs
          !--------------------------------------------------------------------
          if ( limited_area ) then
            if ( ( blend_frequency == blend_frequency_inner) &
               .or.                                          &
               ( blend_frequency == blend_frequency_outer    &
               .and. inner == inner_iterations )             &
               .or.                                          &
               ( blend_frequency == blend_frequency_final    &
               .and. inner == inner_iterations               &
               .and. outer == outer_iterations ) ) then

              call lam_blend_lbc(state(igh_u), state(igh_p), state(igh_d), &
                               state(igh_t), mr, lbc_fields)

            end if
          endif

        end do inner_dynamics_loop
        !--------------------------------------------------------------------
        ! End of Inner (nonlinear, coriolis) loop
        !--------------------------------------------------------------------

      else ! when use_wavedynamics=false, just add physics increments here

        call invoke(X_plus_Y(state(igh_t), state_after_slow(igh_t), dtheta), &
                    X_plus_Y(state(igh_u), state_after_slow(igh_u), du))

      end if ! use_wavedynamics

    end do outer_dynamics_loop
    !--------------------------------------------------------------------
    ! End of Outer (advection) loop
    !--------------------------------------------------------------------

    if (transport_ageofair) then
      call con_tracer_last_outer%get_field('ageofair', ageofair)
      call ageofair_update(ageofair, model_clock)
    end if

    !--------------------------------------------------------------------
    ! Apply mixing
    !--------------------------------------------------------------------
    call mixing_alg(mr, state(igh_t),                             &
                    state(igh_u), visc_m, visc_h, derived_fields, &
                    state(igh_d), cast_dt )

    ! ----------------------------------------------------------------------
    ! Call cloud scheme to generate cloud and latent heating after pressure
    ! changes are applied from the solver.
    ! ----------------------------------------------------------------------
#ifdef UM_PHYSICS
    if (use_physics .and. cloud == cloud_um  ) then
      call cld_alg( dtheta_cld, mr,                                 &
                    state(igh_t), state(igh_p), state(igh_d),       &
                    derived_fields, turbulence_fields,              &
                    cloud_fields, convection_fields,                &
                    state_n(igh_t), mr_n,                           &
                    model_clock%get_step(), cast_dt )
      call invoke(inc_X_plus_Y(state(igh_t), dtheta_cld))
      if (microphysics_casim) then
        call casim_activate_alg( mr, cloud_fields,                  &
                                 microphysics_fields)
      end if ! microphysics_casim
    end if
#endif

    ! Update derived variables for time level n+1
    if (use_moisture) then
      call moist_dyn_factors_alg(moist_dyn, mr)
    end if
    if (use_physics) then
      call map_physics_fields_alg(state(igh_u), state(igh_p),              &
                                  state(igh_d), state(igh_t),              &
                                  moist_dyn, derived_fields)
    end if

    !--------------------------------------------------------------------
    ! Call UKCA for GLOMAP-mode prognostic aerosol updates
    !--------------------------------------------------------------------
#ifdef UM_PHYSICS
    if ( aerosol == aerosol_um .and.            &
         ( glomap_mode == glomap_mode_ukca .or. &
           glomap_mode == glomap_mode_dust_and_clim ) ) then
      call aerosol_ukca_alg ( chemistry_fields, aerosol_fields,          &
                              radiation_fields, derived_fields,          &
                              microphysics_fields, turbulence_fields,    &
                              convection_fields, cloud_fields,           &
                              surface_fields, soil_fields,               &
                              state, mr, model_clock%get_step() )
    end if
#endif

    ! Write diagnostic output
    if (write_diag .and. use_xios_io .and. &
         mod(model_clock%get_step(),diagnostic_frequency) == 0 ) then
      call output_diags_for_si(state, state_n, state_after_slow, mr, mr_n,  &
                               mr_after_slow, mr_after_adv, derived_fields, &
                               du, dtheta, adv_tracer_all_outer,            &
                               cloud_fields_after_adv)
    end if

    !--------------------------------------------------------------------
    ! Update fields held in the driver layer
    !--------------------------------------------------------------------
    if (.not. (spinup_winds .and. model_clock%is_spinning_up())) &
      call invoke( setval_X(u, state(igh_u)) )

    call invoke( setval_X(theta, state(igh_t)), &
                 setval_X(rho,   state(igh_d)), &
                 setval_X(exner, state(igh_p)) )

    nullify( mm_wt, mm_vel, qr )

    if ( subroutine_timers ) call timer('semi_implicit_timestep_alg')

  end subroutine semi_implicit_alg_step


  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !> Release all claimed resources once completed.
  !>
  subroutine semi_implicit_alg_final()

    implicit none

    call semi_implicit_solver_alg_final()
    call final_si_operators()

    if (allocated(state))            deallocate(state)
    if (allocated(state_n))          deallocate(state_n)
    if (allocated(state_after_slow)) deallocate(state_after_slow)
    if (allocated(advected_state))   deallocate(advected_state)
    if (allocated(rhs_n))            deallocate(rhs_n)
    if (allocated(rhs_np1))          deallocate(rhs_np1)
    if (allocated(rhs_adv))          deallocate(rhs_adv)
    if (allocated(rhs_phys))         deallocate(rhs_phys)
    if (allocated(rhs_lbc))          deallocate(rhs_lbc)
    if (allocated(adv_inc_prev))     deallocate(adv_inc_prev)
    if (allocated(mr_n))             deallocate(mr_n)
    if (allocated(mr_after_slow))    deallocate(mr_after_slow)
    if (allocated(mr_after_adv))     deallocate(mr_after_adv)

    call dtheta%field_final()
    call du%field_final()

    if ( use_physics ) then
      call visc_m%field_final()
      call visc_h%field_final()
    end if

    return
  end subroutine semi_implicit_alg_final

  !============================================================================!
  !> @brief Make a deep copy of a subset of a field collection, based on a
  !>        list of fields provided by another collection
  !> @param[out] generic_fields_copied  New collection written with fields
  !>                                    saved at some point in time
  !> @param[in]  generic_fields_to_copy collection we want to save fields from
  !> @param[in]  field_list             list of fields to be saved
  subroutine conditional_collection_copy(generic_fields_copied,  &
                                         generic_fields_to_copy, &
                                         field_list)

    use field_collection_mod,          only: field_collection_type
    use field_collection_iterator_mod, only: field_collection_real_iterator_type

    implicit none

    type(field_collection_type), intent(out) :: generic_fields_copied
    type(field_collection_type), intent(in)  :: generic_fields_to_copy
    type(field_collection_type), intent(in)  :: field_list

    ! Iterator for field collection
    type(field_collection_real_iterator_type) :: iterator

    ! One of the single fields out of the generic_fields_to_copy collection
    type(field_type), pointer :: single_generic_field => null()

    ! The saved version of single_generic_field
    type(field_type) :: copied_generic_field

    logical(kind=l_def) :: l_copy

    call generic_fields_copied%initialise(name='fields_copied')

    if ( generic_fields_to_copy%get_length() > 0 ) then

      call iterator%initialise(generic_fields_to_copy)

      do
        if ( .not.iterator%has_next() ) exit

        single_generic_field => iterator%next()

        l_copy = field_list%field_exists(single_generic_field%get_name())

        if ( l_copy ) then

          ! We copy the field we want to save into a new field
          call single_generic_field%copy_field_properties(copied_generic_field)
          call invoke( setval_X(copied_generic_field, single_generic_field) )

          ! We add it to the field collection passed in
          call generic_fields_copied%add_field(copied_generic_field)

        end if ! ( l_copy )

      end do

    end if

  end subroutine conditional_collection_copy
end module semi_implicit_timestep_alg_mod
