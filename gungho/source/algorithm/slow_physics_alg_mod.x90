!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief Calls to the slow physics schemes
module slow_physics_alg_mod

  use clock_mod,                 only: clock_type
  use timestepping_config_mod,   only: outer_iterations
  use cloud_config_mod,          only: scheme, scheme_pc2, scheme_bimodal,      &
                                       pc2ini, pc2ini_bimodal,cld_fsd_hill
  use convection_config_mod,     only: cv_scheme, cv_scheme_lambert_lewis, &
                                       cv_scheme_gregory_rowntree
  use constants_mod,             only: i_def, r_def, l_def
  use log_mod,                   only: LOG_LEVEL_INFO
  use print_field_stats_alg_mod, only: print_field_stats_alg
  use physics_config_mod,        only: microphysics_placement,         &
                                       microphysics_placement_slow,    &
                                       orographic_drag_placement,      &
                                       orographic_drag_placement_slow, &
                                       radiation_placement,            &
                                       radiation_placement_slow,       &
                                       spectral_gwd_placement,         &
                                       spectral_gwd_placement_slow,    &
                                       blayer_placement,               &
                                       blayer_placement_slow,          &
                                       convection_placement,           &
                                       convection_placement_slow
  use section_choice_config_mod, only: aerosol, aerosol_um,                 &
                                       boundary_layer, boundary_layer_um,   &
                                       microphysics, microphysics_um,       &
                                       orographic_drag, orographic_drag_um, &
                                       radiation, radiation_socrates,       &
                                       spectral_gwd, spectral_gwd_um,       &
                                       methane_oxidation,                   &
                                       surface, surface_jules,              &
                                       convection, convection_um,           &
                                       cloud, cloud_um,                     &
                                       external_forcing

  ! Derived Types
  use field_mod,                 only: field_type
  use field_collection_mod,      only: field_collection_type
  use function_space_collection_mod, only: function_space_collection
  use function_space_mod,            only: function_space_type
  ! Moisture species
  use mr_indices_mod,            only: nummr, imr_v, imr_cl, imr_ci
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type
  use moisture_conservation_alg_mod,  only: moisture_conservation_alg
  use fs_continuity_mod,         only: W3, Wtheta
  use field_bundle_mod,          only: add_bundle, clone_bundle, &
                                       set_bundle_scalar
  use formulation_config_mod,    only: use_moisture
  use io_config_mod,             only: subroutine_timers,                    &
                                       write_conservation_diag
  use timer_mod,                 only: timer
  use external_forcing_alg_mod,  only: external_forcing_alg
  ! Physics schemes called
#ifdef UM_PHYSICS
  use locate_tropopause_alg_mod, only: locate_tropopause_alg
  use radaer_alg_mod,            only: radaer_alg
  use glomap_aerosol_alg_mod,    only: glomap_aerosol_alg
  use strat_aerosol_alg_mod,     only: strat_aerosol_alg
  use mphys_alg_mod,             only: mphys_alg
  use illuminate_alg_mod,        only: illuminate_alg
  use rad_tile_alg_mod,          only: rad_tile_alg
  use radiation_alg_mod,         only: radiation_alg
  use pc2_rad_response_alg_mod,  only: pc2_rad_response_alg
  use spectral_gwd_alg_mod,      only: spectral_gwd_alg
  use orographic_drag_alg_mod,   only: orographic_drag_alg
  use bl_exp_alg_mod,            only: bl_exp_alg
  use bl_imp_alg_mod,            only: bl_imp_alg
  use conv_ll_alg_mod,           only: conv_ll_alg
  use conv_gr_alg_mod,           only: conv_gr_alg
  use jules_extra_alg_mod,       only: jules_extra_alg
  use pc2_conv_coupling_alg_mod, only: pc2_conv_coupling_alg
  use pc2_checks_alg_mod,        only: pc2_checks_alg
  use methox_alg_mod,            only: methox_alg
  use aerosol_config_mod,        only: activation_scheme,                      &
                                       activation_scheme_jones,                &
                                       l_radaer,                               &
                                       sulphuric_strat_climatology
  use ancil_info,                only: rad_nband
  use jules_control_init_mod,    only: n_land_tile
  use fsd_condensate_alg_mod,    only: fsd_condensate_alg
  use um_physics_init_mod,       only: sw_band_mode, lw_band_mode, mode_dimen
  use bm_tau_alg_mod,            only: bm_tau_alg
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          before the outer loop of the solver
  !> @param[in,out] du                     Increment to wind field
  !> @param[in,out] dtheta                 Increment to theta field
  !> @param[in,out] mr                     Mixing ratios to be updated
  !> @param[in,out] visc_m                 Smagorinsky momentum diffusion coef
  !> @param[in,out] visc_h                 Smagorinsky heat diffusion coef
  !> @param[in]     theta                  Theta field at start of timestep
  !> @param[in]     rho                    Rho on w3 space
  !> @param[in]     exner                  Exner pressure on w3 space
  !> @param[in]     mr_n                   Mixing ratios at start of timestep
  !> @param[in]     derived_fields         Group of derived fields
  !> @param[in,out] radiation_fields       Fields for radiation scheme
  !> @param[in,out] microphysics_fields    Fields for mphys scheme
  !> @param[in]     orography_fields       Fields for orog drag scheme
  !> @param[in,out] turbulence_fields      Fields for turbulence scheme
  !> @param[in,out] convection_fields      Fields for convection scheme
  !> @param[in,out] cloud_fields           Fields for cloud scheme
  !> @param[in,out] surface_fields         Fields for surface scheme
  !> @param[in,out] soil_fields            Fields for soil hydrology scheme
  !> @param[in,out] snow_fields            Fields for snow scheme
  !> @param[in,out] aerosol_fields         Fields for aerosol scheme
  !> @param[in]     clock                  Model time
  !> @param[in]     dt                     The model timestep length
  !> @param[in]     mesh_id                Identifier given to current mesh
  !> @param[in]     twod_mesh_id           Identifier given to current 2d mesh
  subroutine slow_physics(du, dtheta, mr, visc_m, visc_h,                      &
                          theta, rho, exner, mr_n, derived_fields,             &
                          radiation_fields, microphysics_fields,               &
                          orography_fields, turbulence_fields,                 &
                          convection_fields, cloud_fields, surface_fields,     &
                          soil_fields, snow_fields, aerosol_fields,            &
                          clock, dt, mesh_id, twod_mesh_id )

    implicit none

    ! Fields
    type( field_type ), intent( inout ) :: du, dtheta, visc_m, visc_h
    type( field_type ), intent( in )    :: theta, rho, exner

    ! Field bundles
    type( field_type ), intent( inout ) :: mr(nummr)   ! Latest value, to update
    type( field_type ), intent( in )    :: mr_n(nummr) ! Start of timestep
                                                       ! Do not alter

    ! Field groups
    type( field_collection_type ), intent(inout) :: derived_fields
    type( field_collection_type ), intent(inout) :: radiation_fields
    type( field_collection_type ), intent(inout) :: microphysics_fields
    type( field_collection_type ), intent(in)    :: orography_fields
    type( field_collection_type ), intent(inout) :: turbulence_fields
    type( field_collection_type ), intent(inout) :: convection_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: surface_fields
    type( field_collection_type ), intent(inout) :: soil_fields
    type( field_collection_type ), intent(inout) :: snow_fields
    type( field_collection_type ), intent(inout) :: aerosol_fields

    integer( kind=i_def ), intent(in) :: mesh_id
    integer( kind=i_def ), intent(in) :: twod_mesh_id
    class(clock_type),     intent(in) :: clock
    real( kind=r_def ),    intent(in) :: dt

    ! Local fields...
    ! ...for external forcing
    type( field_type ) :: dtheta_forcing, du_forcing
    ! ...for microphysics
    type( field_type ), pointer :: dtheta_mphys => null()
    type( field_type ) :: dmr_mphys(nummr)
    type( field_type ) :: dcfl_pc2_mphys, dcff_pc2_mphys, dbcf_pc2_mphys
    ! ...for radiation
    type( field_type ), pointer :: dtheta_rad => null()
    type( field_type ), pointer :: dmv_pc2_rad => null()
    type( field_type ) :: dtheta_pc2_rad, dmcl_pc2_rad
    type( field_type ) :: dcfl_pc2_rad, dbcf_pc2_rad
#ifdef UM_PHYSICS
    type( field_type ) :: trop_level
    type( field_type ) :: aer_mix_ratio
    type( field_type ) :: aer_sw_absorption, aer_sw_scattering, aer_sw_asymmetry
    type( field_type ) :: aer_lw_absorption, aer_lw_scattering, aer_lw_asymmetry
    type( field_type ) :: tile_lw_albedo
    type( field_type ) :: tile_sw_diffuse_albedo, tile_sw_direct_albedo
#endif
    ! ...for spectral GWD
    type( field_type ) :: du_tot_spectral_gwd, dtheta_spectral_gwd
    ! ...for orog GWD
    type( field_type ) :: du_tot_orographic_drag, dtheta_orographic_drag
    ! ...for methane oxidation
    type( field_type ) :: dmv_methox
    ! ...for boundary layer
    type( field_type ) :: dtheta_bl
    type( field_type ), pointer :: du_bl => null()
#ifdef UM_PHYSICS
    ! ...for Convection
    type( field_type ), pointer :: dmv_conv => null()
    ! ...surface fields passed from BL to Jules
    type( field_type ) :: snow_sublimation
    type( field_type ) :: surf_heat_flux
    type( field_type ) :: canopy_evap
    type( field_type ) :: water_extraction
    type( field_type ) :: total_snowmelt
    ! ...for PC2 checks
    type( field_type ) :: dtheta_pc2_checks, theta_updated
    type( field_type ) :: dmv_pc2_checks, dmcl_pc2_checks, dmcf_pc2_checks
    type( field_type ) :: dcfl_pc2_checks, dcff_pc2_checks, dbcf_pc2_checks
    ! ...for fractional standard deviation cloud (microphysics and radiation)
    type( field_type ) :: f_arr

    ! pointers to vector spaces
    type(function_space_type), pointer :: vector_space => null()

    ! Temporary fields to unpack from field collection
    type( field_type ), pointer :: departure_exner_wth => null()
#endif
    type( field_type ), pointer :: exner_in_wth => null()
    ! Fields required by PC2
    type( field_type ), pointer :: liquid_fraction => null()
    type( field_type ), pointer :: ice_fraction    => null()
    type( field_type ), pointer :: bulk_fraction   => null()

    integer( kind=i_def ) :: i_mr

    ! Flags to indicate whether scheme has run and increments need adding
    logical( kind=l_def ) :: theta_forcing_done
    logical( kind=l_def ) :: wind_forcing_done
    logical( kind=l_def ) :: microphysics_done
    logical( kind=l_def ) :: radiation_done
    logical( kind=l_def ) :: spectral_gwd_done
    logical( kind=l_def ) :: orographic_drag_done
    logical( kind=l_def ) :: methox_done
    logical( kind=l_def ) :: boundary_layer_done

    if ( subroutine_timers ) call timer("slow_physics")

    !--------------------------------------------------------------------
    ! Initialisation of fields and flags
    !--------------------------------------------------------------------
    call invoke( setval_c(dtheta, 0.0_r_def), &
                 setval_c(du, 0.0_r_def) )
    exner_in_wth => derived_fields%get_field('exner_in_wth')
    theta_forcing_done   = .false.
    wind_forcing_done    = .false.
    microphysics_done    = .false.
    radiation_done       = .false.
    spectral_gwd_done    = .false.
    orographic_drag_done = .false.
    methox_done          = .false.
    boundary_layer_done  = .false.

    !--------------------------------------------------------------------
    ! External forcing options
    !--------------------------------------------------------------------
    if ( external_forcing ) then
      call external_forcing_alg(derived_fields, theta, exner, exner_in_wth, &
                                dt, dtheta_forcing, du_forcing,             &
                                theta_forcing_done, wind_forcing_done)
    end if

#ifdef UM_PHYSICS

    if ( microphysics == microphysics_um .or. &
         radiation == radiation_socrates ) then

      !--------------------------------------------------------------------
      ! Fractional standard deviation (FSD) of cloud condensate
      !--------------------------------------------------------------------
      vector_space => function_space_collection%get_fs( mesh_id, 0, Wtheta, 3)
      call f_arr%initialise(vector_space)
      if ( cld_fsd_hill ) then
        call fsd_condensate_alg( f_arr, cloud_fields, convection_fields )
      end if

      if ( aerosol == aerosol_um ) then

        !--------------------------------------------------------------------
        ! Tropopause level
        !--------------------------------------------------------------------
        if (sulphuric_strat_climatology .or. l_radaer) then
          call locate_tropopause_alg(trop_level, theta, exner_in_wth, twod_mesh_id)
        end if

        !--------------------------------------------------------------------
        ! Aerosol climatologies
        !--------------------------------------------------------------------
        if ( activation_scheme == activation_scheme_jones ) then
          call glomap_aerosol_alg ( aerosol_fields, theta, exner_in_wth )
        end if

        if ( sulphuric_strat_climatology ) then
          call strat_aerosol_alg ( aerosol_fields, trop_level, exner )
        end if

      end if ! aerosol
    end if ! microphysics or socrates

    !--------------------------------------------------------------------
    ! UM microphysics scheme
    !--------------------------------------------------------------------
    dtheta_mphys => microphysics_fields%get_field('dtheta_mphys')
    call clone_bundle(mr_n, dmr_mphys, nummr)
    call set_bundle_scalar(0.0_r_def, dmr_mphys, nummr)
    if ( microphysics == microphysics_um .and. &
         microphysics_placement == microphysics_placement_slow) then
      call mphys_alg( mr_n, theta, rho, derived_fields, microphysics_fields, &
                      cloud_fields, aerosol_fields, turbulence_fields,       &
                      f_arr, dmr_mphys, dtheta_mphys, dcfl_pc2_mphys,        &
                      dcff_pc2_mphys, dbcf_pc2_mphys, dt )
      microphysics_done = .true. ! Collect this increment later on
    end if

    !--------------------------------------------------------------------
    ! Socrates radiation scheme
    !--------------------------------------------------------------------
    if (radiation == radiation_socrates .and. &
        radiation_placement == radiation_placement_slow) then

      !--------------------------------------------------------------------
      ! UM radaer scheme
      !--------------------------------------------------------------------
      vector_space=>function_space_collection%get_fs(mesh_id,0,Wtheta,mode_dimen)
      call aer_mix_ratio%initialise(vector_space)
      vector_space=>function_space_collection%get_fs(mesh_id,0,Wtheta,         &
                                                     sw_band_mode)
      call aer_sw_absorption%initialise(vector_space)
      call aer_sw_scattering%initialise(vector_space)
      call aer_sw_asymmetry%initialise(vector_space)
      vector_space=>function_space_collection%get_fs(mesh_id,0,Wtheta,         &
                                                     lw_band_mode)
      call aer_lw_absorption%initialise(vector_space)
      call aer_lw_scattering%initialise(vector_space)
      call aer_lw_asymmetry%initialise(vector_space)

      if ( aerosol == aerosol_um .and. l_radaer ) then
        call radaer_alg( aerosol_fields,                                       &
                         theta,                                                &
                         exner_in_wth,                                         &
                         trop_level,                                           &
                         aer_mix_ratio,                                        &
                         aer_sw_absorption,aer_sw_scattering,aer_sw_asymmetry, &
                         aer_lw_absorption,aer_lw_scattering,aer_lw_asymmetry )
      end if

      call illuminate_alg( radiation_fields, clock%get_step() )

      call rad_tile_alg(tile_sw_direct_albedo, tile_sw_diffuse_albedo,  &
                        tile_lw_albedo, derived_fields,                 &
                        radiation_fields, orography_fields,             &
                        surface_fields, soil_fields, snow_fields,       &
                        twod_mesh_id, clock%get_step())

      dtheta_rad => radiation_fields%get_field('dtheta_rad')
      dmv_pc2_rad => radiation_fields%get_field('dmv_pc2_rad')
      call radiation_alg( dtheta_rad, theta, exner, mr_n,                    &
                          derived_fields, radiation_fields, cloud_fields,    &
                          convection_fields, aerosol_fields, surface_fields, &
                          clock%get_step(),                                  &
                          tile_sw_direct_albedo, tile_sw_diffuse_albedo,     &
                          tile_lw_albedo, aer_mix_ratio,                     &
                          aer_sw_absorption, aer_lw_absorption,              &
                          aer_sw_scattering, aer_lw_scattering,              &
                          aer_sw_asymmetry,  aer_lw_asymmetry )
      radiation_done = .true. ! Collect this increment later on

      if (cloud == cloud_um .and. scheme == scheme_pc2) then
        ! PC2 code will be called with dtheta_rad as the only forcing.
        call pc2_rad_response_alg(                 & ! Current state
                                   mr_n,           & ! IN
                                   theta,          & ! IN
                                   derived_fields, & ! IN
                                   cloud_fields,   & ! IN
                                                     ! Forcings
                                   dtheta_rad,     & ! IN
                                                     ! Responses
                                   dtheta_pc2_rad, & ! OUT
                                   dmv_pc2_rad,    & ! OUT
                                   dmcl_pc2_rad,   & ! OUT
                                   dcfl_pc2_rad,   & ! OUT
                                   dbcf_pc2_rad,   & ! OUT
                                   dt )              ! IN
      end if ! (scheme == scheme_pc2)

    end if

    !--------------------------------------------------------------------
    ! UM spectral gravity wave drag scheme
    !--------------------------------------------------------------------
    if (spectral_gwd == spectral_gwd_um .and. &
        spectral_gwd_placement == spectral_gwd_placement_slow) then
      call du%copy_field_properties(du_tot_spectral_gwd)
      call dtheta%copy_field_properties(dtheta_spectral_gwd)
      call spectral_gwd_alg(du_tot_spectral_gwd, &
                            dtheta_spectral_gwd, &
                            derived_fields,      &
                            microphysics_fields, &
                            convection_fields,   &
                            theta)
      spectral_gwd_done = .true. ! Collect this increment later on
    end if

    !--------------------------------------------------------------------
    ! UM orographic drag scheme
    !--------------------------------------------------------------------
    if (orographic_drag == orographic_drag_um .and. &
        orographic_drag_placement == orographic_drag_placement_slow) then
      call du%copy_field_properties(du_tot_orographic_drag)
      call dtheta%copy_field_properties(dtheta_orographic_drag)
      call orographic_drag_alg(du_tot_orographic_drag, &
                               dtheta_orographic_drag, &
                               derived_fields,         &
                               orography_fields,       &
                               theta,                  &
                               mr_n)
      orographic_drag_done = .true. ! Collect this increment later on
    end if

    ! Call methane oxidation code
    if (methane_oxidation) then
      call methox_alg(dmv_methox, mr_n, clock)
      methox_done = .true.
    end if

    !--------------------------------------------------------------------
    ! UM explicit boundary layer and Jules surface schemes
    !--------------------------------------------------------------------
    if (boundary_layer == boundary_layer_um ) then
      call bl_exp_alg(visc_m, visc_h, theta, rho, exner, mr_n,           &
                      derived_fields, radiation_fields,                  &
                      microphysics_fields, dmr_mphys, orography_fields,  &
                      turbulence_fields, convection_fields, cloud_fields,&
                      surface_fields, soil_fields, snow_fields)

    !--------------------------------------------------------------------
    ! Calculate time scales for bimodal cloud scheme
    !------------------------------------------------------------------

    if ( cloud == cloud_um .and. ( scheme == scheme_bimodal .or.          &
        ( scheme == scheme_pc2 .and. pc2ini == pc2ini_bimodal ) ) ) then

      call bm_tau_alg(mr_n, theta, derived_fields, turbulence_fields,     &
                     cloud_fields)

    end if


    !--------------------------------------------------------------------
    ! UM convection scheme
    !--------------------------------------------------------------------
    if (convection == convection_um .and.                       &
        convection_placement == convection_placement_slow) then
      if ( cv_scheme == cv_scheme_lambert_lewis ) then
        ! Call the UM Lambert-Lewis convection scheme
        call conv_ll_alg(mr, exner, derived_fields, convection_fields,    &
                         outer_iterations)
      else if ( cv_scheme == cv_scheme_gregory_rowntree ) then
        ! Call the UM Gregory Rowntree convection scheme
        call conv_gr_alg(mr, rho, exner, derived_fields,                  &
                         turbulence_fields, convection_fields,            &
                         cloud_fields, surface_fields, outer_iterations)
      end if

      if ( cloud == cloud_um .and. scheme == scheme_pc2 ) then
        ! Update the cloud fields if using PC2
        call pc2_conv_coupling_alg( mr, derived_fields,                  &
                                    convection_fields, cloud_fields, dt)
      else
        ! Without PC2, just update vapour field
        dmv_conv => convection_fields%get_field('dmv_conv')
        call invoke( inc_X_plus_Y(mr(imr_v), dmv_conv) )
      end if

    end if

    !--------------------------------------------------------------------
    ! UM implicit boundary layer and Jules surface schemes
    !--------------------------------------------------------------------
      if (blayer_placement == blayer_placement_slow) then
        du_bl => turbulence_fields%get_field('du_bl')
        call bl_imp_alg(dtheta_bl, du_bl, mr, snow_sublimation,             &
                        surf_heat_flux, canopy_evap, water_extraction,      &
                        total_snowmelt, theta, exner, mr_n,                 &
                        derived_fields, radiation_fields, orography_fields, &
                        turbulence_fields, convection_fields, cloud_fields, &
                        surface_fields, soil_fields, snow_fields,           &
                        outer_iterations, clock)
        boundary_layer_done = .true. ! Collect this increment later on

        if ( surface == surface_jules ) then
          call jules_extra_alg(microphysics_fields, convection_fields,        &
                               surface_fields, soil_fields, snow_fields,      &
                               snow_sublimation, surf_heat_flux, canopy_evap, &
                               water_extraction, total_snowmelt)
        end if ! jules
      end if ! slow_bl
    end if ! bl_um
#endif

    !=====================================================================
    ! Update the main fields and increments to pass out
    !=====================================================================
    if (theta_forcing_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_forcing))
    end if

    if (wind_forcing_done) then
      call invoke(inc_X_plus_Y(du, du_forcing))
    end if

    if (cloud == cloud_um .and. scheme == scheme_pc2) then
        liquid_fraction => cloud_fields%get_field('liquid_fraction')
        ice_fraction    => cloud_fields%get_field('ice_fraction')
        bulk_fraction   => cloud_fields%get_field('bulk_fraction')
    end if

    if (microphysics_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_mphys))
      call add_bundle(dmr_mphys, mr, mr, nummr)
      if (cloud == cloud_um .and. scheme == scheme_pc2) then
        call invoke(name="update_with_pc2_mphys_inc",              &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_mphys), &
                    inc_X_plus_Y(ice_fraction,    dcff_pc2_mphys), &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_mphys)  )
      end if
    end if

    if (radiation_done) then
      if (cloud == cloud_um .and. scheme == scheme_pc2) then
        call invoke(name="update_with_pc2_rad_inc",                &
                    inc_X_plus_Y(dtheta_rad,      dtheta_pc2_rad), &
                    inc_X_plus_Y(mr(imr_v),       dmv_pc2_rad),    &
                    inc_X_plus_Y(mr(imr_cl),      dmcl_pc2_rad),   &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_rad),   &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_rad)    )
      end if
      call invoke(inc_X_plus_Y(dtheta, dtheta_rad))
    end if

    if (spectral_gwd_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_spectral_gwd), &
                  inc_X_plus_Y(du, du_tot_spectral_gwd))
    end if

    if (orographic_drag_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_orographic_drag), &
                  inc_X_plus_Y(du, du_tot_orographic_drag))
    end if

    if (methox_done) then
      call invoke(inc_X_plus_Y(mr(imr_v), dmv_methox))
    end if

    if (boundary_layer_done) then
      call invoke(inc_X_plus_Y(du, du_bl), &
                  inc_X_plus_Y(dtheta, dtheta_bl) )
    end if

#ifdef UM_PHYSICS
    !--------------------------------------------------------------------
    ! PC2 checking of current state and preparation for advection
    !--------------------------------------------------------------------
    if (cloud == cloud_um .and. scheme == scheme_pc2) then

      ! Make a copy of exner to be advected
      departure_exner_wth => cloud_fields%get_field('departure_exner_wth')
      call invoke( setval_X(departure_exner_wth,exner_in_wth) )

      if (microphysics_done .or. radiation_done) then

        ! Construct the latest estimate of theta and call PC2 checks with
        ! this and the latest cloud and mr fields
        call theta%copy_field(theta_updated)
        call invoke(name="estimate_theta_at_end_of_slow_before_check", &
                    inc_X_plus_Y(theta_updated,dtheta) )
        call pc2_checks_alg( mr,                & ! Current state IN
                             theta_updated,     & ! Current state IN
                             derived_fields,    & ! Current state IN
                             cloud_fields,      & ! Current state IN
                             dtheta_pc2_checks, & ! Increments OUT
                             dmv_pc2_checks,    & ! Increments OUT
                             dmcl_pc2_checks,   & ! Increments OUT
                             dmcf_pc2_checks,   & ! Increments OUT
                             dcfl_pc2_checks,   & ! Increments OUT
                             dcff_pc2_checks,   & ! Increments OUT
                             dbcf_pc2_checks)     ! Increments OUT

        ! Update all fields and the theta increment again
        call invoke(name="update_after_pc2_checks",                   &
                    inc_X_plus_Y(dtheta,          dtheta_pc2_checks), &
                    inc_X_plus_Y(mr(imr_v),       dmv_pc2_checks),    &
                    inc_X_plus_Y(mr(imr_cl),      dmcl_pc2_checks),   &
                    inc_X_plus_Y(mr(imr_ci),      dmcf_pc2_checks),   &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_checks),   &
                    inc_X_plus_Y(ice_fraction,    dcff_pc2_checks),   &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_checks)    )
      end if ! (microphysics_done .or. radiation_done))

    end if ! (scheme == scheme_pc2)
#endif

    call print_field_stats_alg(dtheta, LOG_LEVEL_INFO, printmin=-20.0_r_def, &
                               printmax=20.0_r_def, name='dtheta slow')

    if (use_moisture) then
      do i_mr = 1, nummr
        call invoke( enforce_lower_bound_kernel_type (mr(i_mr), 0.0_r_def) )
      end do
      if (write_conservation_diag) &
        call moisture_conservation_alg(clock%get_step(), rho, mr, 'After slow')
    end if

    if ( subroutine_timers ) call timer("slow_physics")

  end subroutine slow_physics

end module slow_physics_alg_mod
