!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Calls to the slow physics schemes
module slow_physics_alg_mod

  use section_choice_config_mod, only: aerosol,                                &
                                       aerosol_um,                             &
                                       boundary_layer,                         &
                                       boundary_layer_um,                      &
                                       microphysics,                           &
                                       microphysics_um,                        &
                                       orographic_drag,                        &
                                       orographic_drag_um,                     &
                                       radiation,                              &
                                       radiation_socrates,                     &
                                       spectral_gwd,                           &
                                       spectral_gwd_um

  use constants_mod,    only: i_def,r_def
  use log_mod,          only: log_event,                         &
                              LOG_LEVEL_WARNING, LOG_LEVEL_INFO, &
                              LOG_LEVEL_ERROR

  use physics_config_mod, only: heldsuarez_thermo_placement,                   &
                                heldsuarez_wind_placement,                     &
                                microphysics_placement,                        &
                                microphysics_placement_slow,                   &
                                orographic_drag_placement,                     &
                                orographic_drag_placement_slow,                &
                                radiation_placement,                           &
                                radiation_placement_slow,                      &
                                spectral_gwd_placement,                        &
                                spectral_gwd_placement_slow
  use cloud_config_mod,   only: scheme,                      &
                                scheme_pc2

  ! PsyKAl PSYClone kernels
  use held_suarez_fv_kernel_mod,      only: held_suarez_fv_kernel_type
  use held_suarez_fv_wind_kernel_mod, only: held_suarez_fv_wind_kernel_type

  ! Derived Types
  use field_mod,                 only: field_type
  use field_collection_mod,      only: field_collection_type
  use function_space_collection_mod, only: function_space_collection
  use function_space_mod,            only: function_space_type

  ! Moisture species
  use mr_indices_mod,            only: nummr, imr_v, imr_cl, imr_ci
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type

  use fs_continuity_mod,         only: W2, W3

  use runtime_constants_mod,     only: get_rmultiplicity, &
                                       get_da_at_w2

  use field_bundle_mod,          only: clone_bundle, set_bundle_scalar,  &
                                       add_bundle

  use formulation_config_mod,    only: use_moisture

  use io_config_mod,             only: subroutine_timers
  use timer_mod,                 only: timer


#ifdef UM_PHYSICS
  use glomap_aerosol_alg_mod,    only: glomap_aerosol_alg_step
  use mphys_alg_mod,             only: mphys_alg_step
  use illuminate_alg_mod,        only: illuminate_alg_step
  use rad_tile_alg_mod,          only: rad_tile_alg_step
  use radiation_alg_mod,         only: radiation_alg_step
  use pc2_rad_response_alg_mod,  only: pc2_rad_response_alg_step
  use spectral_gwd_alg_mod,      only: spectral_gwd_alg_step
  use orographic_drag_alg_mod,   only: orographic_drag_alg_step
  use bl_exp_alg_mod,            only: bl_exp_alg_step
  use pc2_checks_alg_mod,        only: pc2_checks_alg_step

  use aerosol_config_mod,        only: c_aerosol,                              &
                                       c_aerosol_glomap_mode_climatology
  use radiation_config_mod,      only: l_planet_grey_surface
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          before the outer loop of the solver
  !> @param[in,out] du                     Increment to wind field
  !> @param[in,out] dtheta                 Increment to theta field
  !> @param[in,out] mr                     Mixing ratios to be updated
  !> @param[in,out] visc_m                 Smagorinsky momentum diffusion coef
  !> @param[in,out] visc_h                 Smagorinsky heat diffusion coef
  !> @param[in]     theta                  Theta field
  !> @param[in]     rho                    Rho on w3 space
  !> @param[in]     exner                  Exner pressure on w3 space
  !> @param[in]     mr_n                   Mixing ratios at start of timestep
  !> @param[in]     derived_fields         Group of derived fields
  !> @param[in,out] radiation_fields       Fields for radiation scheme
  !> @param[in,out] microphysics_fields    Fields for mphys scheme
  !> @param[in]     orography_fields       Fields for orog drag scheme
  !> @param[in,out] turbulence_fields      Fields for turbulence scheme
  !> @param[in,out] convection_fields      Fields for convection scheme
  !> @param[in,out] cloud_fields           Fields for cloud scheme
  !> @param[in,out] surface_fields         Fields for surface scheme
  !> @param[in,out] soil_fields            Fields for soil hydrology scheme
  !> @param[in,out] snow_fields            Fields for snow scheme
  !> @param[in,out] aerosol_fields         Fields for aerosol scheme
  !> @param[in]     dA                     Areas of faces
  !> @param[in]     height_w3              Height in w3
  !> @param[in]     height_wth             Height in wth
  !> @param[in]     chi                    Coordinate array
  !> @param[in]     delta                  Edge length on wtheta points
  !> @param[in]     max_diff_smag          Maximum diffusion coef allowed
  !> @param[in]     timestep               Model timestep number
  !> @param[in]     twod_mesh_id           Identifier given to current 2d mesh
  subroutine slow_physics(du, dtheta, mr, visc_m, visc_h,                      &
                          theta, rho, exner, mr_n, derived_fields,             &
                          radiation_fields, microphysics_fields,               &
                          orography_fields, turbulence_fields,                 &
                          convection_fields, cloud_fields, surface_fields,     &
                          soil_fields, snow_fields, aerosol_fields, dA,        &
                          height_w3, height_wth, chi, delta, max_diff_smag,    &
                          timestep, twod_mesh_id )

    implicit none

    ! Fields
    type( field_type ), intent( inout ) :: du, dtheta, visc_m, visc_h
    type( field_type ), intent( inout ) :: mr(nummr) ! To be modified by physics
    type( field_type ), intent( in )    :: theta, rho, exner
    type( field_type ), intent( in )    :: delta, max_diff_smag

    ! Field bundles
    type( field_type ), intent( in )    :: mr_n(nummr) ! Start of timestep
                                                       ! Do not alter

    ! Field groups
    type( field_collection_type ), intent(in)    :: derived_fields
    type( field_collection_type ), intent(inout) :: radiation_fields
    type( field_collection_type ), intent(inout) :: microphysics_fields
    type( field_collection_type ), intent(in)    :: orography_fields
    type( field_collection_type ), intent(inout) :: turbulence_fields
    type( field_collection_type ), intent(inout) :: convection_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: surface_fields
    type( field_collection_type ), intent(inout) :: soil_fields
    type( field_collection_type ), intent(inout) :: snow_fields
    type( field_collection_type ), intent(inout) :: aerosol_fields

    ! Coordinate fields
    type( field_type ), intent( in )    :: dA, height_w3, height_wth
    type( field_type ), intent( in )    :: chi(3)

    integer, intent(in) :: twod_mesh_id

    ! Timestep value
    integer, intent(in) :: timestep

    ! Local fields (should be created at initialization,
    !               but done here for the time being)
    type( field_type ) :: dtheta_hs, dtheta_rad, dtheta_mphys
    type( field_type ) :: du_hs
    type( field_type ) :: dmr_mphys(nummr)
    type( field_type ) :: du_tot_spectral_gwd, dtheta_spectral_gwd
    type( field_type ) :: du_tot_orographic_drag, dtheta_orographic_drag
    type( field_type ) :: tile_lw_albedo
    type( field_type ) :: tile_sw_diffuse_albedo
    type( field_type ) :: tile_sw_direct_albedo

    type( field_type ), pointer :: w2_rmultiplicity => null() ! 1/multiplicity of w2

    ! pointers to vector spaces
    type(function_space_type), pointer :: vector_space => null()

    ! Temporary field to unpack from field collection
    type( field_type ), pointer :: u_physics => null()
    type( field_type ), pointer :: exner_in_wth => null()

    ! Each column of a higher-order discontinuous field will be used to
    ! represent multi-dimensional quantities. Set parameters for the order
    ! required:
    integer(i_def) :: alb_order = 4 ! Enough space for 125 spectral tiles
                                    ! (spectral bands * surface tiles)
    integer(i_def) :: i_mr

    !Flags to indicate completed actions
    logical :: held_suarez_thermo_done ! Flag to indicate that held_suarez has been calculated
    logical :: held_suarez_wind_done ! Flag to indicate that held_suarez has been calculated
    logical :: microphysics_done ! Flag to indicate that microphysics has been calculated
    logical :: radiation_done ! Flag to indicate that radiation has been calculated
    logical :: spectral_gwd_done ! Flag to indicate that spectral gravity wave drag has been calculated
    logical :: orographic_drag_done ! Flag to indicate that orographic drag has been calculated

    ! Fields required by PC2
    type( field_type ), pointer :: liquid_fraction => null()
    type( field_type ), pointer :: ice_fraction    => null()
    type( field_type ), pointer :: bulk_fraction   => null()

    ! Increments to fields as a response to PC2 processes
    ! N.B. For microphys:
    type( field_type ) :: dcfl_pc2_mphys
    type( field_type ) :: dcff_pc2_mphys
    type( field_type ) :: dbcf_pc2_mphys
    ! N.B. For radiation:
    type( field_type ) :: dtheta_pc2_rad
    type( field_type ) :: dqv_pc2_rad
    type( field_type ) :: dqcl_pc2_rad
    type( field_type ) :: dcfl_pc2_rad
    type( field_type ) :: dbcf_pc2_rad
    ! N.B. For PC2 checks:
    type( field_type ) :: dtheta_pc2_checks
    type( field_type ) :: dqv_pc2_checks
    type( field_type ) :: dqcl_pc2_checks
    type( field_type ) :: dqcf_pc2_checks
    type( field_type ) :: dcfl_pc2_checks
    type( field_type ) :: dcff_pc2_checks
    type( field_type ) :: dbcf_pc2_checks

    ! Temporary, partially updated theta after some, but not all, PC2 processes
    type( field_type ) :: tmp_theta

    if ( subroutine_timers ) call timer("slow_physics")

    w2_rmultiplicity => get_rmultiplicity( W2 ) ! 1/multiplicity of w2

    held_suarez_thermo_done=.false.
    held_suarez_wind_done=.false.
    microphysics_done=.false.
    radiation_done=.false.
    spectral_gwd_done=.false.
    orographic_drag_done=.false.

    ! Some unpacking
    u_physics => derived_fields%get_field('u_physics')
    exner_in_wth => derived_fields%get_field('exner_in_wth')

    if (heldsuarez_thermo_placement < 0)then
      call dtheta_hs%initialise( vector_space = theta%get_function_space() )
      call invoke( setval_c(dtheta_hs, 0.0_r_def) )
      call log_event( &
         'slow_physics: Running Held-Suarez theta forcing', &
         LOG_LEVEL_INFO )
      call invoke(held_suarez_fv_kernel_type(dtheta_hs, theta, exner_in_wth, chi))
      held_suarez_thermo_done=.true. ! We've done it, so need to collect this term later on
    end if

    if (heldsuarez_wind_placement < 0)then
      call du_hs%initialise( vector_space = u_physics%get_function_space() )
      call invoke( setval_c(du_hs, 0.0_r_def) )
      call log_event( &
         'slow_physics: Running Held-Suarez wind forcing', &
         LOG_LEVEL_INFO )
      call invoke(held_suarez_fv_wind_kernel_type(du_hs, u_physics, w2_rmultiplicity, &
         exner_in_wth, chi))
      held_suarez_wind_done=.true. ! We've done it, so need to collect this term later on
    end if

#ifdef UM_PHYSICS
    ! Later if aerosol_um .and. (microphysics_um .or. radiation_socrates)
    if ( ( aerosol == aerosol_um ) .and.                                       &
         ( microphysics == microphysics_um ) ) then
      ! Calculate CDNC field from GLOMAP-mode climatology fields
      if ( c_aerosol == c_aerosol_glomap_mode_climatology ) then

        call glomap_aerosol_alg_step ( aerosol_fields,                         &
                                       theta,                                  &
                                       exner_in_wth )

      end if
    end if

    if ( microphysics == microphysics_um .and. &
         microphysics_placement == microphysics_placement_slow) then
      if (use_moisture) then

        ! Algorithm which calls the UM microphysics scheme
        call log_event( 'slow_physics: Running Microphysics', LOG_LEVEL_INFO )

        call clone_bundle(mr, dmr_mphys, nummr)
        call set_bundle_scalar(0.0_r_def, dmr_mphys, nummr)

        call dtheta_mphys%initialise( vector_space = theta%get_function_space() )
        call dcfl_pc2_mphys%initialise( vector_space = theta%get_function_space() )
        call dcff_pc2_mphys%initialise( vector_space = theta%get_function_space() )
        call dbcf_pc2_mphys%initialise( vector_space = theta%get_function_space() )

        call mphys_alg_step( mr_n, theta, exner, height_w3, height_wth,     &
                             derived_fields, microphysics_fields,           &
                             cloud_fields, aerosol_fields,                  &
                             dmr_mphys, dtheta_mphys,                       &
                             dcfl_pc2_mphys, dcff_pc2_mphys, dbcf_pc2_mphys )

        ! N.B. Call to microphysics passes in mr_n, which is intent(in) and
        !      represents the start of the timestep value of the mixing
        !      ratios. The equivalent variable mr is just a copy of this and
        !      is passed into slow physics as intent(inout). Variable mr is
        !      then updated by microphysics and used to generate the slow
        !      physics increment.

        microphysics_done=.true. ! Microphysics completed

      else ! not use moisture
        ! throw an error: this is just plain daft and user has made a mistake.
        call log_event( &
        'slow_physics: Microphysics cannot be run without moisture. Please correct', &
         LOG_LEVEL_ERROR )
      end if ! use moisture

    end if   ! microphysics placement slow

    if (radiation == radiation_socrates .and. &
        radiation_placement == radiation_placement_slow) then
      call log_event( 'slow_physics: Running Radiation', LOG_LEVEL_INFO )
      call illuminate_alg_step(radiation_fields, timestep)

      ! Use a temporary treatment for multi-dimensional fields using
      ! higher-order fields
      vector_space=>function_space_collection%get_fs(twod_mesh_id,alb_order,W3)
      call tile_sw_direct_albedo%initialise(vector_space)
      call tile_sw_diffuse_albedo%initialise(vector_space)
      call tile_lw_albedo%initialise(vector_space)
      if (.not.l_planet_grey_surface) then
        call rad_tile_alg_step(tile_sw_direct_albedo, tile_sw_diffuse_albedo,  &
                               tile_lw_albedo, derived_fields,                 &
                               radiation_fields, orography_fields,             &
                               surface_fields, soil_fields, snow_fields,       &
                               height_w3)
      end if

      call dtheta_rad%initialise( vector_space = theta%get_function_space() )
      call radiation_alg_step(dtheta_rad, theta, exner, mr_n,                  &
                              derived_fields, radiation_fields, cloud_fields,  &
                              surface_fields, height_w3, height_wth, timestep, &
                              tile_sw_direct_albedo, tile_sw_diffuse_albedo,   &
                              tile_lw_albedo)
      radiation_done=.true.
      call dtheta_rad%log_minmax(LOG_LEVEL_INFO, 'slow physics: dtheta_rad')

      if (scheme == scheme_pc2) then

        ! PC2 code will be called with dtheta_rad as the only forcing.

        call pc2_rad_response_alg_step(                 & ! Current state
                                        mr_n,           & ! IN
                                        theta,          & ! IN
                                        derived_fields, & ! IN
                                        cloud_fields,   & ! IN
                                                          ! Forcings
                                        dtheta_rad,     & ! IN
                                                          ! Responses
                                        dtheta_pc2_rad, & ! OUT
                                        dqv_pc2_rad,    & ! OUT
                                        dqcl_pc2_rad,   & ! OUT
                                        dcfl_pc2_rad,   & ! OUT
                                        dbcf_pc2_rad )    ! OUT

      end if ! (scheme == scheme_pc2)

    end if

    ! Algorithm which calls the UM spectral gravity wave drag scheme
    if (spectral_gwd == spectral_gwd_um .and. &
        spectral_gwd_placement == spectral_gwd_placement_slow) then
      call log_event( 'slow_physics: Running spectral gravity wave drag', LOG_LEVEL_INFO )
      ! copy field properties
      call du%copy_field_properties(du_tot_spectral_gwd)
      call dtheta%copy_field_properties(dtheta_spectral_gwd)
      call spectral_gwd_alg_step(du_tot_spectral_gwd, &
                                 dtheta_spectral_gwd, &
                                 derived_fields,      &
                                 microphysics_fields, &
                                 convection_fields,   &
                                 theta,               &
                                 height_w3,           &
                                 height_wth)
      spectral_gwd_done=.true.
    end if

    ! Algorithm which calls the UM orographic gravity wave and blocking drag scheme
    if (orographic_drag == orographic_drag_um .and. &
        orographic_drag_placement == orographic_drag_placement_slow) then
      call log_event( 'slow_physics: Running Orographic drag', LOG_LEVEL_INFO )
      call du%copy_field_properties(du_tot_orographic_drag)
      call dtheta%copy_field_properties(dtheta_orographic_drag)
      call orographic_drag_alg_step(du_tot_orographic_drag, &
                                    dtheta_orographic_drag, &
                                    derived_fields,         &
                                    orography_fields,       &
                                    theta,                  &
                                    height_w3,              &
                                    height_wth)
      orographic_drag_done=.true.
    end if

    if (boundary_layer == boundary_layer_um ) then
      ! Algorithm that calls the UM explicit Boundary Layer scheme
      call log_event( 'slow_physics: Running explicit Boundary layer', LOG_LEVEL_INFO )
      call bl_exp_alg_step(visc_m, visc_h, theta, rho, exner, mr_n,           &
                           derived_fields, radiation_fields,                  &
                           microphysics_fields, orography_fields,             &
                           turbulence_fields, convection_fields, cloud_fields,&
                           surface_fields, soil_fields, snow_fields,          &
                           height_w3, height_wth, delta, max_diff_smag)
    end if
#endif

    !=====================================
    ! collect individual terms in parallel
    !=====================================
    if (held_suarez_thermo_done)then
      call invoke(inc_X_plus_Y(dtheta, dtheta_hs))
    end if

    if (held_suarez_wind_done) then
      call invoke(inc_X_times_Y(du_hs, dA), &
                  inc_X_plus_Y(du, du_hs)   )
    end if

    if (scheme == scheme_pc2) then
        liquid_fraction => cloud_fields%get_field('liquid_fraction')
        ice_fraction    => cloud_fields%get_field('ice_fraction')
        bulk_fraction   => cloud_fields%get_field('bulk_fraction')
    end if

    if (microphysics_done) then
      if (scheme == scheme_pc2) then
        ! Do microphysics updates to cloud fraction fields.
        call invoke(name="update_with_pc2_mphys_inc",              &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_mphys), &
                    inc_X_plus_Y(ice_fraction,    dcff_pc2_mphys), &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_mphys)  )
      end if
      call invoke(inc_X_plus_Y(dtheta, dtheta_mphys))
      call add_bundle(dmr_mphys, mr, mr, nummr)
    end if

    if (radiation_done) then
      if (scheme == scheme_pc2) then
        call invoke(name="update_with_pc2_rad_inc",                &
                    inc_X_plus_Y(dtheta_rad,      dtheta_pc2_rad), &
                    inc_X_plus_Y(mr(imr_v),       dqv_pc2_rad),    &
                    inc_X_plus_Y(mr(imr_cl),      dqcl_pc2_rad),   &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_rad),   &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_rad)    )
      end if
      call invoke(inc_X_plus_Y(dtheta, dtheta_rad))
    end if

    if (spectral_gwd_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_spectral_gwd), &
                  inc_X_plus_Y(du, du_tot_spectral_gwd))
    end if

    if (orographic_drag_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_orographic_drag), &
                  inc_X_plus_Y(du, du_tot_orographic_drag))
    end if

#ifdef UM_PHYSICS
    if (scheme == scheme_pc2 .and. (microphysics_done .or. radiation_done)) then
      ! Having added mr and cloud_fields increments for microphys and/or radiation
      ! (calculated in parallel from start of timestep values),
      ! now need to check whether there are any inconsistencies.
      !
      ! Estimate what theta would be by now
      ! based on value at start of timestep...
      call theta%copy_field(tmp_theta)

      ! ... plus all dtheta increments so far
      ! (microphys, radiation and pc2 response to radiation)
      call invoke(name="estimate_theta_at_end_of_slow_before_check", &
                  inc_X_plus_Y(tmp_theta,dtheta) )

      ! Call pc2_checks with current updated mr (not mr_n) and tmp_theta
      ! cloud_fields (liquid, ice, bulk cloud fractions) has also
      ! been updated since start of timestep.
      call pc2_checks_alg_step( mr,                & ! Current state IN
                                tmp_theta,         & ! Current state IN
                                derived_fields,    & ! Current state IN
                                cloud_fields,      & ! Current state IN
                                dtheta_pc2_checks, & ! Increments OUT
                                dqv_pc2_checks,    & ! Increments OUT
                                dqcl_pc2_checks,   & ! Increments OUT
                                dqcf_pc2_checks,   & ! Increments OUT
                                dcfl_pc2_checks,   & ! Increments OUT
                                dcff_pc2_checks,   & ! Increments OUT
                                dbcf_pc2_checks)     ! Increments OUT

      ! Update all fields and the theta increment again
      call invoke(name="update_after_pc2_checks",                   &
                  inc_X_plus_Y(dtheta,          dtheta_pc2_checks), &
                  inc_X_plus_Y(mr(imr_v),       dqv_pc2_checks),    &
                  inc_X_plus_Y(mr(imr_cl),      dqcl_pc2_checks),   &
                  inc_X_plus_Y(mr(imr_ci),      dqcf_pc2_checks),   &
                  inc_X_plus_Y(liquid_fraction, dcfl_pc2_checks),   &
                  inc_X_plus_Y(ice_fraction,    dcff_pc2_checks),   &
                  inc_X_plus_Y(bulk_fraction,   dbcf_pc2_checks)    )

     end if ! (cloud_um_scheme == cloud_um_scheme_pc2)
#endif

    call dtheta%log_minmax(LOG_LEVEL_INFO, 'slow physics: dtheta' )
    call du%log_minmax(LOG_LEVEL_INFO, 'slow physics: du' )

    if (use_moisture) then
      do i_mr = 1, nummr
        call invoke( enforce_lower_bound_kernel_type (mr(i_mr), 0.0_r_def) )
      end do
    end if

    nullify( w2_rmultiplicity )

    if ( subroutine_timers ) call timer("slow_physics")

  end subroutine slow_physics

end module slow_physics_alg_mod
