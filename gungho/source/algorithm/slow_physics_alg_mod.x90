!-----------------------------------------------------------------------------
! (c) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief Calls to the slow physics schemes
module slow_physics_alg_mod

  use clock_mod,                 only: clock_type
  use cloud_config_mod,          only: scheme, scheme_pc2, cld_fsd_hill
  use constants_mod,             only: i_def, r_def
  use log_mod,                   only: LOG_LEVEL_INFO
  use physics_config_mod,        only: heldsuarez_thermo_placement,    &
                                       heldsuarez_wind_placement,      &
                                       microphysics_placement,         &
                                       microphysics_placement_slow,    &
                                       orographic_drag_placement,      &
                                       orographic_drag_placement_slow, &
                                       radiation_placement,            &
                                       radiation_placement_slow,       &
                                       spectral_gwd_placement,         &
                                       spectral_gwd_placement_slow
  use section_choice_config_mod, only: aerosol, aerosol_um,                 &
                                       boundary_layer, boundary_layer_um,   &
                                       microphysics, microphysics_um,       &
                                       orographic_drag, orographic_drag_um, &
                                       radiation, radiation_socrates,       &
                                       spectral_gwd, spectral_gwd_um,       &
                                       surface, surface_jules,              &
                                       methane_oxidation
  ! Derived Types
  use field_mod,                 only: field_type
  use field_collection_mod,      only: field_collection_type
  use function_space_collection_mod, only: function_space_collection
  use function_space_mod,            only: function_space_type
  ! Moisture species
  use mr_indices_mod,            only: nummr, imr_v, imr_cl, imr_ci
  use enforce_lower_bound_kernel_mod, only: enforce_lower_bound_kernel_type
  use moisture_conservation_alg_mod,  only: moisture_conservation_alg
  use fs_continuity_mod,         only: W3, Wtheta
  use field_bundle_mod,          only: add_bundle
  use formulation_config_mod,    only: use_moisture
  use io_config_mod,             only: subroutine_timers,                    &
                                       write_conservation_diag
  use timer_mod,                 only: timer
  use held_suarez_alg_mod,       only: held_suarez_alg
  ! Physics schemes called
#ifdef UM_PHYSICS
  use glomap_aerosol_alg_mod,    only: glomap_aerosol_alg
  use mphys_alg_mod,             only: mphys_alg
  use illuminate_alg_mod,        only: illuminate_alg
  use rad_tile_alg_mod,          only: rad_tile_alg
  use radiation_alg_mod,         only: radiation_alg
  use pc2_rad_response_alg_mod,  only: pc2_rad_response_alg
  use spectral_gwd_alg_mod,      only: spectral_gwd_alg
  use orographic_drag_alg_mod,   only: orographic_drag_alg
  use bl_exp_alg_mod,            only: bl_exp_alg
  use pc2_checks_alg_mod,        only: pc2_checks_alg
  use methox_alg_mod,            only: methox_alg
  use aerosol_config_mod,        only: c_aerosol,                            &
                                       c_aerosol_glomap_mode_climatology
  use radiation_config_mod,      only: l_planet_grey_surface
  use ancil_info,                only: rad_nband
  use jules_control_init_mod,    only: sw_band_tile, lw_band_tile, n_land_tile
  use fsd_condensate_alg_mod,    only: fsd_condensate_alg
  use init_aerosol_fields_alg_mod, only: sw_band_mode, lw_band_mode, mode_dimen
#endif

  implicit none

contains

  !> @details Collection of procedures for subgrid physics that act
  !>          before the outer loop of the solver
  !> @param[in,out] du                     Increment to wind field
  !> @param[in,out] dtheta                 Increment to theta field
  !> @param[in,out] mr                     Mixing ratios to be updated
  !> @param[in,out] visc_m                 Smagorinsky momentum diffusion coef
  !> @param[in,out] visc_h                 Smagorinsky heat diffusion coef
  !> @param[in]     theta                  Theta field at start of timestep
  !> @param[in]     rho                    Rho on w3 space
  !> @param[in]     exner                  Exner pressure on w3 space
  !> @param[in]     mr_n                   Mixing ratios at start of timestep
  !> @param[in]     derived_fields         Group of derived fields
  !> @param[in,out] radiation_fields       Fields for radiation scheme
  !> @param[in,out] microphysics_fields    Fields for mphys scheme
  !> @param[in]     orography_fields       Fields for orog drag scheme
  !> @param[in,out] turbulence_fields      Fields for turbulence scheme
  !> @param[in,out] convection_fields      Fields for convection scheme
  !> @param[in,out] cloud_fields           Fields for cloud scheme
  !> @param[in,out] surface_fields         Fields for surface scheme
  !> @param[in,out] soil_fields            Fields for soil hydrology scheme
  !> @param[in,out] snow_fields            Fields for snow scheme
  !> @param[in,out] aerosol_fields         Fields for aerosol scheme
  !> @param[in]     clock                  Model time
  !> @param[in]     mesh_id                Identifier given to current mesh
  !> @param[in]     twod_mesh_id           Identifier given to current 2d mesh
  subroutine slow_physics(du, dtheta, mr, visc_m, visc_h,                      &
                          theta, rho, exner, mr_n, derived_fields,             &
                          radiation_fields, microphysics_fields,               &
                          orography_fields, turbulence_fields,                 &
                          convection_fields, cloud_fields, surface_fields,     &
                          soil_fields, snow_fields, aerosol_fields,            &
                          clock, mesh_id, twod_mesh_id )

    implicit none

    ! Fields
    type( field_type ), intent( inout ) :: du, dtheta, visc_m, visc_h
    type( field_type ), intent( in )    :: theta, rho, exner

    ! Field bundles
    type( field_type ), intent( inout ) :: mr(nummr)   ! Latest value, to update
    type( field_type ), intent( in )    :: mr_n(nummr) ! Start of timestep
                                                       ! Do not alter

    ! Field groups
    type( field_collection_type ), intent(inout) :: derived_fields
    type( field_collection_type ), intent(inout) :: radiation_fields
    type( field_collection_type ), intent(inout) :: microphysics_fields
    type( field_collection_type ), intent(in)    :: orography_fields
    type( field_collection_type ), intent(inout) :: turbulence_fields
    type( field_collection_type ), intent(inout) :: convection_fields
    type( field_collection_type ), intent(inout) :: cloud_fields
    type( field_collection_type ), intent(inout) :: surface_fields
    type( field_collection_type ), intent(inout) :: soil_fields
    type( field_collection_type ), intent(inout) :: snow_fields
    type( field_collection_type ), intent(inout) :: aerosol_fields

    integer, intent(in) :: mesh_id
    integer, intent(in) :: twod_mesh_id
    class(clock_type), intent(in) :: clock

    ! Local fields...
    ! ...for H-S physics
    type( field_type ) :: dtheta_hs, du_hs
    ! ...for microphysics
    type( field_type ) :: dtheta_mphys
    type( field_type ) :: dmr_mphys(nummr)
    type( field_type ) :: dcfl_pc2_mphys, dcff_pc2_mphys, dbcf_pc2_mphys
    ! ...for radiation
    type( field_type ) :: dtheta_rad, dtheta_pc2_rad
    type( field_type ) :: dqv_pc2_rad, dqcl_pc2_rad
    type( field_type ) :: dcfl_pc2_rad, dbcf_pc2_rad
#ifdef UM_PHYSICS
    type( field_type ) :: aer_mix_ratio
    type( field_type ) :: aer_sw_absorption, aer_sw_scattering, aer_sw_asymmetry
    type( field_type ) :: aer_lw_absorption, aer_lw_scattering, aer_lw_asymmetry
    type( field_type ) :: tile_lw_albedo
    type( field_type ) :: tile_sw_diffuse_albedo, tile_sw_direct_albedo
    type( field_type ) :: albedo_obs_scaling
#endif
    ! ...for spectral GWD
    type( field_type ) :: du_tot_spectral_gwd, dtheta_spectral_gwd
    ! ...for orog GWD
    type( field_type ) :: du_tot_orographic_drag, dtheta_orographic_drag
    ! ...for methane oxidation
    type( field_type ) :: dmv_methox
#ifdef UM_PHYSICS
    ! ...for PC2 checks
    type( field_type ) :: dtheta_pc2_checks, theta_updated
    type( field_type ) :: dqv_pc2_checks, dqcl_pc2_checks, dqcf_pc2_checks
    type( field_type ) :: dcfl_pc2_checks, dcff_pc2_checks, dbcf_pc2_checks
    ! ...for fractional standard deviation cloud (microphysics and radiation)
    type( field_type ) :: f_arr

    ! pointers to vector spaces
    type(function_space_type), pointer :: vector_space => null()

    ! Temporary fields to unpack from field collection
    type( field_type ), pointer :: departure_exner_wth => null()
#endif
    type( field_type ), pointer :: exner_in_wth => null()
    ! Fields required by PC2
    type( field_type ), pointer :: liquid_fraction => null()
    type( field_type ), pointer :: ice_fraction    => null()
    type( field_type ), pointer :: bulk_fraction   => null()

    integer(i_def) :: i_mr

    ! Flags to indicate whether scheme has run and increments need adding
    logical :: held_suarez_thermo_done
    logical :: held_suarez_wind_done
    logical :: microphysics_done
    logical :: radiation_done
    logical :: spectral_gwd_done
    logical :: orographic_drag_done
    logical :: methox_done

    if ( subroutine_timers ) call timer("slow_physics")

    !--------------------------------------------------------------------
    ! Initialisation of fields and flags
    !--------------------------------------------------------------------
    call invoke( setval_c(dtheta, 0.0_r_def), &
                 setval_c(du, 0.0_r_def) )
    exner_in_wth => derived_fields%get_field('exner_in_wth')
    held_suarez_thermo_done = .false.
    held_suarez_wind_done   = .false.
    microphysics_done       = .false.
    radiation_done          = .false.
    spectral_gwd_done       = .false.
    orographic_drag_done    = .false.
    methox_done             = .false.

    !--------------------------------------------------------------------
    ! Held-Suarez simple physics codes
    !--------------------------------------------------------------------
    if ( heldsuarez_thermo_placement < 0 .OR. &
         heldsuarez_wind_placement < 0 ) then
      call held_suarez_alg(derived_fields, theta, exner_in_wth,          &
                           dtheta_hs, du_hs,                             &
                           held_suarez_thermo_done, held_suarez_wind_done)
    end if

#ifdef UM_PHYSICS
    !--------------------------------------------------------------------
    ! Fractional standard deviation (FSD) of cloud condensate
    !--------------------------------------------------------------------
    vector_space => function_space_collection%get_fs( mesh_id, 0, Wtheta, 3)
    call f_arr%initialise(vector_space)
    if ( cld_fsd_hill ) then
      call fsd_condensate_alg( f_arr, cloud_fields, convection_fields )
    end if

    !--------------------------------------------------------------------
    ! Glomap mode aerosol climatologies
    !--------------------------------------------------------------------
    vector_space=>function_space_collection%get_fs(mesh_id,0,Wtheta,mode_dimen)
    call aer_mix_ratio%initialise(vector_space)
    vector_space=>function_space_collection%get_fs(mesh_id,0,Wtheta,sw_band_mode)
    call aer_sw_absorption%initialise(vector_space)
    call aer_sw_scattering%initialise(vector_space)
    call aer_sw_asymmetry%initialise(vector_space)
    vector_space=>function_space_collection%get_fs(mesh_id,0,Wtheta,lw_band_mode)
    call aer_lw_absorption%initialise(vector_space)
    call aer_lw_scattering%initialise(vector_space)
    call aer_lw_asymmetry%initialise(vector_space)
    if ( ( aerosol == aerosol_um ) .and.                                  &
         ( microphysics == microphysics_um .or.                           &
           radiation == radiation_socrates ) ) then
      if ( c_aerosol == c_aerosol_glomap_mode_climatology ) then
        call glomap_aerosol_alg ( aerosol_fields,                         &
                                  theta,                                  &
                                  exner_in_wth )
      end if
    end if

    !--------------------------------------------------------------------
    ! UM microphysics scheme
    !--------------------------------------------------------------------
    if ( microphysics == microphysics_um .and. &
         microphysics_placement == microphysics_placement_slow) then
      call mphys_alg( mr_n, theta, rho, derived_fields, microphysics_fields, &
                      cloud_fields, aerosol_fields, f_arr, dmr_mphys,        &
                      dtheta_mphys, dcfl_pc2_mphys, dcff_pc2_mphys,          &
                      dbcf_pc2_mphys )
      microphysics_done=.true. ! Collect this increment later on
    end if

    !--------------------------------------------------------------------
    ! Socrates radiation scheme
    !--------------------------------------------------------------------
    vector_space=>function_space_collection%get_fs(twod_mesh_id,0,W3, &
                                                   n_land_tile*rad_nband)
    call albedo_obs_scaling%initialise(vector_space)

    if (radiation == radiation_socrates .and. &
        radiation_placement == radiation_placement_slow) then
       call illuminate_alg( radiation_fields, clock%get_step() )

      vector_space=>function_space_collection%get_fs(twod_mesh_id,0,W3,sw_band_tile)
      call tile_sw_direct_albedo%initialise(vector_space)
      call tile_sw_diffuse_albedo%initialise(vector_space)
      vector_space=>function_space_collection%get_fs(twod_mesh_id,0,W3,lw_band_tile)
      call tile_lw_albedo%initialise(vector_space)
      if (surface == surface_jules .and. .not.l_planet_grey_surface) then
        call rad_tile_alg(tile_sw_direct_albedo, tile_sw_diffuse_albedo,  &
                          tile_lw_albedo, derived_fields,                 &
                          radiation_fields, orography_fields,             &
                          surface_fields, soil_fields, snow_fields,       &
                          albedo_obs_scaling)
      end if

      call radiation_alg( dtheta_rad, theta, exner, mr_n,                    &
                          derived_fields, radiation_fields, cloud_fields,    &
                          convection_fields, aerosol_fields, surface_fields, &
                          clock%get_step(),                                  &
                          tile_sw_direct_albedo, tile_sw_diffuse_albedo,     &
                          tile_lw_albedo, aer_mix_ratio,                     &
                          aer_sw_absorption, aer_lw_absorption,              &
                          aer_sw_scattering, aer_lw_scattering,              &
                          aer_sw_asymmetry,  aer_lw_asymmetry )
      radiation_done=.true. ! Collect this increment later on

      if (scheme == scheme_pc2) then
        ! PC2 code will be called with dtheta_rad as the only forcing.
        call pc2_rad_response_alg(                 & ! Current state
                                   mr_n,           & ! IN
                                   theta,          & ! IN
                                   derived_fields, & ! IN
                                   cloud_fields,   & ! IN
                                                     ! Forcings
                                   dtheta_rad,     & ! IN
                                                     ! Responses
                                   dtheta_pc2_rad, & ! OUT
                                   dqv_pc2_rad,    & ! OUT
                                   dqcl_pc2_rad,   & ! OUT
                                   dcfl_pc2_rad,   & ! OUT
                                   dbcf_pc2_rad )    ! OUT
      end if ! (scheme == scheme_pc2)

    end if

    !--------------------------------------------------------------------
    ! UM spectral gravity wave drag scheme
    !--------------------------------------------------------------------
    if (spectral_gwd == spectral_gwd_um .and. &
        spectral_gwd_placement == spectral_gwd_placement_slow) then
      call du%copy_field_properties(du_tot_spectral_gwd)
      call dtheta%copy_field_properties(dtheta_spectral_gwd)
      call spectral_gwd_alg(du_tot_spectral_gwd, &
                            dtheta_spectral_gwd, &
                            derived_fields,      &
                            microphysics_fields, &
                            convection_fields,   &
                            theta)
      spectral_gwd_done=.true. ! Collect this increment later on
    end if

    !--------------------------------------------------------------------
    ! UM orographic drag scheme
    !--------------------------------------------------------------------
    if (orographic_drag == orographic_drag_um .and. &
        orographic_drag_placement == orographic_drag_placement_slow) then
      call du%copy_field_properties(du_tot_orographic_drag)
      call dtheta%copy_field_properties(dtheta_orographic_drag)
      call orographic_drag_alg(du_tot_orographic_drag, &
                               dtheta_orographic_drag, &
                               derived_fields,         &
                               orography_fields,       &
                               theta,                  &
                               mr_n)
      orographic_drag_done=.true. ! Collect this increment later on
    end if

    ! Call methane oxidation code
    if (methane_oxidation) then
      call methox_alg(dmv_methox, mr_n, clock)
      methox_done = .true.
    end if

    !--------------------------------------------------------------------
    ! UM explicit boundary layer and Jules surface schemes
    !--------------------------------------------------------------------
    if (boundary_layer == boundary_layer_um ) then
      call bl_exp_alg(visc_m, visc_h, theta, rho, exner, mr_n,           &
                      derived_fields, radiation_fields,                  &
                      microphysics_fields, orography_fields,             &
                      turbulence_fields, convection_fields, cloud_fields,&
                      surface_fields, soil_fields, snow_fields,          &
                      albedo_obs_scaling)
    end if
#endif

    !=====================================================================
    ! Update the main fields and increments to pass out
    !=====================================================================
    if (held_suarez_thermo_done)then
      call invoke(inc_X_plus_Y(dtheta, dtheta_hs))
    end if

    if (held_suarez_wind_done) then
      call invoke(inc_X_plus_Y(du, du_hs))
    end if

    if (scheme == scheme_pc2) then
        liquid_fraction => cloud_fields%get_field('liquid_fraction')
        ice_fraction    => cloud_fields%get_field('ice_fraction')
        bulk_fraction   => cloud_fields%get_field('bulk_fraction')
    end if

    if (microphysics_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_mphys))
      call add_bundle(dmr_mphys, mr, mr, nummr)
      if (scheme == scheme_pc2) then
        call invoke(name="update_with_pc2_mphys_inc",              &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_mphys), &
                    inc_X_plus_Y(ice_fraction,    dcff_pc2_mphys), &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_mphys)  )
      end if
    end if

    if (radiation_done) then
      if (scheme == scheme_pc2) then
        call invoke(name="update_with_pc2_rad_inc",                &
                    inc_X_plus_Y(dtheta_rad,      dtheta_pc2_rad), &
                    inc_X_plus_Y(mr(imr_v),       dqv_pc2_rad),    &
                    inc_X_plus_Y(mr(imr_cl),      dqcl_pc2_rad),   &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_rad),   &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_rad)    )
      end if
      call invoke(inc_X_plus_Y(dtheta, dtheta_rad))
    end if

    if (spectral_gwd_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_spectral_gwd), &
                  inc_X_plus_Y(du, du_tot_spectral_gwd))
    end if

    if (orographic_drag_done) then
      call invoke(inc_X_plus_Y(dtheta, dtheta_orographic_drag), &
                  inc_X_plus_Y(du, du_tot_orographic_drag))
    end if

    if (methox_done) then
      call invoke(inc_X_plus_Y(mr(imr_v), dmv_methox))
    end if

#ifdef UM_PHYSICS
    !--------------------------------------------------------------------
    ! PC2 checking of current state and preparation for advection
    !--------------------------------------------------------------------
    if (scheme == scheme_pc2) then

      ! Make a copy of exner to be advected
      departure_exner_wth => cloud_fields%get_field('departure_exner_wth')
      call invoke( setval_X(departure_exner_wth,exner_in_wth) )

      if (microphysics_done .or. radiation_done) then

        ! Construct the latest estimate of theta and call PC2 checks with
        ! this and the latest cloud and mr fields
        call theta%copy_field(theta_updated)
        call invoke(name="estimate_theta_at_end_of_slow_before_check", &
                    inc_X_plus_Y(theta_updated,dtheta) )
        call pc2_checks_alg( mr,                & ! Current state IN
                             theta_updated,     & ! Current state IN
                             derived_fields,    & ! Current state IN
                             cloud_fields,      & ! Current state IN
                             dtheta_pc2_checks, & ! Increments OUT
                             dqv_pc2_checks,    & ! Increments OUT
                             dqcl_pc2_checks,   & ! Increments OUT
                             dqcf_pc2_checks,   & ! Increments OUT
                             dcfl_pc2_checks,   & ! Increments OUT
                             dcff_pc2_checks,   & ! Increments OUT
                             dbcf_pc2_checks)     ! Increments OUT

        ! Update all fields and the theta increment again
        call invoke(name="update_after_pc2_checks",                   &
                    inc_X_plus_Y(dtheta,          dtheta_pc2_checks), &
                    inc_X_plus_Y(mr(imr_v),       dqv_pc2_checks),    &
                    inc_X_plus_Y(mr(imr_cl),      dqcl_pc2_checks),   &
                    inc_X_plus_Y(mr(imr_ci),      dqcf_pc2_checks),   &
                    inc_X_plus_Y(liquid_fraction, dcfl_pc2_checks),   &
                    inc_X_plus_Y(ice_fraction,    dcff_pc2_checks),   &
                    inc_X_plus_Y(bulk_fraction,   dbcf_pc2_checks)    )
      end if ! (microphysics_done .or. radiation_done))

    end if ! (scheme == scheme_pc2)
#endif

    call dtheta%log_minmax(LOG_LEVEL_INFO, 'slow physics: dtheta' )
    call du%log_minmax(LOG_LEVEL_INFO, 'slow physics: du' )

    if (use_moisture) then
      do i_mr = 1, nummr
        call invoke( enforce_lower_bound_kernel_type (mr(i_mr), 0.0_r_def) )
      end do
      if (write_conservation_diag) &
        call moisture_conservation_alg(clock%get_step(), rho, mr, 'After slow')
    end if

    if ( subroutine_timers ) call timer("slow_physics")

  end subroutine slow_physics

end module slow_physics_alg_mod
