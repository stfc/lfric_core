!-------------------------------------------------------------------------------
! (C) Crown copyright 2017 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-------------------------------------------------------------------------------

!>@brief A wrapper for mappings of FE fields to physics fields
module physics_mappings_alg_mod

  use constants_mod,                         only: r_def, i_def
  use field_mod,                             only: field_type
  use finite_element_config_mod,             only: nqp_exact
  use fs_continuity_mod,                     only: W3, WTHETA
  use function_space_mod,                    only: function_space_type
  use function_space_collection_mod,         only: function_space_collection
  use galerkin_projection_algorithm_mod,     only: galerkin_projection_algorithm
  use geometric_constants_mod,               only: get_height
  use log_mod,                               only: LOG_LEVEL_ERROR, log_event, &
                                                   LOG_LEVEL_DEBUG
  use quadrature_xyoz_mod,                   only: quadrature_xyoz_type
  use quadrature_rule_gaussian_mod,          only: quadrature_rule_gaussian_type
  use physics_config_mod,                    only: sample_physics_scalars, &
                                                   sample_physics_winds
  use sample_w3_to_wtheta_kernel_mod,        only: sample_w3_to_wtheta_kernel_type
  use sample_wtheta_to_w3_kernel_mod,        only: sample_wtheta_to_w3_kernel_type

  implicit none

  private

  public :: map_physics_scalars, map_physics_winds

contains

  !> @details An algorithm to map native FE scalar fields to the appropriate
  !>          location for the FD physics codes
  !> @param[in,out] target_field Field in the target space
  !> @param[in]     source_field Field in the source (native) space
  subroutine map_physics_scalars(target_field, source_field)

    implicit none

    ! Prognostic fields
    type( field_type ), intent( inout ) :: target_field
    type( field_type ), intent( in )    :: source_field
    ! quadrature rule
    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule
    type( field_type )                    :: projected_field(1)
    type( field_type ), pointer           :: height_w3 => null()
    type( field_type ), pointer           :: height_wt => null()
    integer( kind=i_def )                 :: mesh_id
    integer( kind=i_def )                 :: space_dim

    call source_field%log_minmax(LOG_LEVEL_DEBUG, 'source field')

    mesh_id =  source_field%get_mesh_id() ! Currently only coded for fields on the same mesh

    if ( sample_physics_scalars ) then
      ! Determine situation from number of DoFs
      ! First check that both fields are lowest order
      if (.not. ((target_field%get_element_order() == 0) .and. &
                 (source_field%get_element_order() == 0))) then
        call log_event('sample_physics_scalars only works with the lowest order spaces', &
                       LOG_LEVEL_ERROR)
      end if

      ! Now determine situation depending on function spaces
      if (( target_field%which_function_space() == WTHETA ) &
           .and. ( source_field%which_function_space() == W3 ) ) then
        ! Target is lowest order Wtheta, source is lowest order W3
        height_w3 => get_height(W3, mesh_id)
        height_wt => get_height(WTHETA, mesh_id)
        call invoke( sample_w3_to_wtheta_kernel_type(target_field, source_field, &
                                                     height_wt, height_w3 ) )
        nullify(height_w3, height_wt)

      elseif (( target_field%which_function_space() == W3 ) &
              .and. ( source_field%which_function_space() == WTHETA )) then
        ! Target is lowest order W3, source is lowest order Wtheta
        call invoke( sample_wtheta_to_w3_kernel_type(target_field, source_field) )
      else
        call log_event('sample_physics_scalars only works with lowest order W3 and Wtheta fields', &
                       LOG_LEVEL_ERROR)
      end if

    else
      ! Do galerkin projection
      space_dim = 1_i_def
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)
      call projected_field(1)%initialise( vector_space = target_field%get_function_space() )
      call galerkin_projection_algorithm(projected_field, source_field, mesh_id, &
                                         space_dim, qr)
      call invoke( setval_X(target_field, projected_field(1)) )
    end if

    call target_field%log_minmax(LOG_LEVEL_DEBUG, 'target field')

  end subroutine map_physics_scalars

  !> @details An algorithm to map native FE wind fields to the appropriate
  !>          location for the FD physics codes
  !> @param[inout] u1_field Component of wind in the target space
  !> @param[inout] u2_field Component of wind in the target space
  !> @param[inout] u3_field Component of wind in the target space
  !> @param[in]    source_field Wind field in the source (native) space
  subroutine map_physics_winds(u1_field, u2_field, u3_field, source_field)

    use base_mesh_config_mod,             only: geometry, &
                                                geometry_spherical
    use convert_hdiv_field_kernel_mod,    only: convert_hdiv_field_kernel_type
    use nodal_xyz_coordinates_kernel_mod, only: nodal_xyz_coordinates_kernel_type
    use psykal_builtin_light_mod,         only: invoke_convert_cart2sphere_vector
    use geometric_constants_mod,          only: get_coordinates, &
                                                get_panel_id

    implicit none

    ! Prognostic fields
    type( field_type ), intent( inout ) :: u1_field, u2_field, u3_field
    type( field_type ), intent( in )    :: source_field
    type( field_type )                  :: wind_map(3), physical_chi(3)
    type( field_type ), pointer         :: chi(:) => null()
    type( field_type ), pointer         :: panel_id => null()
    ! quatrature rule
    type( quadrature_xyoz_type )          :: qr
    type( quadrature_rule_gaussian_type ) :: quadrature_rule
    type( field_type )                    :: projected_field(3)
    integer( kind=i_def )                 :: mesh_id
    integer( kind=i_def )                 :: space_dim

    mesh_id =  source_field%get_mesh_id()

    ! get chi field
    chi => get_coordinates(mesh_id)
    panel_id => get_panel_id(mesh_id)

    if (sample_physics_winds) then

      call u1_field%copy_field_properties(wind_map(1))
      call u1_field%copy_field_properties(wind_map(2))
      call u1_field%copy_field_properties(wind_map(3))
      call invoke( setval_c(wind_map(1), 0.0_r_def), &
                   setval_c(wind_map(2), 0.0_r_def), &
                   setval_c(wind_map(3), 0.0_r_def)  &
                   )

      call invoke( convert_hdiv_field_kernel_type(wind_map, source_field, chi, panel_id) )

      if ( geometry == geometry_spherical ) then
        call u1_field%copy_field_properties(physical_chi(1))
        call u1_field%copy_field_properties(physical_chi(2))
        call u1_field%copy_field_properties(physical_chi(3))
        call invoke( nodal_xyz_coordinates_kernel_type(physical_chi, chi, panel_id) )
        call invoke_convert_cart2sphere_vector( wind_map, physical_chi )
      end if

      call invoke( name = "Copy wind fields",       &
                   setval_X(u1_field, wind_map(1)), &
                   setval_X(u2_field, wind_map(2)), &
                   setval_X(u3_field, wind_map(3)) )

    else

      ! This method remains for posterity, but should be used with caution.
      space_dim = 3_i_def
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      call projected_field(1)%initialise( vector_space = u1_field%get_function_space() )
      call projected_field(2)%initialise( vector_space = u2_field%get_function_space() )
      call projected_field(3)%initialise( vector_space = u3_field%get_function_space() )
      call galerkin_projection_algorithm(projected_field, source_field, mesh_id, &
                                         space_dim, qr)
      call invoke( name = "Copy wind fields2",             &
                   setval_X(u1_field, projected_field(1)), &
                   setval_X(u2_field, projected_field(2)), &
                   setval_X(u3_field, projected_field(3)) )
    end if

  end subroutine map_physics_winds

end module physics_mappings_alg_mod
