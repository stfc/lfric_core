!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!>@brief Linear operator type which applies the mixed (outer) operator
!>
!> @details Calculates the left hand side of the implicit euler equations.
!>  Given the field-vector \f$ x = (\mathbf{u'},\theta',\rho',\Pi') \f$ this calculate the
!>  field-vector \f$ y = \delta(\mathbf{u},\delta\theta,\delta\rho,\delta\Pi) \f$
!>  where the components are
!>  calculated via the discretised version of the following set of equations:
!>
!>  \f[ \delta\mathbf{u} = \left(1+\mu\Delta t\mathbf{k}\cdot + 2\Delta t\Omega\times\right)\mathbf{u}' \f]
!>  \f[                  - \tau_u\Delta t c_p\left(\theta^*\nabla\Pi' + \theta'\nabla\Pi^*\right)  \f]
!>  \f[ \delta      \rho =       \rho' + \tau_\rho\Delta t \nabla.\left(\rho^*\mathbf{u}'\right)     \f]
!>  \f[ \delta    \theta =     \theta' + \tau_\theta\Delta t \mathbf{u}'.\nabla'theta^* \f]
!>  \f[ \delta       \Pi =     \frac{1-\kappa}{\kappa}\frac{\Pi'}{\Pi^*} - \frac{\rho'}{\rho^*} - \frac{\theta'}{\theta^*} \f]
!>  where \f$ \left(\Pi^*, \rho^*, \theta^*\right) \f$ are a reference profile

!>
!>  The primed terms are increments to the n+1 timelevel field. Upon
!>  discretisation, this leads to :
!>
!>  \f[ \delta\mathbf{u} = \left(M_2 + M_\mu + \tau_u C\right)\mathbf{u}' - \tau_u\Delta t (D^* \Pi' + P_{2\theta} \theta') \f]
!>  \f[ \delta\rho       = \rho'  + \tau_\rho\Delta t M_3^{-1} D \left(\rho^*\mathbf{u}'\right)  \f]
!>  \f[ \delta\theta     = M_theta \theta' + \tau_\theta\Delta t P_{\theta2} \mathbf{u}'  \f]
!>  \f[ \delta\Pi        = M_3^{\Pi}\Pi' - M_3^{\rho}\rho' - P_{3\theta}\theta' \f]

module mixed_operator_alg_mod
  use constants_mod,                     only: r_def, i_def
  use linear_operator_mod,               only: abstract_linear_operator_type
  use vector_mod,                        only: abstract_vector_type
  use field_vector_mod,                  only: field_vector_type
  use log_mod,                           only: log_event, LOG_LEVEL_ERROR, &
                                               log_scratch_space
  use combine_w2_field_kernel_mod,       only: combine_w2_field_kernel_type
  use split_w2_field_kernel_mod,         only: split_w2_field_kernel_type
  use mixed_solver_config_mod,           only: split_w
  implicit none

  private

  type, public, extends(abstract_linear_operator_type) :: &
                        mixed_operator_type

     private

   contains
     !> over-ride the abstract interface
     !> param[in] self a linear operator
     !> param[in] x a fieldvector the linear operator is applied to
     !> param[inout] y a fieldvector, the result.
     procedure, public  :: apply => apply_mixed_operator
     !> Applies the operator as LMA matrix matrix-vector kernels in all blocks
     procedure, private :: apply_mixed_operator
     !> Destroys the object
     final              :: destroy_mixed_operator
  end type mixed_operator_type

contains

  !> @brief Applies the mixed operator to the vector, \f$ y = M x \f$
  !>
  !> @param [in] self instance of the mixed operator
  !> @param [in] x field vector to be read
  !> @param [inout] y field vector to be written
  subroutine apply_mixed_operator(self, x, y)

    use boundaries_config_mod,              only: limited_area
    use io_config_mod,                      only: subroutine_timers
    use timestepping_config_mod,            only: dt, tau_r
    use timer_mod,                          only: timer
    use field_indices_mod,                  only: igh_u, igh_t, igh_d, igh_p, &
                                                  igh_w, igh_uv
    use operator_mod,                       only: operator_type
    use field_mod,                          only: field_type
    use si_operators_alg_mod,               only: get_p2theta,       &
                                                  get_div_star,      &
                                                  get_ptheta2,       &
                                                  get_m3_rho_star,   &
                                                  get_m3_exner_star, &
                                                  get_p3theta,       &
                                                  get_rho_at_u
    use fem_constants_mod,                  only: get_div,           &
                                                  get_mass_matrix,   &
                                                  w2_id, w3inv_id,   &
                                                  wt_id,             &
                                                  w2_si_id,          &
                                                  get_normalisation
    use limited_area_constants_mod,         only: get_mask
    use enforce_bc_kernel_mod,              only: enforce_bc_kernel_type
    use function_space_mod,                 only: function_space_type
    use fs_continuity_mod,                  only: W2, W2h, W2v, W3, Wtheta
    use function_space_collection_mod,      only: function_space_collection
    use apply_mixed_lu_operator_kernel_mod, only: apply_mixed_lu_operator_kernel_type
    use apply_mixed_lt_operator_kernel_mod, only: apply_mixed_lt_operator_kernel_type
    use apply_mixed_lr_operator_kernel_mod, only: apply_mixed_lr_operator_kernel_type
    use apply_mixed_lp_operator_kernel_mod, only: apply_mixed_lp_operator_kernel_type

    implicit none

    class(mixed_operator_type),  intent(inout) :: self
    class(abstract_vector_type), intent(in)    :: x
    class(abstract_vector_type), intent(inout) :: y

    type(operator_type), pointer       :: mm_vel => null(), &
                                          mm_w3_inv => null(), &
                                          mm_wtheta => null(), &
                                          div   => null(), &
                                          p2theta => null(), &
                                          div_star => null(), &
                                          ptheta2 => null(), &
                                          m3_rho_star => null(), &
                                          m3_exner_star => null(), &
                                          p3theta => null()
    type(field_type), pointer          :: rho_at_u => null(), &
                                          mt_lumped_inv => null(), &
                                          m2_diag => null()
    type(field_type)                   :: f_star, &
                                          x_uvw, y_uvw
    real(kind=r_def)                   :: tau_r_dt
    type(function_space_type), pointer :: u_fs => null()
    integer(i_def)                     :: p, mesh_id
    type(field_type), pointer          :: w2_mask     => null(), &
                                          w3_mask     => null(), &
                                          wtheta_mask => null()

    if ( subroutine_timers ) call timer('mixed_operator')

    ! LAM Masks
    if ( limited_area ) then
      w2_mask     => get_mask(W2)
      w3_mask     => get_mask(W3)
      wtheta_mask => get_mask(Wtheta)
    end if

    tau_r_dt = tau_r*dt

    ! Obtain operators from runtime constants
    mm_w3_inv     => get_mass_matrix(w3inv_id)
    mm_wtheta     => get_mass_matrix(wt_id)
    div           => get_div()
    mt_lumped_inv => get_normalisation(wt_id)
    m2_diag       => get_normalisation(w2_id)
    mm_vel        => get_mass_matrix(w2_si_id) ! = m2 (or dl) + tau_u*dt*coriolis

    ! Obtain operators from si operators
    p2theta           => get_p2theta()
    div_star          => get_div_star()
    ptheta2           => get_ptheta2()
    m3_rho_star       => get_m3_rho_star()
    m3_exner_star     => get_m3_exner_star()
    p3theta           => get_p3theta()
    rho_at_u          => get_rho_at_u()

    select type (x)
    type is (field_vector_type)
       select type (y)
       type is (field_vector_type)
         ! Create fields in 3D W2 space
         p = y%vector(igh_u)%get_element_order()
         mesh_id = y%vector(igh_u)%get_mesh_id()
         u_fs => function_space_collection%get_fs( mesh_id, p, W2 )

         call f_star%initialise( vector_space = u_fs )
         call x_uvw%initialise( vector_space = u_fs )
         call y_uvw%initialise( vector_space = u_fs )

         if ( split_w )then
           call invoke( combine_w2_field_kernel_type( x_uvw, x%vector( igh_uv ), &
                                                      x%vector( igh_w ) ) )
         else
           call invoke( setval_X( x_uvw, x%vector( igh_u ) ) )
         end if

         call invoke( name="apply_mixed_lhs",                                                               &
                      setval_c( y_uvw,           0.0_r_def),                                                &
                      setval_c( y%vector(igh_t), 0.0_r_def),                                                &
                      X_times_Y( f_star, rho_at_u, x_uvw ),                                                 &
                      apply_mixed_lu_operator_kernel_type( y_uvw, x_uvw, x%vector(igh_t), x%vector(igh_p),  &
                                                           mm_vel, p2theta, div_star, m2_diag ),            &
                      apply_mixed_lt_operator_kernel_type( y%vector(igh_t), x_uvw, x%vector(igh_t),         &
                                                           mm_wtheta, ptheta2, mt_lumped_inv ),             &
                      apply_mixed_lr_operator_kernel_type( y%vector(igh_d), x%vector(igh_d),                &
                                                           mm_w3_inv, div, tau_r_dt, f_star ),              &
                      apply_mixed_lp_operator_kernel_type( y%vector(igh_p), x%vector(igh_t),                &
                                                           x%vector(igh_d), x%vector(igh_p),                &
                                                           mm_w3_inv, m3_exner_star, m3_rho_star, p3theta), &
                      enforce_bc_kernel_type( y_uvw ) )

        ! Lateral boundaries
         if ( limited_area ) then
           call invoke( &
                      inc_X_times_Y( y_uvw,           w2_mask ),         &
                      inc_X_times_Y( y%vector(igh_d), w3_mask ),         &
                      inc_X_times_Y( y%vector(igh_p), w3_mask ),         &
                      inc_X_times_Y( y%vector(igh_t), wtheta_mask )      &
                      )
         end if
         if ( split_w )then
           call invoke( split_w2_field_kernel_type( y%vector( igh_uv ),          &
                                                    y%vector( igh_w ), y_uvw ) )
         else
           call invoke( setval_X( y%vector( igh_u ), y_uvw ) )
         end if

         nullify( mm_vel, mm_w3_inv, mm_wtheta, div, p2theta, &
                  div_star, ptheta2, m3_rho_star, m3_exner_star, p3theta, rho_at_u, &
                  mt_lumped_inv, m2_diag, u_fs )

         if ( limited_area ) then
           nullify( w2_mask, w3_mask, wtheta_mask )
         end if

       class default
          write(log_scratch_space, '(A)') &
                "mixed_operator_alg_mod: incorrect vector_type argument y"
          call log_event(log_scratch_space, LOG_LEVEL_ERROR)
       end select
    class default
       write(log_scratch_space, '(A)') &
             "mixed_operator_alg_mod: incorrect vector_type argument x"
       call log_event(log_scratch_space, LOG_LEVEL_ERROR)
    end select

    if ( subroutine_timers ) call timer('mixed_operator')

  end subroutine apply_mixed_operator

  !> @brief Finalizer for the mixed operator
  !> @param [inout] self the mixed operator
  subroutine destroy_mixed_operator(self)
    implicit none
    type(mixed_operator_type), intent(inout) :: self
  end subroutine destroy_mixed_operator

end module mixed_operator_alg_mod
