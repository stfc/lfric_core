!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!>@brief Wrapper algorithm to compute the advection of the prognostic
!>       equations
module advection_alg_mod

  use constants_mod,                  only: r_def, i_def
  use enforce_bc_kernel_mod,          only: enforce_bc_kernel_type
  use runtime_constants_mod,          only: get_coordinates, &
                                            get_div, &
                                            get_curl, &
                                            get_mass_matrix, &
                                            get_mass_matrix_diagonal, &
                                            get_inverse_lumped_mass_matrix, &
                                            w1_id, w2_id, w3inv_id, &
                                            theta_space_id
  use field_bundle_mod,               only: bundle_ax
  use field_mod,                      only: field_type
  use finite_element_config_mod,      only: element_order, wtheta_on, supg, &
                                            lumped_m1
  use function_space_mod,             only: function_space_type
  use matrix_vector_kernel_mod,       only: matrix_vector_kernel_type
  use matrix_vector_nobc_kernel_mod,  only: matrix_vector_nobc_kernel_type
  use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type
  use operator_mod,                   only: operator_type
  use psykal_lite_mod,                only: invoke_scale_field_data,    &
                                            invoke_sample_poly_flux,    &
                                            invoke_sample_poly_adv,     &
                                            invoke_rtheta_bd_kernel,    &
                                            invoke_axpy,                &
                                            invoke_inc_xpby,            &
                                            invoke_multiply_field_data, &
                                            invoke_divide_field
  use quadrature_mod,                 only: quadrature_type, GAUSSIAN
  use rtheta_kernel_mod,              only: rtheta_kernel_type
  use rtheta_wtheta_kernel_mod,       only: rtheta_wtheta_kernel_type
  use rtheta_supg_kernel_mod,         only: rtheta_supg_kernel_type
  use flux_rhs_kernel_mod,            only: flux_rhs_kernel_type
  use solver_mod,                     only: solver_algorithm
  use transpose_matrix_vector_kernel_mod, &
                                      only: transpose_matrix_vector_kernel_type
  use vorticity_advection_kernel_mod, only: vorticity_advection_kernel_type
  use vorticity_rhs_kernel_mod,       only: vorticity_rhs_kernel_type
  use derived_config_mod,             only: bundle_size 

  use transport_config_mod,           only: operators,              &
                                            fv_flux_order,          &
                                            fv_advective_order,     &
                                            transport_operators_fv, &
                                            transport_operators_fem
  use log_mod,                        only: log_event,         &
                                            LOG_LEVEL_ERROR,   &
                                            LOG_LEVEL_INFO
  use mr_indices_mod,                 only: nummr
  use timestepping_config_mod,        only: dt
  use runge_kutta_init_mod,           only: num_rk_stage, ak
  use field_indices_mod,              only: igh_u, igh_t, igh_d
  use output_config_mod,              only: subroutine_timers 
  use timer_mod,                      only: timer
  use timestepping_config_mod,        only: time_method => method, &
                                            timestepping_method_rk   

  implicit none

  private
  integer(i_def)                  :: flux_stencil_extent, &
                                     advective_stencil_extent
  type( field_type ), allocatable :: mr_prediction(:)
  integer(i_def)                  :: nstage_adv
  real(r_def),        allocatable :: ak_adv(:,:)

  public  :: advection_alg
  public  :: advection_alg_init
  public  :: advection_mr_alg
  private :: mass_flux_alg
  private :: advective_inc_alg

contains
!>@brief Initialisation routine to advection algorithm
  subroutine advection_alg_init(mesh_id)
    use mesh_mod,                          only: mesh_type
    use mesh_collection_mod,               only: mesh_collection
    use sample_poly_flux_kernel_mod,       only: sample_poly_flux_init
    use sample_poly_adv_kernel_mod,        only: sample_poly_adv_init
    integer(i_def),  intent(in) :: mesh_id

    type(mesh_type), pointer :: mesh => null()

    if ( time_method == timestepping_method_rk ) then
      ! If using explicit timestepping then advection is called once per stage,
      ! therefore no further sub stages are needed, setting number of stages = 1
      ! and coeffs = 1 short cuts the rk advection scheme
      nstage_adv = 1
      allocate( ak_adv(nstage_adv,nstage_adv) )
      ak_adv(1,1) = 1.0_r_def
    else
      nstage_adv = num_rk_stage
      allocate( ak_adv(nstage_adv,nstage_adv) )
      ak_adv = ak
    end if

    if ( operators == transport_operators_fv ) then
      if ( element_order == 0 ) then
        mesh => mesh_collection%get_mesh( mesh_id )
        call sample_poly_flux_init(fv_flux_order, mesh%get_nlayers())
        call sample_poly_adv_init (fv_advective_order, mesh%get_nlayers())
        ! Compute stencil extents
        flux_stencil_extent      = int(real(fv_flux_order+1)/2.0,i_def)
        advective_stencil_extent = int(real(fv_advective_order+1)/2.0,i_def)
      else
        call log_event( "Gungho: subgrid mappings needed for FV MoL with high &
                         order elements", LOG_LEVEL_ERROR )
      end if

      allocate ( mr_prediction(nstage_adv) )
    end if

  end subroutine advection_alg_init

!=============================================================================!
!>@details A wrapper algorithm for computing the advection of the prognostic
!>         equations, namely:
!>         \f[ \mathbf{R_u} = \xi \times \frac{\mathbf{F}}{\rho} \f]
!>         \f[ R_\theta = \frac{\mathbf{F}}{\rho}.\nabla\theta \f]
!>         \f[ R_\rho = \nabla.\mathbf{F} \f]
!>         with diagnostic fields:
!>
!>         Mass flux: \f$ \mathbf{F} = \mathbf{u}\rho \f$
!>         Vorticity: \f$ \xi = \nabla\times\mathbf{u} \f$
!>
!>         Using a method of lines algorithm
!> @param[inout] advection Advective terms
!> @param[in]    state Current state of the model prognostics
!> @param[in]    xi Relative vorticity field
  subroutine advection_alg( advection, &
                            state, &
                            xi, advecting_wind)
  
  implicit none
  ! Form of state and advection is [u,theta,rho] & [r_u,r_theta,r_rho]
  type(field_type), intent(in),    target  :: state(bundle_size)
  type(field_type), intent(inout)          :: advection(bundle_size)
  type(field_type), intent(inout)          :: xi
  type(field_type), intent(in)             :: advecting_wind

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_wt => null(), mm_w3_inv => null(), &
                                  div => null(), curl => null()

  type(quadrature_type)     :: qr
  type(field_type), pointer :: u => null() ,theta => null(), rho  => null()
  type(field_type)          :: r_xi, mass_flux, r_rho, rho_adv, mf, &
                               theta_adv, r_theta, u_grad_theta
  type(field_type), allocatable :: rrho_prediction(:), rtheta_prediction(:)

  type(function_space_type), pointer :: xi_fs => null(), u_fs => null(), &
                                        rho_fs => null(), theta_fs => null()
  type(field_type), pointer          :: mt_lumped_inv => null()
  type(field_type), pointer          :: m1_lumped_inv => null()
  integer(i_def)                     :: stage, st

  if ( subroutine_timers ) call timer('advection_alg')
  chi    => get_coordinates()

  u     => state(igh_u)
  theta => state(igh_t)
  rho   => state(igh_d)

  u_fs     => u%get_function_space()
  xi_fs    => xi%get_function_space()
  rho_fs   => rho%get_function_space()
  theta_fs => theta%get_function_space()

  ! Advective time integrated mass flux = rho*u
  mass_flux = field_type( vector_space = u_fs  )

  
  r_xi      = field_type( vector_space = xi_fs  )
  r_rho     = field_type( vector_space = rho_fs )
  r_theta   = field_type( vector_space = theta_fs)

  qr = quadrature_type(element_order+3, GAUSSIAN)

  ! Predictor fields used to store the right hand side at each stage of the
  ! Runge-Kutta algorithm
  allocate ( rrho_prediction(nstage_adv), rtheta_prediction(nstage_adv) )
  do stage = 1,nstage_adv
    rrho_prediction(stage)   = field_type( vector_space = rho_fs )
    rtheta_prediction(stage) = field_type( vector_space = theta_fs )
  end do

  ! Compute advection terms
  ! 1) mass flux ( F = rho * u ) 
  !rho_np1 = rho_n - dt* mm_w3_inv * div * F
  call log_event( "Computing advective mass flux...", LOG_LEVEL_INFO)
  ! advected density field
  rho_adv = field_type( vector_space = rho_fs )
  ! mass flux at each stage of rk scheme
  mf      = field_type( vector_space = u_fs ) 
  mm_w3_inv => get_mass_matrix(w3inv_id)
  div       => get_div()

  ! Runge-Kutta algorithm
  call invoke( copy_field(rho, rho_adv), &
               set_field_scalar(0.0_r_def, mass_flux) )
  do stage = 1,nstage_adv
    ! Compute the mass flux using desired spatial reconstruction
    call mass_flux_alg(mf, rho_adv, advecting_wind)
    ! Compute m3^-1 * div * mass flux
    call invoke( dg_matrix_vector_kernel_type(r_rho, mf, div), &
                 dg_matrix_vector_kernel_type(rrho_prediction(stage), r_rho, &
                                              mm_w3_inv) )
    ! Build the rhs of the RK scheme at this stage: sum_s -ak(s)*r_rho(s)
    call invoke( set_field_scalar(0.0_r_def, r_rho) )
    do st = 1, stage
      call invoke_inc_xpby(r_rho, -ak_adv(stage,st), rrho_prediction(st))

    end do
    ! Increment the advected density field to obtain estimate at this stage
    call invoke_axpy(dt, r_rho, rho, rho_adv)
    ! Add increment from this stage to the time integrated mass flux 
    call invoke_inc_xpby(mass_flux, ak_adv(nstage_adv,stage), mf) 
  end do

  ! 2) theta_advection ( u . grad(theta) )
  ! theta_np1 = theta_n - dt * u.grad(theta)
  call log_event( "Computing advective potential temperature increment...", &
                   LOG_LEVEL_INFO)
  ! Advected theta field
  theta_adv    = field_type( vector_space = theta_fs )
  ! time integrated update to theta state
  u_grad_theta = field_type( vector_space = theta_fs )

  ! Runge-Kutta algorithm  
  call invoke( set_field_scalar(0.0_r_def, u_grad_theta), &
               copy_field(theta, theta_adv) )
  do stage = 1,nstage_adv
    ! Compute u.grad(theta) using desired spatial reconstruction of gtad(theta)
    call advective_inc_alg(r_theta, theta_adv, advecting_wind)
    ! If using FEM operators and SUPG scheme add correction
    if ( supg ) call invoke( rtheta_supg_kernel_type(r_theta,     &
                             theta_adv, theta, mass_flux, rho, chi, qr) )   

    ! Obtain lumped inverse and full mass matrices for the correct space (Wtheta
    ! or W0) 
    mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
    mm_wt         => get_mass_matrix(theta_space_id) 
    if ( wtheta_on ) then
      ! If using Wtheta use lumped approximation to inverse mass matrix
      call invoke_multiply_field_data(r_theta, mt_lumped_inv, &
                                      rtheta_prediction(stage)) 
    else
      ! If using W0 use full mass matrix with iterative inverse
      ! (It would be possible to use the lumped inverse to speed things up)
      call solver_algorithm( rtheta_prediction(stage), r_theta)
    end if
    ! Build the rhs of the RK scheme at this stage: sum_s -ak(s)*r_theta(s)
    call invoke( set_field_scalar(0.0_r_def, r_theta) )
    do st = 1, stage
      call invoke_inc_xpby(r_theta, -ak_adv(stage,st), rtheta_prediction(st))
    end do
    call invoke_axpy(dt, r_theta, theta, theta_adv)
    ! Add increment from this stage to the time integrated u.grad(theta)
    call invoke_inc_xpby(u_grad_theta, -ak_adv(nstage_adv,stage), &
                         rtheta_prediction(stage)) 
  end do

  ! Return the advective increment in the correct form, this means for 
  ! si timestepping multiplying by Mtheta if fv operators are used to transform the pointwise field into a
  ! FEM field in the correct space.
  ! If FEM operators are used we need to cancel out the mt_lumped_inv factor
  ! used to update the theta_adv field.
  ! For RK timestepping with FV operators the full equation is solved in a
  ! pointwise fashion and so nothing needs to be done
  if ( operators == transport_operators_fv ) then   
    if ( time_method == timestepping_method_rk ) then
      ! Solve equation in pointwise form (fully fv equation)
      call invoke( copy_field(u_grad_theta, advection(igh_t) ) )
    else
      ! Solve equation weak pointwise form (fully fem equation)
      call invoke( set_field_scalar(0.0_r_def, advection(igh_t)), &
                   matrix_vector_kernel_type(advection(igh_t), u_grad_theta, mm_wt) )
    end if
  else
    call invoke_divide_field(u_grad_theta, mt_lumped_inv, advection(igh_t)) 
  end if

  ! 3) Vorticity advection
  ! Currently this is just a single stage approximation using xi = curl(u), it 
  ! should later be updated to use a RK scheme for the vorticity
  call log_event( "Computing advective vorticity...", LOG_LEVEL_INFO)
  curl   => get_curl()
  call invoke( set_field_scalar(0.0_r_def, r_xi) )
  call invoke( transpose_matrix_vector_kernel_type(r_xi, advecting_wind, curl) )
  call invoke( enforce_bc_kernel_type(r_xi) )
  if ( lumped_m1 ) then
    m1_lumped_inv => get_inverse_lumped_mass_matrix(w1_id)
    call invoke_multiply_field_data(r_xi, m1_lumped_inv, xi)
    call invoke( enforce_bc_kernel_type(xi) )
  else
    call solver_algorithm( xi, r_xi)
  end if

  ! 4) Vorticity advection of u ( F/rho \cross curl(u))
  call log_event( "Computing advective wind increment...", LOG_LEVEL_INFO)
  call invoke( set_field_scalar(0.0_r_def, advection(igh_u)) )
  call invoke( vorticity_advection_kernel_type(advection(igh_u), mass_flux, rho, &
                                               xi, chi, qr) )
  call invoke( enforce_bc_kernel_type(advection(igh_u)) )

  ! 5) advection update for the continuity equation divergence of mass flux: 
  !    M3^-1(div(F))
  call log_event( "Computing advective density increment...", LOG_LEVEL_INFO)
  call invoke( set_field_scalar(0.0_r_def, r_rho) )
  call invoke( matrix_vector_kernel_type(r_rho, mass_flux, div) )
  call invoke_scale_field_data(-1.0_r_def, r_rho)
  call invoke( dg_matrix_vector_kernel_type(advection(igh_d), r_rho, mm_w3_inv) )

  if ( subroutine_timers ) call timer('advection_alg')
  end subroutine advection_alg

!>@details A wrapper algorithm for computing the advection of the moisture 
!>         prognostic
!> @param[inout] advection Field array containing the advective terms
!> @param[in]    mr Field array. Mixing ratios
!> @param[in]    wind Field array. Winds

  subroutine advection_mr_alg( mr, wind )
  
    use matrix_vector_kernel_mod, only: matrix_vector_kernel_type
    implicit none
    type(field_type), intent(inout),    target  :: mr(nummr)
    type(field_type), intent(in),       target  :: wind

    type(function_space_type), pointer :: theta_fs  => null()

    type(field_type)          :: mr_inc, mr_adv, mr_n
    type(field_type), pointer :: mt_lumped_inv => null()

    integer :: imr, stage, st

    if ( subroutine_timers ) call timer('advection_mr_alg')
    call log_event( "Computing moisture advection...", LOG_LEVEL_INFO)

    theta_fs => mr(1)%get_function_space()

    mr_inc = field_type( vector_space = theta_fs )
    mr_adv = field_type( vector_space = theta_fs )
    mr_n   = field_type( vector_space = theta_fs )
    do stage = 1,nstage_adv
      mr_prediction(stage) = field_type( vector_space = theta_fs )
    end do

    ! Runge-Kutta algorithm
    do imr = 1,nummr
      call invoke( copy_field(mr(imr), mr_n) )
      do stage = 1,nstage_adv
        call advective_inc_alg(mr_prediction(stage), mr(imr), wind)
        call invoke( set_field_scalar(0.0_r_def, mr_adv) )
        do st = 1, stage
          call invoke_inc_xpby(mr_adv, -ak_adv(stage,st), mr_prediction(st))
        end do
        ! Use lumped mass matrix     
        mt_lumped_inv => get_inverse_lumped_mass_matrix(theta_space_id)
        call invoke_multiply_field_data(mr_adv, mt_lumped_inv, mr_inc)          
        call invoke_axpy(dt, mr_inc, mr_n, mr(imr))
      end do
    end do
    if ( subroutine_timers ) call timer('advection_mr_alg')

  end subroutine advection_mr_alg

!>@brief Compute the mass flux, f = rho*u using desired spatial reconstruction
!>@param[inout] mass_flux Mass flux field: f = density*wind
!>@param[in]    density Field to advect
!>@param[in]    wind Advecting wind field
  subroutine mass_flux_alg(mass_flux, density, wind)
  implicit none
  
  type(field_type), intent(in)    :: density, wind
  type(field_type), intent(inout) :: mass_flux

  type(field_type),    pointer :: chi(:) => null()
  type(operator_type), pointer :: mm_w2 => null()
  type(field_type),    pointer :: mmd_w2 => null()

  type(quadrature_type)     :: qr
  type(field_type)          :: rhs_f 

  type(function_space_type), pointer :: u_fs  => null()

  u_fs     => wind%get_function_space()

  select case(operators)
    case(transport_operators_fv)
     ! Use pointwise fv operators compute mass flux with high-order polynomial
     ! interpolation of density
     call invoke_sample_poly_flux( mass_flux, wind, density, &
                                   flux_stencil_extent )
    case(transport_operators_fem)  
      ! Project density*wind into the mass flux space    
      qr = quadrature_type(element_order+3, GAUSSIAN)
      mm_w2  => get_mass_matrix(w2_id)
      mmd_w2 => get_mass_matrix_diagonal(w2_id)
      chi    => get_coordinates()
      rhs_f = field_type( vector_space = u_fs )
      call invoke( set_field_scalar(0.0_r_def, rhs_f) )
      call invoke( flux_rhs_kernel_type(rhs_f, wind, density, chi, qr) )
      call invoke( enforce_bc_kernel_type(rhs_f) )
      call invoke( set_field_scalar(0.0_r_def, mass_flux) )
      call solver_algorithm( mass_flux, rhs_f)
  end select

  end subroutine mass_flux_alg


!>@brief Compute advective update u.grad(theta) using desired spatial 
!>       reconstruction
!>@param[inout] rtheta Advective increment
!>@param[in]    theta Field to advect
!>@param[in]    wind Advecting wind field
  subroutine advective_inc_alg(rtheta, theta, wind)
  implicit none
  type(field_type), intent(in)    :: theta, wind
  type(field_type), intent(inout) :: rtheta
  type(quadrature_type)           :: qr

  select case(operators)
    case(transport_operators_fv)
     ! Use pointwise fv operators compute u.grad(theta) with high-order 
     ! polynomial interpolation of theta
      call invoke_sample_poly_adv( rtheta, theta, wind, &
                                   advective_stencil_extent )
         
    case(transport_operators_fem)
     ! Use project u.grad(theta) into the theta function space
      qr = quadrature_type(element_order+3, GAUSSIAN)
      call invoke( set_field_scalar(0.0_r_def, rtheta) )
      if ( wtheta_on ) then
        call invoke ( rtheta_wtheta_kernel_type (rtheta, theta, wind, qr) )
        call invoke_rtheta_bd_kernel ( rtheta, theta, wind, qr )
      else
        call invoke( rtheta_kernel_type(rtheta, theta, wind, qr) )
      end if
   end select

  end subroutine advective_inc_alg

end module advection_alg_mod


