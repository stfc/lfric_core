
!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief   This module handles calculation of fields sent to the coupler
!> @details Here, we set up fields, essentailly as diagnostics, which are
!           to be passed to external models via an external coupler which
!           deals with any regridding, interpolation, etc.

module coupler_diagnostics_mod
  use field_mod,                     only: field_type
  use field_collection_mod,          only: field_collection_type
  use clock_mod,                     only: clock_type
  use constants_mod,                 only: str_def, l_def, i_def, r_def, imdi, &
                                           rmdi, i_timestep
  use log_mod,                       only: log_event,       &
                                           LOG_LEVEL_INFO,  &
                                           LOG_LEVEL_ERROR, &
                                           log_scratch_space
#if defined(UM_PHYSICS)
  use cv_run_mod,                    only: l_param_conv
  use jules_control_init_mod,        only: n_sea_tile, first_sea_tile,   &
                                           first_sea_ice_tile,           &
                                           n_sea_ice_tile
  use driver_water_constants_mod,    only: latent_heat_h2o_condensation, &
                                           latent_heat_h2o_fusion
#endif

  use convert_to_celsius_kernel_mod, only: convert_to_celsius_kernel_type
  use convert_to_marine_fraction_mod, only: convert_to_marine_fraction_type

  implicit none

  private
  ! workspace used for coupling field calculation
  type( field_type )                 :: cpl_field1, cpl_field2, cpl_field3
  type( field_type )                 :: cpl_field1_si, cpl_field2_si,          &
                                        cpl_field3_si

  ! Raw sea ice fractions that are unaltered by post processing
  ! for use in scaling data going from atmos to ocean
  type( field_type )                 :: sea_ice_frac_raw

  ! Sea ice fractions used in the previous timestep
  ! (i.e. not unpaded by the coupling)
  ! These ice fractions are stored as a fraction of
  ! the marine portion of the grid box
  type( field_type )                 :: sea_ice_frac_previous
  type( field_type )                 :: sea_frac_previous

#if !defined(UM_PHYSICS)
  !
  ! Dummy variables required when NOT running with UM_PHYSICS
  !
  logical ::  l_param_conv = .false.
  ! index of the sea tile set here to prevent using jules_control_init_mod
  ! when UM physics is not used
  integer(i_def),parameter              :: n_sea_tile = imdi
  ! index of the first sea and tile
  integer(i_def), parameter             :: first_sea_tile = imdi
  ! other indices for sea ice
  integer(i_def), parameter             :: first_sea_ice_tile = imdi
  integer(i_def), parameter             :: n_sea_ice_tile = imdi
  ! latent heat of condensation
  real(r_def), parameter                :: latent_heat_h2o_condensation = rmdi
#endif

  public cpl_diagnostics, cpl_reset_field, initialise_extra_coupling_fields
  public sea_ice_frac_raw
  public save_sea_ice_frac_previous
  contains

  !> @brief assignes data to coupling fields
  !> @param[in, out] fld coupling field
  !> @param[in] depository field collection - all fields
  !> @param[in] clock model clock
  !> @param[in] istep model time step
  subroutine cpl_diagnostics(fld, depository, clock, istep)

   use multi_extract_kernel_mod,    only: multi_extract_kernel_type

   implicit none
   type( field_type ), intent(inout)            :: fld
   type( field_collection_type ), intent(in)    :: depository
   class(clock_type), intent(in)                :: clock
   integer(i_def), intent(in)                   :: istep
   ! Local variables
   logical(l_def)                               :: lfail    ! failure flag
   !local pointers
   type( field_type ), pointer                  :: fld_ptr1 => null()
   type( field_type ), pointer                  :: fld_ptr2 => null()
   type( field_type ), pointer                  :: fld_ptr3 => null()
   type( field_type ), pointer                  :: fld_ptr4 => null()
   real(r_def)                                  :: dtime    !seconds in timestep

   lfail = .false.

   if(istep > 1) then
      dtime = real(clock%get_seconds_per_step(), r_def)
      select case(fld%get_name())
         case ("lf_taux")
            fld_ptr1 => depository%get_field("taux_ssi")
            call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_tauy")
            fld_ptr1 => depository%get_field("tauy_ssi")
            call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_solar")
            fld_ptr1 => depository%get_field("sw_up_tile")
            fld_ptr2 => depository%get_field("sw_down_surf")
            call invoke(                                                       &
            !
            ! Extract SW up from tile field, subtract from SW down at surface
            ! and increment our coupling field with the net (SW/solar)
            ! contribution.
            !
                        multi_extract_kernel_type(cpl_field1, fld_ptr1,        &
                        first_sea_tile, n_sea_tile),                           &
                        X_minus_Y(cpl_field2, fld_ptr2, cpl_field1),           &
                        inc_X_plus_bY( fld, dtime, cpl_field2 ))
            fld_ptr1 => null()
            fld_ptr2 => null()
         case ("lf_heatflux")
            fld_ptr1 => depository%get_field("lw_up_tile")
            fld_ptr2 => depository%get_field("lw_down_surf")
            fld_ptr3 => depository%get_field("tile_heat_flux")
            fld_ptr4 => depository%get_field("tile_moisture_flux")

            ! Concoct our heatflux value from various contributing fields.
            call invoke(                                                       &
            !
            ! Extract LW up from tile field, subtract from LW down at surface
            ! and increment our coupling field with the net (LW) contribution.
            !
                        multi_extract_kernel_type(cpl_field1, fld_ptr1,        &
                        first_sea_tile, n_sea_tile),                           &
                        X_minus_Y(cpl_field2, fld_ptr2, cpl_field1),           &
                        inc_X_plus_bY(fld, dtime, cpl_field2),                 &
            !
            ! Extract heat flux from tile field
            !
                        multi_extract_kernel_type(cpl_field1, fld_ptr3,        &
                        first_sea_tile, n_sea_tile),                           &
            !
            ! Extract moisture heat flux from tile field
            !
                        multi_extract_kernel_type(cpl_field2, fld_ptr4,        &
                        first_sea_tile, n_sea_tile),                           &
            !
            ! Add heat flux + hlat*moisture heat flux and
            ! increment coupling field with the net contribution
            !
                        aX_plus_bY(cpl_field3, 1._r_def, cpl_field1,           &
                        latent_heat_h2o_condensation, cpl_field2),             &
                        inc_X_minus_bY( fld, dtime, cpl_field3 ))
            fld_ptr1 => null()
            fld_ptr2 => null()
            fld_ptr3 => null()
            fld_ptr4 => null()
         case ("lf_train")
            !large scale rain
            fld_ptr1 => depository%get_field("ls_rain")

            if(l_param_conv) then
               !convective rain
               fld_ptr2 => depository%get_field("conv_rain")
               !total
               call invoke(X_plus_Y( cpl_field1, fld_ptr1, fld_ptr2),          &
                           inc_X_plus_bY( fld, dtime, cpl_field1 ))
               fld_ptr2 => null()
            else
               call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            endif

            fld_ptr1 => null()
         case ("lf_tsnow")
            !large scale snow
            fld_ptr1 => depository%get_field("ls_snow")

            if(l_param_conv) then
               !convective snow
               fld_ptr2 => depository%get_field("conv_snow")
               !total
               call invoke(X_plus_Y( cpl_field1, fld_ptr1, fld_ptr2),          &
                           inc_X_plus_bY( fld, dtime, cpl_field1 ))
               fld_ptr2 => null()
            else
               call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            endif

            fld_ptr1 => null()
         case ("lf_w10")
            !10m wind
            fld_ptr1 => depository%get_field("wspd10m")
            call invoke(inc_X_plus_bY( fld, dtime, fld_ptr1 ))
            fld_ptr1 => null()
         case ("lf_evap")
            fld_ptr1 => depository%get_field("tile_moisture_flux")

            ! Extract the oceanic evaporation from the ocean tile
            call invoke( multi_extract_kernel_type(cpl_field1, fld_ptr1,       &
                                             first_sea_tile, n_sea_tile ),     &

               ! Convert oceanic evaporation to be as a fraction of the marine
               ! portion of the grid box
               ! evaporation_marine_fraction(cpl_field2) =
               ! evaporation(cpl_field1) * sea_fraction_of_marine(sea_frac_previous)
               X_times_Y( cpl_field2, cpl_field1, sea_frac_previous ),         &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_bY( fld, dtime, cpl_field2 ))
            fld_ptr1 => null()

         case ("lf_topmelt")
            fld_ptr1 => depository%get_field("snowice_melt")

            ! Extract the sea ice top melt from the snowice_melt which is on
            ! all tiles
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert top melt into an equivalent energy flux
               ! (i.e. from kg m-2 s-1 to W m-2)
               ! top_melt_flux(cpl_field2_si) =
               !                latent_heat_h2o_fusion * top_melt(cpl_field1_si)
               a_times_X( cpl_field2_si, latent_heat_h2o_fusion,               &
                                               cpl_field1_si ),                &

               ! Convert top melt to be as a fraction of the marine portion
               ! of the grid box
               ! top_melt_marine_fraction(cpl_field3_si) =
               !               top_melt_flux(cpl_field2_si) *
               !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
               X_times_Y( cpl_field3_si, cpl_field2_si,                        &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_bY( fld, dtime, cpl_field3_si ))
            fld_ptr1 => null()

         case ("lf_iceheatflux")
            fld_ptr1 => depository%get_field("surf_ht_flux")

            ! Extract the sea ice surface to sub-surface heat flux from the
            ! surf_ht_flux which is on all tiles
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert surface heat flux to be as a fraction of the marine
               ! portion of the grid box.
               ! surf_heat_marine_fraction(cpl_field2_si) =
               !               surf_ht_flux(cpl_field1_si) *
               !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
               X_times_Y( cpl_field2_si, cpl_field1_si,                        &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_bY( fld, dtime, cpl_field2_si ))
            fld_ptr1 => null()

         case ("lf_sublimation")
            fld_ptr1 => depository%get_field("snowice_sublimation")

            ! Extract the sea ice sublimation from the snowice_sublimation
            ! which is on all tiles
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert sublimation to be as a fraction of the marine
               ! portion of the grid box
               ! sublimation_marine_fraction(cpl_field2_si) =
               !               sublimation(cpl_field1_si) *
               !               sea_ice_fraction_of_marine(sea_ice_frac_previous)
               X_times_Y( cpl_field2_si, cpl_field1_si,                        &
                                                      sea_ice_frac_previous ), &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_bY( fld, dtime, cpl_field2_si ))
            fld_ptr1 => null()

         case ("lf_iceskint")
            fld_ptr1 => depository%get_field('tile_temperature')

            ! Extract the sea ice skin temperature from the tile temperature
            call invoke( multi_extract_kernel_type(cpl_field1_si, fld_ptr1,    &
                                         first_sea_ice_tile, n_sea_ice_tile ), &

               ! Convert from Kelvin to Celsius
               ! (NEMO is expecting the data in Celsius)
               convert_to_celsius_kernel_type(cpl_field2_si, cpl_field1_si),   &

               ! Multiply by the length of the timestep as part of the
               ! time averaging process
               inc_X_plus_bY( fld, dtime, cpl_field2_si ))
            fld_ptr1 => null()

         case default
            lfail = .true.
            write(log_scratch_space, '(3A)' )                                  &
                                         "PROBLEM cpl_diagnostics variable ",  &
                                trim(fld%get_name()), ": can not assign value"
            call log_event( log_scratch_space, LOG_LEVEL_INFO )
      end select
   else if(istep == 0) then
     !for now. It will be set by restart when available
      call cpl_reset_field(fld)
      write(log_scratch_space, '(2A)' ) "cpl_diagnostics: variable ",          &
                                   trim(fld%get_name())//": set to 0"
      call log_event( log_scratch_space, LOG_LEVEL_INFO )
   endif

   if(lfail) then
      write(log_scratch_space, * ) "ERRORS in cpl_diagnostics"
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
   endif

  end subroutine cpl_diagnostics

  !> @brief sets value of fld to 0
  !> @param[in, out] fld coupling field
  subroutine cpl_reset_field(fld)
   implicit none
   type( field_type ), intent(inout) :: fld

   call invoke(setval_c(fld, 0.0_r_def))

  end subroutine cpl_reset_field

  subroutine initialise_extra_coupling_fields(fld_cpld_fs, sice_space)
  !> @brief initialises temporary coupling work fields
  !> @param[in] fld_cpld_fs: 2D function space
  !> @param[in] sice_space : sea ice function space

    use function_space_mod,             only: function_space_type

    implicit none

    type(function_space_type), intent(in), pointer :: fld_cpld_fs
    type(function_space_type), intent(in), pointer :: sice_space

    ! initialize 2D scratch variables
    call cpl_field1%initialise( vector_space=fld_cpld_fs, name="cpl_field1_W3" )
    call cpl_field2%initialise( vector_space=fld_cpld_fs, name="cpl_field2_W3" )
    call cpl_field3%initialise( vector_space=fld_cpld_fs, name="cpl_field3_W3" )

    ! initialise sea ice scratch variables
    call cpl_field1_si%initialise( vector_space = sice_space,             &
                                        name="cpl_field1_sea_ice_W3" )
    call cpl_field2_si%initialise( vector_space = sice_space,             &
                                        name="cpl_field2_sea_ice_W3" )
    call cpl_field3_si%initialise( vector_space = sice_space,             &
                                        name="cpl_field3_sea_ice_W3" )

    ! Initialise other fields used in coupling
    call sea_ice_frac_raw%initialise( vector_space = sice_space,             &
                                        name="sea_ice_frac_raw" )
    call sea_ice_frac_previous%initialise( vector_space = sice_space,        &
                                        name="sea_ice_frac_previous" )
    call sea_frac_previous%initialise( vector_space = fld_cpld_fs,           &
                                        name="sea_frac_previous" )

  end subroutine initialise_extra_coupling_fields

  subroutine save_sea_ice_frac_previous(depository)
  !> @brief Save the sea and sea ice fractions from the previous timestep prior
  !> @brief to recieving a new sea ice fraction from the coupler.
  !> @brief These are saved as a marine fraction
  !> @brief             (rather than whole grid box fraction)

    implicit none
    type( field_collection_type ), intent(in)    :: depository

    !local variables
    type( field_type ), pointer :: tile_fraction_ptr       => null()

    tile_fraction_ptr => depository%get_field('tile_fraction')
    call invoke(convert_to_marine_fraction_type(sea_ice_frac_previous,         &
                                          sea_frac_previous, tile_fraction_ptr))

  end subroutine save_sea_ice_frac_previous

end module coupler_diagnostics_mod
