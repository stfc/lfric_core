!-----------------------------------------------------------------------------
! (C) Crown copyright 2020 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief A module containing a time axis object.
!>
!> @details Fields need to be updated at different times and frequencies. The
!>          time axis object can be linked to a field to provide information
!>          of how the field should be updated with time.
module lfric_xios_time_axis_mod

  use clock_mod,            only: clock_type
  use constants_mod,        only: i_def, str_def, r_def, l_def, dp_xios
  use field_mod,            only: field_type, field_proxy_type
  use field_parent_mod,     only: field_parent_type
  use field_collection_mod, only: field_collection_type, &
                                  field_collection_iterator_type
  use fs_continuity_mod,    only: W3
  use log_mod,              only: log_event, log_scratch_space, &
                                  LOG_LEVEL_ERROR, LOG_LEVEL_INFO
  use linked_list_data_mod, only: linked_list_data_type

  implicit none

  private

  !> Time axis object type
  type, extends(linked_list_data_type), public :: time_axis_type

    private

    !> Name of the time_axis.
    character(str_def) :: name = 'unset'
    !> The data values of the time axis
    real(kind=r_def), allocatable :: time_data( : )
    !> The indices of the data points of the time axis
    integer(kind=i_def), allocatable :: index_data( : )
    !> The XIOS ID of the time axis
    character(str_def) :: xios_id
    !> The collection of fields associated with the time axis
    type(field_collection_type) :: fields
    !> Flag determining the cyclical nature of time axis
    logical(l_def) :: cyclic = .true.
    !> String identifier for units of the time axis
    character(str_def) :: time_units = 'seconds'
    !> Upper limit for time axis data
    real(r_def) :: upper_limit = 31536000.0_r_def
    !> Flag for interpolation
    logical(l_def) :: does_interpolation = .false.
    !> Update frequency in timesteps
    integer(i_def) :: update_frequency = 1

    procedure(update_interface), nopass, pointer :: update_behaviour => null()

  contains
    !> Initialiser for the time axis object
    procedure, public :: initialise
    !> Set the routine that updates the time axis field data
    procedure, public :: set_update_behaviour
    !> Getter for time axis name
    procedure, public :: get_name
    !> Getter for time units
    procedure, public :: get_units
    !> Procedure for cycling through time data to find the correct entry
    procedure, public :: shift_forward
    !> Returns start/end times for active time window
    procedure, public :: get_time_window
    !> Returns start/end indices for active time window
    procedure, public :: get_index_window
    !> Returns update frequency of time axis in timesteps
    procedure, public :: get_update_frequency
    !> Aligns the active time window with the current model time
    procedure, public :: align
    !> Adds a field to the associated time axis object
    procedure, public :: add_field
    !> Reads the fields associated with the time axis
    procedure, public :: update_fields
    !> Populates the model fields linked with the time axis data
    procedure, public :: populate_model_fields
  end type time_axis_type

  abstract interface

  !> @brief Interface for updating the field data associated with the time axis.
  !> @param[in]     field_name  Name of the field to be updated
  !> @param[in,out] field_proxy Field proxy to be updated
  !> @param[in]     times       The time data corresponding to the new field data
  !>
  subroutine update_interface(field_name, field_proxy, times, xios_id)
    import i_def, field_proxy_type
    character(len=*),        intent(in) :: field_name
    type(field_proxy_type),  intent(inout) :: field_proxy
    integer(i_def),          intent(in) :: times(:)
    character(len=*),        intent(in) :: xios_id
  end subroutine update_interface

end interface

public :: update_interface

contains

  !> @brief Initialise a <code>time_axis_type</code> object.
  !>
  !> @param[in] input_data   The input time data array
  !> @param[in] name         The time axis name
  !> @param[in] xios_id      The type of time axis
  !> @param[in] input_units  The units of time data
  !> @param[in] cyclic       Flag determining if axis is cyclic
  !> @param[in] upper_limit  The maximum value that the time axis can take
  !>                         before it cycles
  !> @param[in] interp_flag  Flag determining if time_axis fields are linearly
  !>                         interpolated before being passed to the model data
  !> @param[in] update_freq  The update frequency of the time axis in timesteps
  subroutine initialise( self, input_data, name, xios_id, input_units, cyclic, &
                         upper_limit, interp_flag, update_freq )

    implicit none

    class(time_axis_type),        intent(inout) :: self
    real(r_def),                  intent(in)    :: input_data(:)
    character(*),                 intent(in)    :: name
    character(*),                 intent(in)    :: xios_id
    character(*),   optional,     intent(in)    :: input_units
    logical(l_def), optional,     intent(in)    :: cyclic
    real(r_def),    optional,     intent(in)    :: upper_limit
    logical(l_def), optional,     intent(in)    :: interp_flag
    integer(i_def), optional,     intent(in)    :: update_freq

    type(field_collection_type) :: input_fields
    integer(i_def) :: i

    self%time_data = input_data

    self%index_data = (/ (i, i=1, size(input_data)) /)

    self%name = name

    self%xios_id = xios_id

    input_fields = field_collection_type(name=trim(name)//'_fields')
    self%fields = input_fields

    if ( present(input_units) ) self%time_units = input_units

    if ( present(cyclic) ) self%cyclic = cyclic

    if ( present(upper_limit) ) self%upper_limit = upper_limit

    if ( present(interp_flag) ) self%does_interpolation = interp_flag

    if ( present(update_freq) ) self%update_frequency = update_freq

  end subroutine initialise

  !> @brief Sets routine that updates field data for time axis.
  !> @param[in] update_behaviour Pointer to update routine
  subroutine set_update_behaviour(self, update_behaviour)

    implicit none

    class(time_axis_type), intent(inout) :: self
    procedure(update_interface), pointer, intent(in) :: update_behaviour

    self%update_behaviour => update_behaviour

  end subroutine set_update_behaviour

  !> @brief Returns the time_axis name.
  !> @return output_name The time axis name
  function get_name(self) result(output_name)

    implicit none

    class(time_axis_type), intent(inout) :: self

    character(str_def) :: output_name

    output_name = self%name

  end function get_name

  !> @brief Returns the time_axis units.
  !> @return output_units The time axis units
  function get_units(self) result(output_units)

    implicit none

    class(time_axis_type), intent(inout) :: self

    character(str_def) :: output_units

    output_units = self%time_units

  end function get_units

  !> @brief Performs a cshift on the data and index data arrays.
  subroutine shift_forward(self)

    implicit none

    class(time_axis_type), intent(inout) :: self

    if ( self%cyclic ) then
      self%time_data(1) = self%time_data(1) + self%upper_limit
    end if

    self%time_data = cshift(self%time_data, 1)
    self%index_data = cshift(self%index_data, 1)

  end subroutine shift_forward

  !> @brief Returns start and end time data for active time window.
  !> @return time_window The active time window of the time axis
  function get_time_window(self) result(time_window)

    implicit none

    class(time_axis_type), intent(inout) :: self

    real(r_def) :: time_window(2)

    time_window = self%time_data(1:2)

  end function get_time_window

  !> @brief Returns start and end time indices for active time window.
  !> @return time_window_index The indices of the active time window
  function get_index_window(self) result(time_window_index)

    implicit none

    class(time_axis_type), intent(inout) :: self

    integer(i_def) :: time_window_index(2)

    time_window_index = self%index_data(1:2)

  end function get_index_window

  !> @brief Returns time axis update frequency.
  !> @return update_frequency The update frequency of the time axis in timesteps
  function get_update_frequency(self) result(update_frequency)

    implicit none

    class(time_axis_type), intent(inout) :: self

    integer(i_def) :: update_frequency

    update_frequency = self%update_frequency

  end function get_update_frequency

  !> @brief Takes model time and shifts forward through time axis so active
  !>        time window is aligned with model time.
  !> @param[in] input_time The current time of the model
  subroutine align(self, input_time)

    implicit none

    class(time_axis_type), intent(inout) :: self
    real(r_def),           intent(in)    :: input_time

    integer(i_def) :: n

    ! Until final clock/calendar implementation, the time is currently in the
    ! form of a real number of seconds (future work will introduce time units)
    ! Cycle backwards - find correct time window if its behind the start
    do n=1,size(self%time_data)
      if ( input_time < self%time_data(1) ) then
        self%time_data = cshift(self%time_data, -1)
        self%index_data = cshift(self%index_data, -1)

        if ( (self%time_data(1) > self%time_data(2)) ) then
          self%time_data(1) = self%time_data(1) - self%upper_limit
          return
        end if

      else if ( (self%time_data(1) <= input_time) .and. (input_time < self%time_data(2)) ) then
        return
      else
        self%time_data = cshift(self%time_data, -1)
        self%index_data = cshift(self%index_data, -1)
      end if
    end do

    ! If we are still going, cycle forward to get the correct time window
    do n=1,size(self%time_data)
      if ( (self%time_data(1) <= input_time) .and. (input_time < self%time_data(2)) ) then
        return
      else
        call self%shift_forward()
      end if
    end do

    ! If we're still going then the correct time is out of the time axis bounds
    ! or in a future cycle of a cyclic time-axis
    if ( self%cyclic ) then
      do
        if ( (self%time_data(1) <= input_time) .and. (input_time < self%time_data(2)) ) then
          return
        else
          call self%shift_forward()
        end if
      end do
    else
      write( log_scratch_space, '(A,A)' ) &
        "Model time is out of bounds for time axis: ", &
         self%name
      call log_event( log_scratch_space, LOG_LEVEL_ERROR )
    end if

  end subroutine align

  !> @brief Adds a field to the time axis field collection.
  !> @param[in] field Field to be added to the time axis
  subroutine add_field(self, field)

    implicit none

    class(time_axis_type), intent(inout) :: self
    type(field_type), intent(in) :: field

    call self%fields%add_field(field)

  end subroutine add_field

  !> @brief Updates associated data fields using update routine.
  subroutine update_fields(self)

    implicit none

    class(time_axis_type), intent(inout) :: self

    type( field_collection_iterator_type) :: read_iter
    class( field_parent_type ), pointer   :: updated_field => null()

    type(field_proxy_type) :: tmp_proxy


    read_iter = self%fields%get_iterator()
    do
      if ( .not.read_iter%has_next() ) exit
      updated_field => read_iter%next()
      select type(updated_field)
        type is (field_type)
          tmp_proxy = updated_field%get_proxy()
          call log_event( &
            'Reading '//trim(adjustl(updated_field%get_name())), &
            LOG_LEVEL_INFO)
          call self%update_behaviour(updated_field%get_name(), tmp_proxy, self%index_data(1:2), self%xios_id)
      end select
    end do

    nullify(updated_field)

  end subroutine update_fields

  !> @brief Populates model fields using time axis data fields.
  !> @param[in] model_fields Field collection to populate from data fields
  !> @param[in] clock        The model clock object
  subroutine populate_model_fields(self, model_fields, clock)

    implicit none

    class(time_axis_type),       intent(inout) :: self
    type(field_collection_type), intent(in)    :: model_fields
    type(clock_type),            intent(in)    :: clock

    class(field_parent_type), pointer :: field_next => null()
    type(field_type),         pointer :: model_field => null()
    type(field_type),         pointer :: data_field => null()

    type(field_collection_iterator_type) :: pop_iter
    type(field_proxy_type)               :: data_proxy, model_proxy
    character(str_def), allocatable      :: field_name


    pop_iter = self%fields%get_iterator()

    do
      if ( .not. pop_iter%has_next() ) exit

      field_next => pop_iter%next()
      field_name = field_next%get_name()

      if ( model_fields%field_exists(trim(field_name)) ) then
        model_field => model_fields%get_field(trim(field_name))
        model_proxy = model_field%get_proxy()
        data_field => self%fields%get_field(trim(field_name))
        data_proxy = data_field%get_proxy()

        ! Populate model fields based on interpolation flag
        if ( self%does_interpolation ) then
          call interp_field_1d( model_field, model_proxy, data_proxy, clock, self%get_time_window() )
        else
          model_proxy%data(:) = data_proxy%data(1::2)
        end if

        ! Set halos dirty
        call model_proxy%set_dirty()

        nullify(model_field)
        nullify(data_field)

      end if

    end do

    nullify(field_next)

  end subroutine populate_model_fields

  !> @brief Populates a model field by interpolating between the data entries of
  !>        the current time window.
  !> @param[in] model_field Pointer to field to be populated from data fields
  !> @param[in] model_proxy Field proxy object for model field
  !> @param[in] data_proxy  Field proxy object for input data field
  !> @param[in] clock       The model clock object
  !> @param[in] time_window The current time window
  subroutine interp_field_1d( model_field, model_proxy, data_proxy, clock, time_window )

    use xios, only: xios_date, xios_get_current_date, &
                    xios_date_get_day_of_year, xios_date_get_second_of_day

    implicit none

    type(field_type),       intent(inout), pointer :: model_field
    type(field_proxy_type), intent(in)             :: model_proxy
    type(field_proxy_type), intent(in)             :: data_proxy
    type(clock_type),       intent(in)             :: clock
    real(r_def),            intent(in)             :: time_window(2)


    type(field_type)                     :: field_time_entries(2)
    type(field_type)                     :: interp_gradient
    type(field_type)                     :: dData
    type(field_proxy_type)               :: time_entry_proxy
    integer(i_def)                       :: t, day_of_year
    real(r_def)                          :: dt_recip, time_diff, second_of_day
    type(xios_date)                      :: datetime

     ! Split multi-data field into two fields for start and end time entry
    do t = 1, 2
      call field_time_entries(t)%initialise( model_proxy%vspace )
      time_entry_proxy = field_time_entries(t)%get_proxy()
      time_entry_proxy%data(:) = data_proxy%data(t::2)
    end do

    ! Initialise interpolation variables
    call dData%initialise( model_proxy%vspace )
    call interp_gradient%initialise( model_proxy%vspace )

    dt_recip = 1.0_r_def/(time_window(2)-time_window(1))

    ! Get the current time from xios. This will change when the clock is
    ! properly integrated.
    call xios_get_current_date(datetime)
    day_of_year   = int(xios_date_get_day_of_year(datetime), i_def)
    second_of_day = real(xios_date_get_second_of_day(datetime), r_def)
    time_diff     = day_of_year * 24.0_r_def *3600.0_r_def &
                  + second_of_day - time_window(1)

    ! Perform linear interpolation and populate model field with interpolated data
    call invoke( X_minus_Y( dData, field_time_entries(2), field_time_entries(1) ), &
                 a_times_X( interp_gradient, dt_recip, dData ),                    &
                 inc_a_times_X( time_diff, interp_gradient ),                      &
                 X_plus_Y( model_field, field_time_entries(1), interp_gradient ) )

  end subroutine interp_field_1d

end module lfric_xios_time_axis_mod
