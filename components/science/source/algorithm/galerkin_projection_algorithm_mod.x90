!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE.original which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------
!> Computes the galerkin projection of fields.
!>
!> As a first step fields are projected into a continuous space.
!>
module galerkin_projection_algorithm_mod

  use constants_mod,                   only: r_def, i_def
  use function_space_collection_mod,   only: function_space_collection
  use field_mod,                       only: field_type
  use finite_element_config_mod,       only: element_order
  use fs_continuity_mod,               only: W2, W3
  use gp_rhs_kernel_mod,               only: gp_rhs_kernel_type
  use gp_vector_rhs_kernel_mod,        only: gp_vector_rhs_kernel_type
  use log_mod,                         only: log_event, log_scratch_space, &
                                             log_level_debug
  use mesh_mod,                        only: mesh_type
  use operator_mod,                    only: operator_type
  use quadrature_xyoz_mod,             only: quadrature_xyoz_type
  use sci_mass_matrix_solver_alg_mod,  only: mass_matrix_solver_alg

  implicit none

  private
  public :: galerkin_projection_algorithm

contains

  !> @brief Computes the galerkin projection of a field into another.
  !>
  !> @details Computes the Galerkin projection of a field <code>f_in</code>
  !>          into the space of field <code>f_out</code>.
  !>
  !>          Solves \f$M * f_{out} = rhs\f$ where
  !>          \f$rhs = \lfloor\gamma * f_{in}\rfloor\f$ and \f$\gamma\f$ is a test
  !>          function from the same space as \f$f_{out}\f$ and \f$M\f$ is
  !>          the mass matrix for the space of \f$f_{out}\f$.
  !>
  !>          If <code>f_in</code> is in a vector space then it is decomposed
  !>          into orthogonal components and the galerkin projection of each
  !>          component is computed.
  !>
  !> @param[out] f_out     Field to project onto.
  !> @param[in]  f_in      Field to project.
  !> @param[in]  chi       Field entity co-ordinates.
  !> @param[in]  panel_id  Cell orientation.
  !> @param[in]  mesh      Operating on this mesh.
  !> @param[in]  qr        Quadrature rule to perform integrations.
  !>
  !> @todo Why is mesh passed all the way down here given that it is always
  !>       available from the fields we are working on. See lfric_apps:#118
  !>
  subroutine galerkin_projection_algorithm( f_out,    &
                                            f_in,     &
                                            chi,      &
                                            panel_id, &
                                            mesh,     &
                                            qr)

    implicit none

    ! Field to output
    type(field_type),           intent(inout) :: f_out(:)

    ! Field to input
    type(field_type),           intent(in)    :: f_in

    ! Coordinate fields
    type(field_type),           intent(in)    :: chi(:)
    type(field_type),           intent(in)    :: panel_id
    type(mesh_type), pointer,   intent(in)    :: mesh

    type(quadrature_xyoz_type), intent(in)    :: qr

    type(field_type) :: rhs(size(f_out))
    type(field_type) :: w2_field
    integer(i_def)   :: out_fs
    integer(i_def)   :: idx

    ! Create continuous fields to project data into
    out_fs = f_out(1)%which_function_space()
    do idx = 1, size(f_out)
      call rhs(idx)%initialise( vector_space = f_out(1)%get_function_space() )
      call invoke( setval_c(rhs(idx), 0.0_r_def) )
    end do

    ! Project field into continuous space
    write( log_scratch_space, '(A)' ) 'Computing Galerkin projection...'
    call log_event( log_scratch_space, log_level_debug )
    if ( f_in%which_function_space() == out_fs ) then
      write( log_scratch_space, '(A)' ) '   function spaces match, no projection needed'
      call log_event( log_scratch_space, log_level_debug )
      call invoke( setval_X(f_out(1), f_in) )
    else
      if ( size(f_out) == 1 ) then
        write( log_scratch_space, '(A)' ) '    scalar field ... '
        call log_event( log_scratch_space, log_level_debug )
        call invoke( gp_rhs_kernel_type(rhs(1), f_in, chi, panel_id, qr) )
      else
        write( log_scratch_space, '(A)' ) '    vector field ... '
        call log_event( log_scratch_space, log_level_debug )

        ! Create dummy W2 field for kernel to perform check again
        call w2_field%initialise(                          &
          vector_space = function_space_collection%get_fs( &
            mesh, element_order, W2                        &
          )                                                &
        )

        call invoke( &
          gp_vector_rhs_kernel_type( &
            rhs, f_in, chi, panel_id, w2_field, qr &
          ) &
        )
      end if
      do idx = 1, size(f_out)
        call mass_matrix_solver_alg( f_out(idx), rhs(idx) )
      end do
    end if

  end subroutine galerkin_projection_algorithm

end module galerkin_projection_algorithm_mod
