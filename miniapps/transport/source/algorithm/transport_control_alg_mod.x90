!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Control module for the transport miniapp, where the wind is prescribed.

module transport_control_alg_mod

  use constants_mod,                     only: i_def, r_def, l_def, str_def
  use extrusion_mod,                     only: SHIFTED
  use field_mod,                         only: field_type
  use log_mod,                           only: log_event,       &
                                               LOG_LEVEL_ERROR, &
                                               LOG_LEVEL_INFO,  &
                                               log_scratch_space
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use mr_indices_mod,                    only: nummr
  use runtime_tools_mod,                 only: find_mesh_index
  use transport_config_mod,              only: moisture_eqn, &
                                               moisture_eqn_conservative, &
                                               moisture_eqn_consistent
  use transport_enumerated_types_mod,    only: equation_conservative, &
                                               equation_advective,    &
                                               equation_consistent
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_runtime_alg_mod,         only: transport_runtime_type
  use transport_runtime_collection_mod,  only: set_transport_runtime
  use transport_metadata_collection_mod, only: transport_metadata_collection_type

  implicit none

  private

  logical(kind=l_def) :: time_varying_wind
  logical(kind=l_def) :: variables_allocated = .false.

  ! Initial fields, to be compared against at the end for measuring errors
  ! These are allocatable as there might be one for each mesh
  type(field_type), allocatable :: rho0(:)
  type(field_type), allocatable :: theta0(:)
  type(field_type), allocatable :: tracer0(:)
  type(field_type), allocatable :: mr0(:,:)

  type(transport_metadata_collection_type) :: transport_metadata_collection

  ! Contained suroutines
  public :: transport_prerun_setup
  public :: transport_init
  public :: transport_step
  public :: transport_final

contains

  !=============================================================================
  !> @brief Set up various entities for transport-only time stepping.
  !> @details Taking the number of meshes, this allocates arrays of true fields
  !!          and sets up whether the wind is to be updated and the metadata for
  !!          the transported variables.
  !> @param[in] number_of_meshes Number of meshes to transport on
  subroutine transport_prerun_setup( number_of_meshes )

    use transport_config_mod,    only: profile_size,      &
                                       field_names,       &
                                       scheme,            &
                                       monotone,          &
                                       splitting,         &
                                       horizontal_method, &
                                       vertical_method,   &
                                       log_space,         &
                                       enforce_min_value, &
                                       min_value,         &
                                       reversible

    use initial_wind_config_mod, only: profile,                      &
                                       profile_curl_free_reversible, &
                                       profile_div_free_reversible,  &
                                       profile_xy_NL_case_1,         &
                                       profile_yz_NL_case_1,         &
                                       profile_NL_case_1,            &
                                       profile_NL_case_2,            &
                                       profile_NL_case_3,            &
                                       profile_NL_case_4,            &
                                       profile_hadley_like_dcmip,    &
                                       profile_sbr_with_vertical,    &
                                       profile_dcmip_101,            &
                                       profile_vertical_deformation

    implicit none

    integer(kind=i_def), intent(in) :: number_of_meshes

    integer(kind=i_def)            :: equation_form
    integer(kind=i_def)            :: config
    type(transport_metadata_type)  :: transport_metadata
    logical(kind=l_def), parameter :: use_divergence_factor = .false.

    ! ------------------------------------------------------------------------ !
    ! Allocate arrays for initial/true fields
    ! ------------------------------------------------------------------------ !
    if (.not. variables_allocated) then
      if (.not. allocated(rho0)) allocate(rho0(number_of_meshes))
      if (.not. allocated(theta0)) allocate(theta0(number_of_meshes))
      if (.not. allocated(tracer0)) allocate(tracer0(number_of_meshes))
      if (.not. allocated(mr0)) allocate(mr0(nummr, number_of_meshes))
      variables_allocated = .true.
    else
      call log_event('Variables have already been allocated for ' // &
                     'transport_control', LOG_LEVEL_ERROR)
    end if

    ! ------------------------------------------------------------------------ !
    ! Determine if wind is time-varying or not
    ! ------------------------------------------------------------------------ !
    if ((profile == profile_xy_NL_case_1)         .or. &
        (profile == profile_yz_NL_case_1)         .or. &
        (profile == profile_NL_case_1)            .or. &
        (profile == profile_NL_case_2)            .or. &
        (profile == profile_NL_case_3)            .or. &
        (profile == profile_NL_case_4)            .or. &
        (profile == profile_hadley_like_dcmip)    .or. &
        (profile == profile_div_free_reversible)  .or. &
        (profile == profile_curl_free_reversible) .or. &
        (profile == profile_sbr_with_vertical)    .or. &
        (profile == profile_dcmip_101)            .or. &
        (profile == profile_vertical_deformation))then
      time_varying_wind = .true.
    else
      time_varying_wind = .false.
    end if

    ! ------------------------------------------------------------------------ !
    ! Set up metadata for variables
    ! ------------------------------------------------------------------------ !
    ! Set up linked list of metadatas
    transport_metadata_collection = transport_metadata_collection_type()

    ! Set up configs using namelist entries
    do config = 1, profile_size

      write(log_scratch_space,'(3A)') 'Setting up ',trim(field_names(config)),' transport metadata'
      call log_event(log_scratch_space, LOG_LEVEL_INFO)

      ! Set hardwired defaults based upon which field is being advected
      if ( trim(field_names(config)) == 'rho' .or. &
          (trim(field_names(config)) == 'mr' .and. &
           moisture_eqn == moisture_eqn_conservative ) ) then
        equation_form = equation_conservative
      else if ( trim(field_names(config)) == 'mr' .and. &
                moisture_eqn == moisture_eqn_consistent ) then
        equation_form = equation_consistent
      else
        equation_form = equation_advective
      end if

      transport_metadata = transport_metadata_type( field_names(config),       &
                                                    equation_form,             &
                                                    splitting(config),         &
                                                    scheme(config),            &
                                                    horizontal_method(config), &
                                                    vertical_method(config),   &
                                                    monotone(config),          &
                                                    enforce_min_value(config), &
                                                    min_value(config),         &
                                                    log_space(config),         &
                                                    use_divergence_factor,     &
                                                    reversible(config) )

      call transport_metadata_collection%set_transport_metadata(transport_metadata)

    end do

  end subroutine transport_prerun_setup


  !=============================================================================
  !> @brief Stores the initial values of the fields to be transported.
  !> @details This copies the initial fields to be transported into variables
  !!          to be held in this algorithm. At the end of the simulation, this
  !!          allows us to compare the final states of the field with their
  !!          initial values, so that the errors incurred by the transport can
  !!          be measured.
  !> @param[in] rho     Dry density field (in W3)
  !> @param[in] theta   Potential temperature field (in Wtheta)
  !> @param[in] tracer  Tracer field obeying advective equation (in W3)
  !> @param[in] mr      Bundle of mixing ratio fields (in Wtheta)
  subroutine transport_init( rho, theta, tracer, mr )

    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_init
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_init

    implicit none

    ! Prognostic fields
    type(field_type), intent(in) :: rho, theta, tracer
    type(field_type), intent(in) :: mr(nummr)

    ! Internal variables
    integer(kind=i_def)          :: mesh_index

    type(mesh_type), pointer     :: primary_mesh => null()
    type(mesh_type), pointer     :: shifted_mesh => null()

    primary_mesh => rho%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

    mesh_index = find_mesh_index(primary_mesh%get_id())

    ! Store initial values for computing errors
    call rho%copy_field(rho0(mesh_index))
    call theta%copy_field(theta0(mesh_index))
    call tracer%copy_field(tracer0(mesh_index))
    call mr(1)%copy_field(mr0(1,mesh_index))

    ! Initialise any necessary transport fields or coefficients
    call reconstruct_w3_field_alg_init(primary_mesh)
    call wt_advective_update_alg_init(primary_mesh)
    call reconstruct_w3_field_alg_init(shifted_mesh)

    nullify(primary_mesh, shifted_mesh)

  end subroutine transport_init


  !=============================================================================
  !> @brief Performs a single transport-only step.
  !> @details This performs a single step of gungho in transport-only mode, by
  !!          transporting rho, theta, tracer and moisture mixing ratios. The
  !!          transporting wind field is prescribed, but may be updated if a
  !!          time-varying profile has been specified.
  !> @param[in]     timestep           Integer from the clock denoting the step
  !> @param[in]     model_dt           Time difference across time step in seconds
  !> @param[in,out] wind               The transporting wind field
  !> @param[in,out] rho                Dry density field to transport
  !> @param[in,out] theta              Pot. temperature field to transport
  !> @param[in,out] tracer             Tracer field to transport
  !> @param[in,out] mr                 Bundle of mixing ratio fields to transport
  !> @param[in]     nummr_to_transport Number of moisture species to transport
  subroutine transport_step( timestep, model_dt, wind, &
                             rho, theta, tracer, mr,   &
                             nummr_to_transport )

    use field_bundle_mod,                 only: clone_bundle, copy_bundle
    use init_gungho_prognostics_alg_mod,  only: init_u_field
    use moist_mr_transport_alg_mod,       only: moist_mr_transport_alg
    use transport_field_mod,              only: transport_field

    implicit none

    ! Arguments
    integer(kind=i_def), intent(in)    :: timestep
    real(kind=r_def),    intent(in)    :: model_dt
    type(field_type),    intent(inout) :: wind, rho, theta, tracer
    type(field_type),    intent(inout) :: mr(nummr)
    integer(kind=i_def), intent(in)    :: nummr_to_transport

    real(kind=r_def)             :: current_time
    type(field_type)             :: rho_n, theta_n
    type(field_type)             :: tracer_n, mr_n(nummr)

    type(transport_runtime_type) :: transport_runtime
    type(mesh_type),     pointer :: primary_mesh => null()
    type(mesh_type),     pointer :: shifted_mesh => null()


    type(transport_metadata_type), pointer :: transport_metadata => null()

    ! Update the transporting wind field
    if ( time_varying_wind ) then
      current_time = model_dt * real(timestep, r_def)
      call init_u_field(wind, current_time)
    end if

    primary_mesh => wind%get_mesh()
    shifted_mesh => mesh_collection%get_mesh(primary_mesh, SHIFTED)

    ! Create transport_runtime object (advecting wind etc)
    transport_runtime = transport_runtime_type(wind, wind, model_dt, shifted_mesh)
    call set_transport_runtime(transport_runtime)

    ! Transport dry density
    call log_event( "Transporting density...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('rho')
    call rho%copy_field(rho_n)
    call transport_field(rho, rho_n, model_dt, transport_metadata)

    ! Transport potential temperature
    call log_event( "Transporting potential temperature...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('theta')
    call theta%copy_field(theta_n)
    call transport_field(theta, theta_n, model_dt, transport_metadata)

    ! Transport W3 tracer
    call log_event( "Transporting tracer...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('tracer')
    call tracer%copy_field(tracer_n)
    call transport_field(tracer, tracer_n, model_dt, transport_metadata)

    ! Transport moisture mixing ratio fields
    call log_event("Transporting moisture mixing ratio fields...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('mr')
    call clone_bundle(mr, mr_n, nummr)
    call copy_bundle(mr, mr_n, nummr)
    call moist_mr_transport_alg(mr, mr_n, nummr_to_transport, &
                                model_dt, transport_metadata)

    nullify(primary_mesh, shifted_mesh)

  end subroutine transport_step


  !=============================================================================
  !> @brief Finalises transport only run.
  !> @details Calculates final error norms for transport schemes and calls
  !!          finalising routines for transport only run.
  !> @param[in] rho      Transported dry density field
  !> @param[in] theta    Transported pot. temperature field
  !> @param[in] tracer   Transported tracer field
  !> @param[in] mr       Transported bundle of mixing ratio fields
  subroutine transport_final( rho, theta, tracer, mr )

    use transport_stats_mod,          only: write_transport_stats
    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_final
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_final

    implicit none

    ! Prognostic fields
    type(field_type), intent(in) :: rho, theta, tracer
    type(field_type), intent(in) :: mr(nummr)

    ! Internal variables
    character(str_def)  :: field_name
    integer(kind=i_def) :: mesh_index
    type(mesh_type), pointer :: mesh => null()

    mesh => rho%get_mesh()
    mesh_index = find_mesh_index(mesh%get_id())

    ! Calculate and write out statistics
    field_name = 'rho'
    call write_transport_stats(rho, rho0(mesh_index), field_name)
    field_name = 'theta'
    call write_transport_stats(theta, theta0(mesh_index), field_name)
    field_name = 'tracer'
    call write_transport_stats(tracer, tracer0(mesh_index), field_name)
    field_name = 'mr'
    call write_transport_stats(mr(1), mr0(1,mesh_index), field_name)

    call reconstruct_w3_field_alg_final()
    call wt_advective_update_alg_final()

    nullify( mesh )

  end subroutine transport_final

end module transport_control_alg_mod
