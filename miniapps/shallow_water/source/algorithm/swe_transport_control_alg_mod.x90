!-----------------------------------------------------------------------------
! (c) Crown copyright 2022 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!> @brief Module controlling the transport of the shallow water miniapp's
!!        prognostic variables.

module swe_transport_control_alg_mod

  use combine_w2_field_kernel_mod,       only: combine_w2_field_kernel_type
  use constants_mod,                     only: i_def, r_def, l_def
  use derived_config_mod,                only: bundle_size
  use enforce_bc_kernel_mod,             only: enforce_bc_kernel_type
  use field_mod,                         only: field_type
  use field_indices_mod,                 only: isw_u, isw_g, isw_b, isw_q
  use field_vector_mod,                  only: field_vector_type
  use finite_element_config_mod,         only: element_order, nqp_exact
  use fs_continuity_mod,                 only: W1, W3, W2v
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use geometric_constants_mod,           only: get_coordinates, &
                                               get_panel_id
  use local_mesh_mod,                    only: local_mesh_type
  use log_mod,                           only: log_event,       &
                                               LOG_LEVEL_ERROR, &
                                               LOG_LEVEL_INFO,  &
                                               log_scratch_space
  use matrix_vector_kernel_mod,          only: matrix_vector_kernel_type
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use model_clock_mod,                   only: model_clock_type
  use quadrature_rule_gaussian_mod,      only: quadrature_rule_gaussian_type
  use quadrature_xyoz_mod,               only: quadrature_xyoz_type
  use runtime_tools_mod,                 only: find_mesh_index
  use shallow_water_settings_config_mod, only: thermal_swe,            &
                                               momentum_form,          &
                                               momentum_form_momentum, &
                                               momentum_form_vector_invariant
  use transport_config_mod,              only: cheap_update
  use transport_enumerated_types_mod,    only: scheme_mol_3d, &
                                               scheme_split,  &
                                               splitting_hv,  &
                                               splitting_vh,  &
                                               splitting_strang_vhv
  use transport_metadata_mod,            only: transport_metadata_type
  use transport_metadata_collection_mod, only: transport_metadata_collection_type
  use transport_runtime_alg_mod,         only: transport_runtime_type
  use transport_runtime_collection_mod,  only: init_transport_runtime_collection, &
                                               set_transport_runtime,             &
                                               get_transport_runtime
  use vorticity_advection_kernel_mod,    only: vorticity_advection_kernel_type

  implicit none

  private

  type(transport_metadata_collection_type) :: transport_metadata_collection

  ! Contained suroutines
  public :: swe_transport_control_alg_init
  public :: swe_transport_control_alg_step
  public :: swe_transport_control_alg_final

contains

  !=============================================================================
  !> @brief Create all the initialisation structures required for transport in
  !!        the shallow water model.
  !> @params[in] mesh_id   The ID of the mesh to initialise on
  subroutine swe_transport_control_alg_init(mesh)

    use reconstruct_w3_field_alg_mod, only: reconstruct_w3_field_alg_init
    use wt_advective_update_alg_mod,  only: wt_advective_update_alg_init
    use transport_config_mod,         only: profile_size,          &
                                            field_names,           &
                                            equation_form,         &
                                            scheme,                &
                                            splitting,             &
                                            horizontal_method,     &
                                            vertical_method,       &
                                            enforce_min_value,     &
                                            min_value,             &
                                            log_space,             &
                                            reversible,            &
                                            horizontal_monotone,   &
                                            vertical_monotone,     &
                                            vertical_monotone_order

    implicit none

    type(mesh_type), pointer, intent(in) :: mesh

    integer(kind=i_def)           :: config
    type(transport_metadata_type) :: transport_metadata

    integer(kind=i_def), allocatable :: local_mesh_ids(:)
    type(local_mesh_type),   pointer :: local_mesh => null()

    ! Set up metadata field collection
    transport_metadata_collection = transport_metadata_collection_type()

    ! Set up configs using namelist entries
    do config = 1, profile_size

      write(log_scratch_space,'(3A)') 'Setting up ',trim(field_names(config)),' transport metadata'
      call log_event(log_scratch_space, LOG_LEVEL_INFO)

      transport_metadata = transport_metadata_type( field_names(config),             &
                                                    equation_form(config),           &
                                                    splitting(config),               &
                                                    scheme(config),                  &
                                                    horizontal_method(config),       &
                                                    vertical_method(config),         &
                                                    horizontal_monotone(config),     &
                                                    vertical_monotone(config),       &
                                                    vertical_monotone_order(config), &
                                                    enforce_min_value(config),       &
                                                    min_value(config),               &
                                                    log_space(config),               &
                                                    reversible(config) )

      call transport_metadata_collection%set_transport_metadata(transport_metadata)

    end do

    ! Initialise any necessary transport fields or coefficients
    call reconstruct_w3_field_alg_init( mesh )
    call wt_advective_update_alg_init( mesh )

    ! Initialise transport_runtime_collection
    ! Only one mesh
    allocate(local_mesh_ids(1))
    local_mesh => mesh%get_local_mesh()
    local_mesh_ids(1) = local_mesh%get_id()
    call init_transport_runtime_collection(local_mesh_ids)

  end subroutine swe_transport_control_alg_init


  !=============================================================================
  !> @brief Advection of prognostic variables for the shallow water miniapp.
  !> @param[in,out] advection_inc   Advection increment of the shallow water
  !!                                prognostics [u, geopot, buoyancy, q]
  !> @param[in]     advected_fields Fields to advect: [u, geopot, buoyancy, q]
  !> @param[in]     state_n         Fields at time n
  !> @param[in]     state_np1       Estimate of fields at time n+1
  !> @param[in]     model_clock     Time within the model
  !> @param[in]     outer           Outer (advection) iteration number
  !> @param[in]     wind_prev       (Optional) Estimate of end of timestep wind
  !!                                from previous outer iteration

  subroutine swe_transport_control_alg_step( advection_inc,   &
                                             advected_fields, &
                                             state_n,         &
                                             state_np1,       &
                                             model_clock,     &
                                             outer,           &
                                             wind_prev )

    use fem_constants_mod,               only: get_mass_matrix
    use operator_mod,                    only: operator_type
    use transport_field_mod,             only: transport_field
    use wind_transport_alg_mod,          only: wind_transport_alg
    use io_config_mod,                   only: subroutine_timers
    use timer_mod,                       only: timer

    implicit none

    ! Arguments
    type(field_vector_type),         intent(inout) :: advection_inc
    type(field_vector_type), target, intent(in)    :: advected_fields
    type(field_vector_type), target, intent(in)    :: state_np1
    type(field_vector_type), target, intent(in)    :: state_n
    class(model_clock_type),         intent(in)    :: model_clock
    integer(kind=i_def),             intent(in)    :: outer
    type(field_type),                intent(in), optional :: wind_prev

    ! Fields from advected_fields, state_n and state_np1 vector
    type(field_type), pointer :: wind_np1 => null(), &
                                 wind_n   => null(), &
                                 wind     => null(), &
                                 geopot   => null(), &
                                 buoyancy => null(), &
                                 q        => null()

    ! Fields updated during transport (but not used in model update)
    type(field_type) :: geopot_np1
    type(field_type) :: q_np1
    type(field_type) :: buoyancy_np1
    type(field_vector_type) :: prev_inc

    ! Function space
    type(function_space_type), pointer :: w1_fs => null()
    type(function_space_type), pointer :: w2v_fs => null()

    ! Internal variables
    logical(kind=l_def) :: cheap_update_flag
    type(transport_runtime_type) :: transport_runtime
    type(transport_runtime_type), pointer :: transport_runtime_get => null()
    type(transport_metadata_type), pointer :: transport_metadata => null()

    ! Internal variables
    type(field_type), pointer :: q_mass_flux_get => null()
    type(field_type) :: buoy_inc,     &
                        constant_one, &
                        q_geopot,     &
                        wind_for_adv, &
                        q_mass_flux,  &
                        q_mass_flux_vert

    ! Coordinates, Panel ID, and Mass Matrix
    type(field_type),    pointer :: chi(:)   => null()
    type(field_type),    pointer :: panel_id => null()
    type(operator_type), pointer :: mm_wb    => null()

    ! Quadrature
    type(quadrature_xyoz_type)          :: qr
    type(quadrature_rule_gaussian_type) :: quadrature_rule

    real(r_def) :: cast_dt

    if ( subroutine_timers ) call timer('swe_transport_control_alg_step')

    ! ------------------------------------------------------------------------ !
    ! Pre-transport initialisation tasks
    ! ------------------------------------------------------------------------ !

    ! Get individual advected, state_n and state_np1 fields
    wind     => advected_fields%vector(isw_u)
    q        => advected_fields%vector(isw_q)
    buoyancy => advected_fields%vector(isw_b)
    geopot   => advected_fields%vector(isw_g)
    wind_np1 => state_np1%vector(isw_u)
    wind_n   => state_n%vector(isw_u)

    ! Set up cheap update flag and store advection_inc from first outer iteration
    call wind_for_adv%initialise(vector_space = wind_n%get_function_space())
    call invoke( setval_X(wind_for_adv, wind_n) )
    if (cheap_update .AND. present(wind_prev)) then
      cheap_update_flag = .true.
      if (outer > 2) then
        call invoke( setval_X(wind_for_adv, wind_prev) )
      end if
    else
      cheap_update_flag = .false.
    end if
    prev_inc = field_vector_type(bundle_size)
    prev_inc = advection_inc

    ! Create transport_runtime object (advecting wind etc)
    transport_runtime = transport_runtime_type(wind_for_adv, wind_np1, model_clock, outer, cheap_update_flag)
    call set_transport_runtime(transport_runtime)

    ! Initialise geopotential variables
    call geopot_np1%initialise(vector_space = geopot%get_function_space())

    ! ------------------------------------------------------------------------ !
    ! Transport of prognostic variables
    ! ------------------------------------------------------------------------ !

    cast_dt = real( model_clock%get_seconds_per_step(), r_def )

    ! ------------------------------------------------------------------------ !
    ! Transport geopotential
    call log_event( "Transporting geopotential...", LOG_LEVEL_INFO)
    transport_metadata => transport_metadata_collection%get_transport_metadata('geopot')
    call transport_field( geopot_np1, geopot, &
                          cast_dt, transport_metadata )
    call invoke( X_minus_Y( advection_inc%vector(isw_g), geopot_np1, &
                            geopot ) )

    ! ------------------------------------------------------------------------ !
    ! Transport buoyancy
    if ( thermal_swe ) then

      ! Initialise updated buoyancy
      call buoyancy_np1%initialise(vector_space = buoyancy%get_function_space())

      call log_event( "Transporting buoyancy...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('buoyancy')
      call transport_field( buoyancy_np1, buoyancy, &
                            cast_dt, transport_metadata )
      call invoke( X_minus_Y( advection_inc%vector(isw_b), buoyancy_np1, &
                              buoyancy ) )
      ! The increment is now pointwise. Depending upon the temporal discretisation
      ! this may need converting into weak form by multiplying by the mass matrix
      mm_wb => get_mass_matrix(W3, buoyancy%get_mesh_id() )
      call buoy_inc%initialise( vector_space = &
                                buoyancy_np1%get_function_space() )
      call invoke( setval_X(buoy_inc, advection_inc%vector(isw_b)),       &
                   setval_c(advection_inc%vector(isw_b), 0.0_r_def),      &
                   matrix_vector_kernel_type(advection_inc%vector(isw_b), &
                                             buoy_inc, mm_wb) )

      nullify( mm_wb )

    end if

    ! ------------------------------------------------------------------------ !
    ! Transport wind field

    ! Vector invariant or momentum form of the momentum equations determines
    ! advection terms for wind

    select case (momentum_form)

    case(momentum_form_vector_invariant)

      ! If vector invariant form, calculate the PV mass flux, Q=q*geopot*u
      ! and use this in the momentum equations.
      call log_event( "Transporting PV...", LOG_LEVEL_INFO)

      ! Get transport runtime
      transport_runtime_get => get_transport_runtime(geopot%get_mesh())

      ! Initialise PV variables
      call q_geopot%initialise(vector_space = q%get_function_space())
      call q_np1%initialise(vector_space = q%get_function_space())

      ! Initialise vorticity advection function spaces and quadrature
      w1_fs    => function_space_collection%get_fs( geopot%get_mesh(), element_order, W1 )
      w2v_fs   => function_space_collection%get_fs( geopot%get_mesh(), element_order, W2v )
      chi      => get_coordinates(geopot%get_mesh_id())
      panel_id => get_panel_id(geopot%get_mesh_id())
      qr = quadrature_xyoz_type(nqp_exact, quadrature_rule)

      ! Calculate q*phi
      call invoke( X_times_Y(q_geopot,q,geopot) )
      transport_metadata => transport_metadata_collection%get_transport_metadata('q')
      call transport_field( q_np1, q_geopot, &
                            cast_dt, transport_metadata )

      ! The PV mass flux depends on whether splitting has been used
      ! we require it to be in W2 space
      call q_mass_flux%initialise(vector_space = wind%get_function_space())

      select case ( transport_metadata%get_scheme() )
      case ( scheme_mol_3d )
        q_mass_flux_get => transport_runtime_get%get_dry_flux(geopot%get_mesh_id(), 1)
        call invoke( setval_X(q_mass_flux, q_mass_flux_get) )
      case ( scheme_split )
        ! Get the correct directional flux based on which splitting is used
        if ( transport_metadata%get_splitting() == splitting_hv ) then
          ! HV splitting requires flux from first splitting stage
          q_mass_flux_get => transport_runtime_get%get_dry_flux(geopot%get_mesh_id(), 1)
        else if ( transport_metadata%get_splitting() == splitting_vh .OR. &
                  transport_metadata%get_splitting() == splitting_strang_vhv ) then
          ! VH or VHV splitting requires flux from second splitting stage
          q_mass_flux_get => transport_runtime_get%get_dry_flux(geopot%get_mesh_id(), 2)
        else
          call log_event('Only HV, VH, or VHV splitting is valid for shallow water', &
                          LOG_LEVEL_ERROR)
        end if
        ! Combine W2h and W2v flux parts into a W2 field
        call q_mass_flux_vert%initialise( w2v_fs )
        call invoke( setval_c(q_mass_flux_vert, 0.0_r_def) )
        call invoke( combine_w2_field_kernel_type( q_mass_flux, q_mass_flux_get, q_mass_flux_vert ) )
      case default
        call log_event('Trying to transport PV with unrecognised scheme', &
                        LOG_LEVEL_ERROR)
      end select

      ! If vector_invariant form, use the PV mass flux for the velocity advection
      call constant_one%initialise( vector_space = w1_fs )
      call invoke( setval_c(constant_one, 1.0_r_def),                                &
                   setval_c(advection_inc%vector(isw_u), 0.0_r_def),                 &
                   vorticity_advection_kernel_type(advection_inc%vector(isw_u),      &
                                                   q_mass_flux,                      &
                                                   constant_one, chi, panel_id, qr), &
                   enforce_bc_kernel_type(advection_inc%vector(isw_u)),              &
                   inc_a_times_X(cast_dt,advection_inc%vector(isw_u)) )

      nullify( w1_fs, w2v_fs, q_mass_flux_get, chi, panel_id )

    case(momentum_form_momentum)

      call log_event( "Transporting wind...", LOG_LEVEL_INFO)
      transport_metadata => transport_metadata_collection%get_transport_metadata('wind')
      call wind_transport_alg( advection_inc%vector(isw_u), wind, &
                               cast_dt, transport_metadata )
      ! We don't change advection_inc%vector(isw_u) as wind_transport_alg
      ! already returns weak increment

    end select    ! momentum_form

    ! If cheap update we need to add the 1st iteration state increments
    if ( cheap_update_flag .AND. outer > 1) then
      ! Add the previous iteration state increments for geopotential and u
      ! On the second outer iteration we have
      ! advection_inc = dt increment(field,(wind_np1-wind_n)/2)
      ! prev_inc      = dt increment(field,(wind_n)/2)
      ! We set
      ! advection_inc = advection_inc + prev_inc = dt increment(field,(wind_np1+wind_n)/2)
      ! This carries forward for further outer iterations
      call invoke( inc_X_plus_Y(advection_inc%vector(isw_g),prev_inc%vector(isw_g)), &
                   inc_X_plus_Y(advection_inc%vector(isw_u),prev_inc%vector(isw_u)) )
      if (thermal_swe) then
        call invoke( inc_X_plus_Y(advection_inc%vector(isw_b),prev_inc%vector(isw_b)) )
      end if
    end if

    if ( subroutine_timers ) call timer('swe_transport_control_alg_step')

  end subroutine swe_transport_control_alg_step

  !=============================================================================
  !> @brief Calls finalising routines for shallow water transport.
  subroutine swe_transport_control_alg_final()

    use reconstruct_w3_field_alg_mod,     only: reconstruct_w3_field_alg_final
    use wt_advective_update_alg_mod,      only: wt_advective_update_alg_final
    use transport_runtime_collection_mod, only: transport_runtime_collection_final

    implicit none

    call reconstruct_w3_field_alg_final()
    call wt_advective_update_alg_final()
    call transport_runtime_collection_final()

  end subroutine swe_transport_control_alg_final


end module swe_transport_control_alg_mod
