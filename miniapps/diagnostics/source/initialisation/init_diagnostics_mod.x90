!-----------------------------------------------------------------------------
! (c) Crown copyright 2019 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> @brief Initialisation functionality for the diagnostics miniapp

!> @details Handles init of prognostic fields and through the call to
!>          runtime_contants the coordinate fields and fem operators

module init_diagnostics_mod

    use constants_mod,                 only : i_def, str_short, str_def, r_def
    use axisspec_mod,                  only : axisspec_type
    use field_mod,                     only : field_type
    use field_parent_mod,              only : write_interface
    use field_collection_mod,          only : field_collection_type
    use fieldspec_mod,                 only : fieldspec_type, &
                                              non_spatial_dimension_iterator_type
    use fieldspec_collection_mod,      only : fieldspec_collection_type, &
                                              fieldspec_collection_iterator_type
    use function_space_collection_mod, only : function_space_collection
    use driver_model_data_mod,         only : model_data_type
    use io_config_mod,                 only : write_diag, &
                                              use_xios_io
    use io_driver_enum_mod,            only : name_from_io_driver
    use lfric_xios_write_mod,          only : write_field_face, &
                                              write_field_edge, &
                                              write_field_node, &
                                              write_field_single_face
    use log_mod,                       only : log_event, &
                                              log_scratch_space , &
                                              LOG_LEVEL_INFO, &
                                              LOG_LEVEL_ERROR
    use mesh_mod,                      only : mesh_type
    use non_spatial_dimension_mod,     only : NUMERICAL, CATEGORICAL
    use pure_abstract_field_mod,       only : pure_abstract_field_type
    use fs_continuity_mod,             only : W0, W2H, W3, Wtheta

    implicit none


contains

    subroutine init_diagnostics( mesh, twod_mesh, chi, panel_id, &
                                 dt, model_data, fieldspec_collection)

        implicit none

        type(mesh_type), intent(in), pointer :: mesh
        type(mesh_type), intent(in), pointer :: twod_mesh

        real(r_def),    intent(in) :: dt

        type (model_data_type), intent(inout) :: model_data
        type (fieldspec_collection_type), intent(in) :: fieldspec_collection

        ! Coordinate field
        type(field_type), intent(inout) :: chi(:)
        type(field_type), intent(inout) :: panel_id

        type (field_type), allocatable :: new_field
        type (field_type), pointer :: tmp_field => null()
        class(pure_abstract_field_type), pointer  :: tmp_field_ptr => null()

        type(field_collection_type), pointer :: depository => null()
        character(str_def)                   :: field_collection_name
        type(field_collection_type), pointer :: field_collection => null()

        type(fieldspec_collection_iterator_type)  :: iterator
        type(fieldspec_type), pointer :: fieldspec => null()

        procedure(write_interface), pointer :: tmp_ptr => null()

        type(axisspec_type), pointer :: vert_axis => null()
        type(axisspec_type), pointer :: non_spatial_axis => null()
        type(non_spatial_dimension_iterator_type) :: nsd_iterator
        integer(i_def) :: length_ndata

        allocate(new_field)

        call log_event('diagnostics: Initialising miniapp ...', LOG_LEVEL_INFO)

        ! Iterate through fieldspec collection
        iterator = fieldspec_collection%get_iterator()
        do
            if (.not. iterator%has_next()) exit
            fieldspec => iterator%next()
            vert_axis => fieldspec%get_vertical_axis()
            non_spatial_axis => null()
            nsd_iterator = fieldspec%get_non_spatial_dimension_iterator()
            length_ndata = 1
            do
                if (.not. nsd_iterator%has_next()) exit
                non_spatial_axis => nsd_iterator%next()
                length_ndata = length_ndata * non_spatial_axis%get_size()
            end do

            ! This needs updating when support for diagnostics to have both
            ! vertical and non-spatial dimensions is required
            if (associated(vert_axis) .and. associated(non_spatial_axis)) then
                call log_event("Diagnostics with both vert and non-spatial axes &
                        &is currently unsupported", LOG_LEVEL_ERROR)

            ! Initialise fields with non-spatial dimensions
            else if (associated(non_spatial_axis)) then
                call new_field%initialise( vector_space =       &
                        function_space_collection%get_fs(       &
                                twod_mesh,                      &
                                fieldspec%get_order(),          &
                                fieldspec%get_function_space(), &
                                length_ndata ),                 &
                        name = trim(fieldspec%get_unique_id()) )

            ! Initialise fields with vertical axis
            else if (associated(vert_axis)) then
                ! Mutable vertical axes use 3d mesh
                if (vert_axis%get_is_primary_axis()) then
                    call new_field%initialise( vector_space =         &
                            function_space_collection%get_fs(         &
                                    mesh,                             &
                                    fieldspec%get_order(),            &
                                    fieldspec%get_function_space() ), &
                            name = trim(fieldspec%get_unique_id()) )
                ! Immutable vertical axes use multi-data field with 2d mesh
                else
                    call new_field%initialise( vector_space =       &
                            function_space_collection%get_fs(       &
                                    twod_mesh,                      &
                                    fieldspec%get_order(),          &
                                    fieldspec%get_function_space(), &
                                    vert_axis%get_size() ),         &
                            name = trim(fieldspec%get_unique_id()) )
                end if

            ! Initialise 2-d fields
            else
                call new_field%initialise( vector_space =         &
                        function_space_collection%get_fs(         &
                                twod_mesh,                        &
                                fieldspec%get_order(),            &
                                fieldspec%get_function_space() ), &
                        name = trim(fieldspec%get_unique_id()) )
            end if

            call log_event("Add to depository", LOG_LEVEL_INFO)
            depository => model_data%get_field_collection("depository")
            call depository%add_field(new_field)

            call depository%get_field(fieldspec%get_unique_id(), tmp_field)
            tmp_field_ptr => tmp_field

            ! Add field collection to model data if necessary
            field_collection_name = fieldspec%get_field_group_id()
            if (.not. model_data%field_collection_exists(field_collection_name)) then
                write(log_scratch_space, '(3A)') "Adding field collection ", &
                        trim(field_collection_name), " to model data"
                call log_event(log_scratch_space, LOG_LEVEL_INFO)
                call model_data%add_empty_field_collection(field_collection_name)
            end if

            call log_event("Adding reference to field to model data field collection", LOG_LEVEL_INFO)
            field_collection => model_data%get_field_collection(field_collection_name)
            call field_collection%add_reference_to_field(tmp_field_ptr)

            ! Set field to 0
            call invoke(setval_c(tmp_field, 0.0_r_def))

            ! Set write behaviour
            if (write_diag .and. use_xios_io) then

                select case(fieldspec%get_function_space())
                    case(W0)
                        tmp_ptr => write_field_node
                    case(W2H)
                        tmp_ptr => write_field_edge
                    case(Wtheta)
                        tmp_ptr => write_field_face
                    case(W3)
                        if (length_ndata > 1) then
                            tmp_ptr => write_field_single_face
                        else
                            tmp_ptr => write_field_face
                        end if
                    case default
                        call log_event("Invalid function space", LOG_LEVEL_ERROR)
                end select

                call tmp_field%set_write_behaviour(tmp_ptr)
            end if
        end do

        call log_event('diagnostics: Miniapp initialised', LOG_LEVEL_INFO)

    end subroutine init_diagnostics

end module init_diagnostics_mod
